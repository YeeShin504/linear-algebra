{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"linear-algebra","text":""},{"location":"#about","title":"About","text":"<p>This project builds on SymPy's Matrix class and is designed for students taking NUS MA1522 Linear Algebra for Computing. It has implementations of most of the algorithms taught during the course (as of Sem 1 AY24/25). Documentation of the code is still a work in progress. </p>"},{"location":"#key-features","title":"Key Features","text":"<ol> <li>Import matrices from \\(\\rm\\LaTeX\\) directly. \\(\\rm\\LaTeX\\) expression can be obtained from Canvas by right-clicking on the equations.</li> <li>Step-by-step workings for most algorithms (including LU Factorisation and SVD)</li> </ol>"},{"location":"#installation-and-usage","title":"Installation and Usage","text":""},{"location":"#installation","title":"Installation","text":""},{"location":"#prerequisites","title":"Prerequisites","text":"<p>This project is best supported in a Jupyter Notebook environment with Python 3.10+. You can download Python from here.</p>"},{"location":"#install-dependencies","title":"Install Dependencies","text":"<p>It is recommended to use a virtual environment for managing dependencies.</p> <ol> <li> <p>Create a virtual environment:     Bash<pre><code>python -m venv venv\n</code></pre></p> </li> <li> <p>Activate the virtual environment:</p> <ul> <li>On Windows:   Bash<pre><code>venv\\Scripts\\activate\n</code></pre></li> <li>On macOS/Linux:   Bash<pre><code>source venv/bin/activate\n</code></pre></li> </ul> </li> <li> <p>Install the library:     Bash<pre><code>pip install ma1522-linear-algebra\n</code></pre>    It is recommended to use a Jupyter Notebook environment to run the code.    Bash<pre><code>pip install notebook\n</code></pre></p> </li> </ol>"},{"location":"#usage","title":"Usage","text":"<p>Create a Jupyter Notebook <code>test.ipynb</code>. Within the notebook, run the following code. Python<pre><code>from ma1522 import *\n\n# Create Matrix objects\nA = Matrix([[1, 2, 3],\n            [4, 5, 5],\n            [7, 8, 9]])\n\nb = Matrix([[1], \n            [2], \n            [3]])\n\n# Join matrices along the columns via `row_join`. \naugmented_matrix = A.aug_line().row_join(b)\n\n# `aug_line` adds a visual line that can be seen using `display`\ndisplay(augmented_matrix)\n\n# Solution to the matrix equation Ax = b can be found using `solve`.\nA.solve(rhs=b)\n\n# Alternatively, the full steps with LU Factorisation can be found using `ref` with the appropriate options.\naugmented_matrix.ref(verbosity=2)\n</code></pre></p> <p>Documentation of more functions can be found here.</p> <p>More usage examples can be found under tutorials.</p> <p>Live demonstration of the library can be found here.</p>"},{"location":"#faq","title":"FAQ","text":""},{"location":"#development","title":"Development","text":""},{"location":"#work-in-progress","title":"Work in Progress","text":"<ul> <li>[ ] Better <code>ref</code> algorithm to determine boundary conditions for a given matrix.</li> </ul>"},{"location":"#credits","title":"Credits","text":"<p>I would like to thank @DenseLance for his contributions.</p>"},{"location":"license/","title":"License","text":"Text Only<pre><code>MIT License\n\nCopyright (c) [2025] [Teng Yee Shin]\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"api/custom_types/","title":"custom_types","text":"<p>Classes:</p> <ul> <li> <code>Shape</code>           \u2013            <p>Enumeration for different matrix shapes and structural properties.</p> </li> <li> <code>Printable</code>           \u2013            <p>Base class for objects that can be printed as \\(\\rm\\LaTeX\\).</p> </li> <li> <code>PartGen</code>           \u2013            <p>Represents a matrix as the sum of a particular solution and a general solution.</p> </li> <li> <code>ScalarFactor</code>           \u2013            <p>Represents a matrix factored into a diagonal matrix and a full matrix.</p> </li> <li> <code>PLU</code>           \u2013            <p>Represents a PLU decomposition of a matrix.</p> </li> <li> <code>RREF</code>           \u2013            <p>Represents the reduced row echelon form (RREF) of a matrix.</p> </li> <li> <code>VecDecomp</code>           \u2013            <p>Represents a vector decomposition into projection and normal components.</p> </li> <li> <code>QR</code>           \u2013            <p>Represents a QR decomposition of a matrix.</p> </li> <li> <code>PDP</code>           \u2013            <p>Represents a PDP diagonalization of a matrix.</p> </li> <li> <code>SVD</code>           \u2013            <p>Represents a symbolic Singular Value Decomposition (SVD) of a matrix.</p> </li> <li> <code>NumSVD</code>           \u2013            <p>Represents a numerical Singular Value Decomposition (SVD) of a matrix.</p> </li> </ul>"},{"location":"api/custom_types/#ma1522.custom_types.Shape","title":"<code>Shape</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration for different matrix shapes and structural properties.</p> <p>This enum defines various matrix shapes that can be used to specify the structure of matrices in mathematical operations and optimizations. Each shape represents a specific pattern of zero and non-zero elements.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; shape = Shape.SYMMETRIC\n&gt;&gt;&gt; print(shape.value)\nSYMMETRIC\n</code></pre> <p>Attributes:</p> <ul> <li> <code>DIAGONAL</code>           \u2013            <p>Diagonal matrix.</p> </li> <li> <code>SCALAR</code>           \u2013            <p>Scalar matrix (diagonal matrix with equal diagonal entries).</p> </li> <li> <code>STRICT_UPPER</code>           \u2013            <p>Strictly upper triangular matrix.</p> </li> <li> <code>STRICT_LOWER</code>           \u2013            <p>Strictly lower triangular matrix.</p> </li> <li> <code>UPPER</code>           \u2013            <p>Upper triangular matrix.</p> </li> <li> <code>LOWER</code>           \u2013            <p>Lower triangular matrix.</p> </li> <li> <code>SYMMETRIC</code>           \u2013            <p>Symmetric matrix.</p> </li> </ul>"},{"location":"api/custom_types/#ma1522.custom_types.Shape.DIAGONAL","title":"<code>DIAGONAL = 'DIAGONAL'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Diagonal matrix.</p> <p>A matrix where all off-diagonal entries are zero. Only elements on the main diagonal (\\(i,j\\) where \\(i = j\\)) can be non-zero. The diagonal entries can have different values and need not be square (unlike SCALAR matrices).</p> Example \\[ \\begin{pmatrix} a &amp; 0 &amp; 0 \\\\ 0 &amp; b &amp; 0 \\\\ 0 &amp; 0 &amp; c \\end{pmatrix} \\]"},{"location":"api/custom_types/#ma1522.custom_types.Shape.SCALAR","title":"<code>SCALAR = 'SCALAR'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Scalar matrix (diagonal matrix with equal diagonal entries).</p> <p>A square matrix where all diagonal entries are equal to the same scalar value, and all off-diagonal entries are zero. This is also known as a scalar matrix or scalar multiple of the identity matrix.</p> Example \\[ \\begin{pmatrix} c &amp; 0 &amp; 0 \\\\ 0 &amp; c &amp; 0 \\\\ 0 &amp; 0 &amp; c \\end{pmatrix} \\]"},{"location":"api/custom_types/#ma1522.custom_types.Shape.STRICT_UPPER","title":"<code>STRICT_UPPER = 'STRICT_UPPER'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Strictly upper triangular matrix.</p> <p>A matrix where all elements on and below the main diagonal are zero. Only elements above the main diagonal (\\(i,j\\) where \\(i &lt; j\\)) can be non-zero.</p> Example \\[ \\begin{pmatrix} 0 &amp; a &amp; b \\\\ 0 &amp; 0 &amp; c \\\\ 0 &amp; 0 &amp; 0 \\end{pmatrix} \\]"},{"location":"api/custom_types/#ma1522.custom_types.Shape.STRICT_LOWER","title":"<code>STRICT_LOWER = 'STRICT_LOWER'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Strictly lower triangular matrix.</p> <p>A matrix where all elements on and above the main diagonal are zero. Only elements below the main diagonal (\\(i,j\\) where \\(i &gt; j\\)) can be non-zero.</p> Example \\[ \\begin{pmatrix} 0 &amp; 0 &amp; 0 \\\\ a &amp; 0 &amp; 0 \\\\ b &amp; c &amp; 0 \\end{pmatrix} \\]"},{"location":"api/custom_types/#ma1522.custom_types.Shape.UPPER","title":"<code>UPPER = 'UPPER'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Upper triangular matrix.</p> <p>A matrix where all elements below the main diagonal are zero. Elements on and above the main diagonal (\\(i,j\\) where \\(i &lt;= j\\)) can be non-zero.</p> Example \\[ \\begin{pmatrix} a &amp; b &amp; c \\\\ 0 &amp; d &amp; e \\\\ 0 &amp; 0 &amp; f \\end{pmatrix} \\]"},{"location":"api/custom_types/#ma1522.custom_types.Shape.LOWER","title":"<code>LOWER = 'LOWER'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Lower triangular matrix.</p> <p>A matrix where all elements above the main diagonal are zero. Elements on and below the main diagonal (\\(i,j\\) where \\(i &gt;= j\\)) can be non-zero.</p> Example \\[ \\begin{pmatrix} a &amp; 0 &amp; 0 \\\\ b &amp; c &amp; 0 \\\\ d &amp; e &amp; f \\end{pmatrix} \\]"},{"location":"api/custom_types/#ma1522.custom_types.Shape.SYMMETRIC","title":"<code>SYMMETRIC = 'SYMMETRIC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Symmetric matrix.</p> <p>A square matrix where elements are symmetric about the main diagonal, meaning \\(A_{i, j} = A_{j,i}\\) for all valid indices \\(i\\) and \\(j\\).</p> Example \\[ \\begin{pmatrix} a &amp; b &amp; c \\\\ b &amp; d &amp; e \\\\ c &amp; e &amp; f \\end{pmatrix} \\]"},{"location":"api/custom_types/#ma1522.custom_types.Printable","title":"<code>Printable()</code>  <code>dataclass</code>","text":"<p>Base class for objects that can be printed as \\(\\rm\\LaTeX\\).</p> <p>Methods:</p> <ul> <li> <code>eval</code>             \u2013              <p>Evaluates the object to a matrix.</p> </li> <li> <code>evalf</code>             \u2013              <p>Evaluates the object to a matrix of floats.</p> </li> </ul>"},{"location":"api/custom_types/#ma1522.custom_types.Printable.eval","title":"<code>eval() -&gt; Matrix</code>  <code>abstractmethod</code>","text":"<p>Evaluates the object to a matrix.</p> Source code in <code>src/ma1522/custom_types.py</code> Python<pre><code>@abstractmethod\ndef eval(self) -&gt; Matrix:\n    \"\"\"Evaluates the object to a matrix.\"\"\"\n    ...\n</code></pre>"},{"location":"api/custom_types/#ma1522.custom_types.Printable.evalf","title":"<code>evalf(*args, **kwargs)</code>","text":"<p>Evaluates the object to a matrix of floats.</p> See Also <ul> <li>SymPy's <code>Matrix.evalf()</code></li> </ul> Source code in <code>src/ma1522/custom_types.py</code> Python<pre><code>def evalf(self, *args, **kwargs):\n    \"\"\"Evaluates the object to a matrix of floats.\n\n    See Also:\n        - SymPy's [`Matrix.evalf()`][sympy.matrices.matrixbase.MatrixBase.evalf]\n    \"\"\"\n    return (self.eval()).evalf(*args, **kwargs)\n</code></pre>"},{"location":"api/custom_types/#ma1522.custom_types.PartGen","title":"<code>PartGen(part_sol: Matrix, gen_sol: Matrix)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Printable</code></p> <p>Represents a matrix as the sum of a particular solution and a general solution.</p> <p>This dataclass is used to express the general solution to a linear system as the sum of a particular solution (with all free variables set to zero) and a general solution (the homogeneous part).</p> <p>Attributes:</p> <ul> <li> <code>part_sol</code>               (<code>Matrix</code>)           \u2013            <p>The particular solution matrix.</p> </li> <li> <code>gen_sol</code>               (<code>Matrix</code>)           \u2013            <p>The general (homogeneous) solution matrix.</p> </li> </ul>"},{"location":"api/custom_types/#ma1522.custom_types.ScalarFactor","title":"<code>ScalarFactor(diag: Matrix, full: Matrix, order: Literal['FD', 'DF'])</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Printable</code></p> <p>Represents a matrix factored into a diagonal matrix and a full matrix.</p> <p>This dataclass is used to express a matrix as the product of a diagonal matrix (containing scalar factors) and a matrix with the common divisors factored out. The order of multiplication is specified by the 'order' attribute.</p> <p>Attributes:</p> <ul> <li> <code>diag</code>               (<code>Matrix</code>)           \u2013            <p>The diagonal matrix containing the scalar factors.</p> </li> <li> <code>full</code>               (<code>Matrix</code>)           \u2013            <p>The matrix with common divisors factored out.</p> </li> <li> <code>order</code>               (<code>Literal['FD', 'DF']</code>)           \u2013            <p>The order of multiplication, either 'FD' (full @ diag) or 'DF' (diag @ full).</p> </li> </ul>"},{"location":"api/custom_types/#ma1522.custom_types.PLU","title":"<code>PLU(P: Matrix, L: Matrix, U: Matrix)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Printable</code></p> <p>Represents a PLU decomposition of a matrix.</p> <p>This dataclass stores the permutation matrix (P), lower triangular matrix (L), and upper triangular matrix (U) such that the original matrix can be written as P @ L @ U.</p> <p>Attributes:</p> <ul> <li> <code>P</code>               (<code>Matrix</code>)           \u2013            <p>The permutation matrix.</p> </li> <li> <code>L</code>               (<code>Matrix</code>)           \u2013            <p>The lower triangular matrix.</p> </li> <li> <code>U</code>               (<code>Matrix</code>)           \u2013            <p>The upper triangular matrix.</p> </li> </ul>"},{"location":"api/custom_types/#ma1522.custom_types.RREF","title":"<code>RREF(rref: Matrix, pivots: tuple[int, ...])</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Printable</code></p> <p>Represents the reduced row echelon form (RREF) of a matrix.</p> <p>This dataclass stores the RREF of a matrix and the tuple of pivot column indices.</p> <p>Attributes:</p> <ul> <li> <code>rref</code>               (<code>Matrix</code>)           \u2013            <p>The matrix in reduced row echelon form.</p> </li> <li> <code>pivots</code>               (<code>tuple[int, ...]</code>)           \u2013            <p>The indices of the pivot columns.</p> </li> </ul>"},{"location":"api/custom_types/#ma1522.custom_types.VecDecomp","title":"<code>VecDecomp(proj: Matrix, norm: Matrix)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Printable</code></p> <p>Represents a vector decomposition into projection and normal components.</p> <p>This dataclass is used to express a vector as the sum of its projection onto a subspace and its orthogonal component.</p> <p>Attributes:</p> <ul> <li> <code>proj</code>               (<code>Matrix</code>)           \u2013            <p>The projection component.</p> </li> <li> <code>norm</code>               (<code>Matrix</code>)           \u2013            <p>The orthogonal (normal) component.</p> </li> </ul>"},{"location":"api/custom_types/#ma1522.custom_types.QR","title":"<code>QR(Q: Matrix, R: Matrix)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Printable</code></p> <p>Represents a QR decomposition of a matrix.</p> <p>This dataclass stores the orthogonal matrix (Q) and the upper triangular matrix (R) such that the original matrix = Q @ R.</p> <p>Attributes:</p> <ul> <li> <code>Q</code>               (<code>Matrix</code>)           \u2013            <p>The orthogonal matrix.</p> </li> <li> <code>R</code>               (<code>Matrix</code>)           \u2013            <p>The upper triangular matrix.</p> </li> </ul>"},{"location":"api/custom_types/#ma1522.custom_types.PDP","title":"<code>PDP(P: Matrix, D: Matrix)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Printable</code></p> <p>Represents a PDP diagonalization of a matrix.</p> <p>This dataclass stores the matrices P and D such that the original matrix = P @ D @ P^{-1}.</p> <p>Attributes:</p> <ul> <li> <code>P</code>               (<code>Matrix</code>)           \u2013            <p>The matrix of eigenvectors.</p> </li> <li> <code>D</code>               (<code>Matrix</code>)           \u2013            <p>The diagonal matrix of eigenvalues.</p> </li> </ul>"},{"location":"api/custom_types/#ma1522.custom_types.SVD","title":"<code>SVD(U: Matrix, S: Matrix, V: Matrix)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Printable</code></p> <p>Represents a symbolic Singular Value Decomposition (SVD) of a matrix.</p> <p>This dataclass stores the matrices U, S, and V such that the original matrix = U @ S @ V.T.</p> <p>Attributes:</p> <ul> <li> <code>U</code>               (<code>Matrix</code>)           \u2013            <p>The left singular vectors.</p> </li> <li> <code>S</code>               (<code>Matrix</code>)           \u2013            <p>The diagonal matrix of singular values.</p> </li> <li> <code>V</code>               (<code>Matrix</code>)           \u2013            <p>The right singular vectors.</p> </li> </ul>"},{"location":"api/custom_types/#ma1522.custom_types.NumSVD","title":"<code>NumSVD</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Represents a numerical Singular Value Decomposition (SVD) of a matrix.</p> <p>This named tuple stores the numerical matrices U, S, and V from a numerical SVD computation.</p> <p>Attributes:</p> <ul> <li> <code>U</code>               (<code>NDArray</code>)           \u2013            <p>The left singular vectors.</p> </li> <li> <code>S</code>               (<code>NDArray</code>)           \u2013            <p>The diagonal matrix of singular values.</p> </li> <li> <code>V</code>               (<code>NDArray</code>)           \u2013            <p>The right singular vectors.</p> </li> </ul>"},{"location":"api/inherited/","title":"Inherited Methods Summary","text":"<p>This page summarizes the methods and attributes that the custom <code>Matrix</code> class inherits from the <code>sympy.MutableDenseMatrix</code> class. These inherited methods and attributes are essential for performing various matrix operations and manipulations.</p> <p>               Bases: <code>MutableDenseMatrix</code></p> <p>A symbolic matrix class extending <code>MutableDenseMatrix</code> with enhanced linear algebra operations.</p> <p>The inherited methods from <code>MutableDenseMatrix</code> can be found in the SymPy Matrices Documentation. A summary of the inherited attributes and methods is also available on the Inherited Methods Summary page.</p> This class provides comprehensive linear algebra functionality with support for <ul> <li>Matrix creation from various sources (lists, \\(\\rm\\LaTeX\\), random values)</li> <li>Matrix decompositions (REF, RREF, LU, QR, SVD, diagonalization)</li> <li>Vector space operations (orthogonalization, projections, basis manipulation)</li> <li>Eigenvalue/eigenvector computations</li> <li>Custom printing and \\(\\rm\\LaTeX\\) formatting with augmented matrix support</li> </ul> Key Features <ul> <li>Maintains symbolic expressions throughout operations</li> <li>Follows MA1522 syllabus conventions for linear algebra</li> <li>Provides detailed step-by-step output for learning purposes</li> <li>Supports both exact symbolic and numerical computations</li> </ul> <p>Attributes:</p> <ul> <li> <code>_aug_pos</code>               (<code>set[int]</code>)           \u2013            <p>Set of column indices where augmentation lines should be drawn for displaying augmented matrices.</p> </li> </ul> <p>Examples:</p> <p>Basic matrix operations:</p> Python Console Session<pre><code>&gt;&gt;&gt; A = Matrix([[1, 2], [3, 4]])\n&gt;&gt;&gt; A.rref()\nRREF(rref=Matrix([\n[1, 0]\n[0, 1]\n]), pivots=(0, 1))\n</code></pre> <p>Creating from LaTeX:</p> Python Console Session<pre><code>&gt;&gt;&gt; B = Matrix.from_latex(r'\\begin{pmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\end{pmatrix}')\n\u23a11  2\u23a4\n\u23a2    \u23a5\n\u23a33  4\u23a6\n</code></pre> <p>Eigenvalue decomposition:</p> Python Console Session<pre><code>&gt;&gt;&gt; P, D = A.diagonalize(verbosity=0)\n&gt;&gt;&gt; P, D\n(Matrix([\n[-sqrt(33)/6 - 1/2, -1/2 + sqrt(33)/6]\n[                1,                 1]\n]), Matrix([\n[5/2 - sqrt(33)/2,                0]\n[               0, 5/2 + sqrt(33)/2]\n]))\n</code></pre> <p>Methods:</p> <ul> <li> <code>__getitem__</code>             \u2013              </li> <li> <code>col_del</code>             \u2013              <p>Delete the specified column.</p> </li> <li> <code>col_insert</code>             \u2013              <p>Insert one or more columns at the given column position.</p> </li> <li> <code>col</code>             \u2013              <p>Elementary column selector.</p> </li> <li> <code>extract</code>             \u2013              <p>Return a submatrix by specifying a list of rows and columns.</p> </li> <li> <code>get_diag_blocks</code>             \u2013              <p>Obtains the square sub-matrices on the main diagonal of a square matrix.</p> </li> <li> <code>hstack</code>             \u2013              <p>Return a matrix formed by joining args horizontally (i.e.</p> </li> <li> <code>reshape</code>             \u2013              <p>Reshape the matrix. Total number of elements must remain the same.</p> </li> <li> <code>row_del</code>             \u2013              <p>Delete the specified row.</p> </li> <li> <code>row_insert</code>             \u2013              <p>Insert one or more rows at the given row position.</p> </li> <li> <code>diagonal</code>             \u2013              <p>Returns the kth diagonal of self. The main diagonal</p> </li> <li> <code>row</code>             \u2013              <p>Elementary row selector.</p> </li> <li> <code>todok</code>             \u2013              <p>Return the matrix as dictionary of keys.</p> </li> <li> <code>from_dok</code>             \u2013              <p>Create a matrix from a dictionary of keys.</p> </li> <li> <code>tolist</code>             \u2013              <p>Return the Matrix as a nested Python list.</p> </li> <li> <code>todod</code>             \u2013              <p>Returns matrix as dict of dicts containing non-zero elements of the Matrix</p> </li> <li> <code>vec</code>             \u2013              <p>Return the Matrix converted into a one column matrix by stacking columns</p> </li> <li> <code>vech</code>             \u2013              <p>Reshapes the matrix into a column vector by stacking the</p> </li> <li> <code>vstack</code>             \u2013              <p>Return a matrix formed by joining args vertically (i.e.</p> </li> <li> <code>jordan_block</code>             \u2013              <p>Returns a Jordan block</p> </li> <li> <code>companion</code>             \u2013              <p>Returns a companion matrix of a polynomial.</p> </li> <li> <code>wilkinson</code>             \u2013              <p>Returns two square Wilkinson Matrix of size 2*n + 1</p> </li> <li> <code>atoms</code>             \u2013              <p>Returns the atoms that form the current object.</p> </li> <li> <code>has</code>             \u2013              <p>Test whether any subexpression matches any of the patterns.</p> </li> <li> <code>is_anti_symmetric</code>             \u2013              <p>Check if matrix M is an antisymmetric matrix,</p> </li> <li> <code>is_diagonal</code>             \u2013              <p>Check if matrix is diagonal,</p> </li> <li> <code>is_symbolic</code>             \u2013              <p>Checks if any elements contain Symbols.</p> </li> <li> <code>is_symmetric</code>             \u2013              <p>Check if matrix is symmetric matrix,</p> </li> <li> <code>values</code>             \u2013              <p>Return non-zero values of self.</p> </li> <li> <code>iter_values</code>             \u2013              <p>Iterate over non-zero values of self.</p> </li> <li> <code>iter_items</code>             \u2013              <p>Iterate over indices and values of nonzero items.</p> </li> <li> <code>applyfunc</code>             \u2013              <p>Apply a function to each element of the matrix.</p> </li> <li> <code>as_real_imag</code>             \u2013              <p>Returns a tuple containing the (real, imaginary) part of matrix.</p> </li> <li> <code>conjugate</code>             \u2013              <p>Return the by-element conjugation.</p> </li> <li> <code>doit</code>             \u2013              </li> <li> <code>evalf</code>             \u2013              <p>Apply evalf() to each element of self.</p> </li> <li> <code>expand</code>             \u2013              <p>Apply core.function.expand to each entry of the matrix.</p> </li> <li> <code>permute</code>             \u2013              <p>Permute the rows or columns of a matrix by the given list of</p> </li> <li> <code>permute_cols</code>             \u2013              <p>Alias for</p> </li> <li> <code>permute_rows</code>             \u2013              <p>Alias for</p> </li> <li> <code>refine</code>             \u2013              <p>Apply refine to each element of the matrix.</p> </li> <li> <code>replace</code>             \u2013              <p>Replaces Function F in Matrix entries with Function G.</p> </li> <li> <code>rot90</code>             \u2013              <p>Rotates Matrix by 90 degrees</p> </li> <li> <code>trace</code>             \u2013              <p>Returns the trace of a square matrix i.e. the sum of the</p> </li> <li> <code>transpose</code>             \u2013              <p>Returns the transpose of the matrix.</p> </li> <li> <code>n</code>             \u2013              <p>Apply evalf() to each element of self.</p> </li> <li> <code>xreplace</code>             \u2013              <p>Return a new matrix with xreplace applied to each entry.</p> </li> <li> <code>upper_triangular</code>             \u2013              <p>Return the elements on and above the kth diagonal of a matrix.</p> </li> <li> <code>lower_triangular</code>             \u2013              <p>Return the elements on and below the kth diagonal of a matrix.</p> </li> <li> <code>__truediv__</code>             \u2013              </li> <li> <code>__matmul__</code>             \u2013              </li> <li> <code>__mod__</code>             \u2013              </li> <li> <code>multiply</code>             \u2013              <p>Same as mul() but with optional simplification.</p> </li> <li> <code>multiply_elementwise</code>             \u2013              <p>Return the Hadamard product (elementwise product) of A and B</p> </li> <li> <code>__pow__</code>             \u2013              <p>Return self**exp a scalar or symbol.</p> </li> <li> <code>pow</code>             \u2013              <p>Return self**exp a scalar or symbol.</p> </li> <li> <code>__radd__</code>             \u2013              </li> <li> <code>__rmatmul__</code>             \u2013              </li> <li> <code>rmultiply</code>             \u2013              <p>Same as rmul() but with optional simplification.</p> </li> <li> <code>__rsub__</code>             \u2013              </li> <li> <code>__sub__</code>             \u2013              </li> <li> <code>adjugate</code>             \u2013              </li> <li> <code>charpoly</code>             \u2013              </li> <li> <code>cofactor</code>             \u2013              </li> <li> <code>cofactor_matrix</code>             \u2013              </li> <li> <code>det</code>             \u2013              </li> <li> <code>per</code>             \u2013              </li> <li> <code>minor</code>             \u2013              </li> <li> <code>minor_submatrix</code>             \u2013              </li> <li> <code>echelon_form</code>             \u2013              </li> <li> <code>rank</code>             \u2013              </li> <li> <code>rref_rhs</code>             \u2013              <p>Return reduced row-echelon form of matrix, matrix showing</p> </li> <li> <code>elementary_col_op</code>             \u2013              <p>Performs the elementary column operation <code>op</code>.</p> </li> <li> <code>elementary_row_op</code>             \u2013              <p>Performs the elementary row operation <code>op</code>.</p> </li> <li> <code>columnspace</code>             \u2013              </li> <li> <code>rowspace</code>             \u2013              </li> <li> <code>eigenvals</code>             \u2013              </li> <li> <code>eigenvects</code>             \u2013              </li> <li> <code>bidiagonalize</code>             \u2013              </li> <li> <code>bidiagonal_decomposition</code>             \u2013              </li> <li> <code>jordan_form</code>             \u2013              </li> <li> <code>left_eigenvects</code>             \u2013              </li> <li> <code>singular_values</code>             \u2013              </li> <li> <code>diff</code>             \u2013              <p>Calculate the derivative of each element in the matrix.</p> </li> <li> <code>integrate</code>             \u2013              <p>Integrate each element of the matrix.  <code>args</code> will</p> </li> <li> <code>jacobian</code>             \u2013              <p>Calculates the Jacobian matrix (derivative of a vector-valued function).</p> </li> <li> <code>limit</code>             \u2013              <p>Calculate the limit of each element in the matrix.</p> </li> <li> <code>berkowitz_charpoly</code>             \u2013              </li> <li> <code>berkowitz_det</code>             \u2013              <p>Computes determinant using Berkowitz method.</p> </li> <li> <code>berkowitz_eigenvals</code>             \u2013              <p>Computes eigenvalues of a Matrix using Berkowitz method.</p> </li> <li> <code>berkowitz_minors</code>             \u2013              <p>Computes principal minors using Berkowitz method.</p> </li> <li> <code>berkowitz</code>             \u2013              </li> <li> <code>cofactorMatrix</code>             \u2013              </li> <li> <code>det_bareis</code>             \u2013              </li> <li> <code>det_LU_decomposition</code>             \u2013              <p>Compute matrix determinant using LU decomposition.</p> </li> <li> <code>jordan_cell</code>             \u2013              </li> <li> <code>jordan_cells</code>             \u2013              </li> <li> <code>minorEntry</code>             \u2013              </li> <li> <code>minorMatrix</code>             \u2013              </li> <li> <code>permuteBkwd</code>             \u2013              <p>Permute the rows of the matrix with the given permutation in reverse.</p> </li> <li> <code>permuteFwd</code>             \u2013              <p>Permute the rows of the matrix with the given permutation.</p> </li> <li> <code>flat</code>             \u2013              </li> <li> <code>__array__</code>             \u2013              </li> <li> <code>__len__</code>             \u2013              <p>Return the number of elements of <code>self</code>.</p> </li> <li> <code>irregular</code>             \u2013              <p>Return a matrix filled by the given matrices which</p> </li> <li> <code>add</code>             \u2013              <p>Return self + b.</p> </li> <li> <code>condition_number</code>             \u2013              <p>Returns the condition number of a matrix.</p> </li> <li> <code>cross</code>             \u2013              <p>Return the cross product of <code>self</code> and <code>b</code> relaxing the condition</p> </li> <li> <code>hat</code>             \u2013              <p>Return the skew-symmetric matrix representing the cross product,</p> </li> <li> <code>vee</code>             \u2013              <p>Return a 3x1 vector from a skew-symmetric matrix representing the cross product,</p> </li> <li> <code>dot</code>             \u2013              <p>Return the dot or inner product of two vectors of equal length.</p> </li> <li> <code>dual</code>             \u2013              <p>Returns the dual of a matrix.</p> </li> <li> <code>analytic_func</code>             \u2013              <p>Computes f(A) where A is a Square Matrix</p> </li> <li> <code>exp</code>             \u2013              <p>Return the exponential of a square matrix.</p> </li> <li> <code>log</code>             \u2013              <p>Return the logarithm of a square matrix.</p> </li> <li> <code>is_nilpotent</code>             \u2013              <p>Checks if a matrix is nilpotent.</p> </li> <li> <code>key2bounds</code>             \u2013              <p>Converts a key with potentially mixed types of keys (integer and slice)</p> </li> <li> <code>key2ij</code>             \u2013              <p>Converts key into canonical form, converting integers or indexable</p> </li> <li> <code>norm</code>             \u2013              <p>Return the Norm of a Matrix or Vector.</p> </li> <li> <code>print_nonzero</code>             \u2013              <p>Shows location of non-zero entries for fast shape lookup.</p> </li> <li> <code>project</code>             \u2013              <p>Return the projection of <code>self</code> onto the line containing <code>v</code>.</p> </li> <li> <code>table</code>             \u2013              <p>String form of Matrix as a table.</p> </li> <li> <code>rank_decomposition</code>             \u2013              </li> <li> <code>cholesky</code>             \u2013              </li> <li> <code>LDLdecomposition</code>             \u2013              </li> <li> <code>LUdecomposition</code>             \u2013              </li> <li> <code>LUdecomposition_Simple</code>             \u2013              </li> <li> <code>LUdecompositionFF</code>             \u2013              </li> <li> <code>upper_hessenberg_decomposition</code>             \u2013              </li> <li> <code>diagonal_solve</code>             \u2013              </li> <li> <code>lower_triangular_solve</code>             \u2013              </li> <li> <code>upper_triangular_solve</code>             \u2013              </li> <li> <code>cholesky_solve</code>             \u2013              </li> <li> <code>LDLsolve</code>             \u2013              </li> <li> <code>LUsolve</code>             \u2013              </li> <li> <code>QRsolve</code>             \u2013              </li> <li> <code>gauss_jordan_solve</code>             \u2013              </li> <li> <code>pinv_solve</code>             \u2013              </li> <li> <code>pinv</code>             \u2013              </li> <li> <code>inverse_ADJ</code>             \u2013              </li> <li> <code>inverse_BLOCK</code>             \u2013              </li> <li> <code>inverse_GE</code>             \u2013              </li> <li> <code>inverse_LU</code>             \u2013              </li> <li> <code>inverse_CH</code>             \u2013              </li> <li> <code>inverse_LDL</code>             \u2013              </li> <li> <code>inverse_QR</code>             \u2013              </li> <li> <code>inv</code>             \u2013              </li> <li> <code>connected_components</code>             \u2013              </li> <li> <code>connected_components_decomposition</code>             \u2013              </li> <li> <code>strongly_connected_components</code>             \u2013              </li> <li> <code>strongly_connected_components_decomposition</code>             \u2013              </li> <li> <code>to_DM</code>             \u2013              <p>Convert to a :class:<code>~.DomainMatrix</code>.</p> </li> <li> <code>equals</code>             \u2013              <p>Applies <code>equals</code> to corresponding elements of the matrices,</p> </li> <li> <code>inv_mod</code>             \u2013              <p>Returns the inverse of the integer matrix <code>M</code> modulo <code>m</code>.</p> </li> <li> <code>lll</code>             \u2013              <p>LLL-reduced basis for the rowspace of a matrix of integers.</p> </li> <li> <code>lll_transform</code>             \u2013              <p>LLL-reduced basis and transformation matrix.</p> </li> <li> <code>__new__</code>             \u2013              </li> <li> <code>as_mutable</code>             \u2013              <p>Returns a mutable version of this matrix</p> </li> <li> <code>__setitem__</code>             \u2013              <p>Examples</p> </li> <li> <code>col_op</code>             \u2013              <p>In-place operation on col j using two-arg functor whose args are</p> </li> <li> <code>col_swap</code>             \u2013              <p>Swap the two given columns of the matrix in-place.</p> </li> <li> <code>row_op</code>             \u2013              <p>In-place operation on row <code>i</code> using two-arg functor whose args are</p> </li> <li> <code>row_mult</code>             \u2013              <p>Multiply the given row by the given factor in-place.</p> </li> <li> <code>row_add</code>             \u2013              <p>Add k times row s (source) to row t (target) in place.</p> </li> <li> <code>row_swap</code>             \u2013              <p>Swap the two given rows of the matrix in-place.</p> </li> <li> <code>zip_row_op</code>             \u2013              <p>In-place operation on row <code>i</code> using two-arg functor whose args are</p> </li> <li> <code>copyin_list</code>             \u2013              <p>Copy in elements from a list.</p> </li> <li> <code>copyin_matrix</code>             \u2013              <p>Copy in values from a matrix into the given bounds.</p> </li> <li> <code>fill</code>             \u2013              <p>Fill self with the given value.</p> </li> <li> <code>as_immutable</code>             \u2013              <p>Returns an Immutable version of this Matrix</p> </li> </ul>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.__slots__","title":"<code>__slots__ = ()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._repr_png_","title":"<code>_repr_png_ = _repr_disabled</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._repr_svg_","title":"<code>_repr_svg_ = _repr_disabled</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._op_priority","title":"<code>_op_priority = 10.01</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.__array_priority__","title":"<code>__array_priority__ = 11</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_Matrix","title":"<code>is_Matrix = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._class_priority","title":"<code>_class_priority = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._sympify","title":"<code>_sympify = staticmethod(sympify)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.zero","title":"<code>zero = S.Zero</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.one","title":"<code>one = S.One</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._diff_wrt","title":"<code>_diff_wrt = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.rows","title":"<code>rows = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.cols","title":"<code>cols = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._simplify","title":"<code>_simplify = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.shape","title":"<code>shape</code>  <code>property</code>","text":"<p>The shape (dimensions) of the matrix as the 2-tuple (rows, cols).</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.shape--examples","title":"Examples","text":"<p>from sympy import zeros M = zeros(2, 3) M.shape (2, 3) M.rows 2 M.cols 3</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.free_symbols","title":"<code>free_symbols</code>  <code>property</code>","text":"<p>Returns the free symbols within the matrix.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.free_symbols--examples","title":"Examples","text":"<p>from sympy.abc import x from sympy import Matrix Matrix([[x], [1]]).free_symbols</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_weakly_diagonally_dominant","title":"<code>is_weakly_diagonally_dominant</code>  <code>property</code>","text":"<p>Tests if the matrix is row weakly diagonally dominant.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_weakly_diagonally_dominant--explanation","title":"Explanation","text":"<p>A \\(n, n\\) matrix \\(A\\) is row weakly diagonally dominant if</p> <p>.. math::     \\left|A_{i, i}\\right| \\ge \\sum_{j = 0, j \\neq i}^{n-1}     \\left|A_{i, j}\\right| \\quad {\\text{for all }}     i \\in { 0, ..., n-1 }</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_weakly_diagonally_dominant--examples","title":"Examples","text":"<p>from sympy import Matrix A = Matrix([[3, -2, 1], [1, -3, 2], [-1, 2, 4]]) A.is_weakly_diagonally_dominant True</p> <p>A = Matrix([[-2, 2, 1], [1, 3, 2], [1, -2, 0]]) A.is_weakly_diagonally_dominant False</p> <p>A = Matrix([[-4, 2, 1], [1, 6, 2], [1, -2, 5]]) A.is_weakly_diagonally_dominant True</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_weakly_diagonally_dominant--notes","title":"Notes","text":"<p>If you want to test whether a matrix is column diagonally dominant, you can apply the test after transposing the matrix.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_strongly_diagonally_dominant","title":"<code>is_strongly_diagonally_dominant</code>  <code>property</code>","text":"<p>Tests if the matrix is row strongly diagonally dominant.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_strongly_diagonally_dominant--explanation","title":"Explanation","text":"<p>A \\(n, n\\) matrix \\(A\\) is row strongly diagonally dominant if</p> <p>.. math::     \\left|A_{i, i}\\right| &gt; \\sum_{j = 0, j \\neq i}^{n-1}     \\left|A_{i, j}\\right| \\quad {\\text{for all }}     i \\in { 0, ..., n-1 }</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_strongly_diagonally_dominant--examples","title":"Examples","text":"<p>from sympy import Matrix A = Matrix([[3, -2, 1], [1, -3, 2], [-1, 2, 4]]) A.is_strongly_diagonally_dominant False</p> <p>A = Matrix([[-2, 2, 1], [1, 3, 2], [1, -2, 0]]) A.is_strongly_diagonally_dominant False</p> <p>A = Matrix([[-4, 2, 1], [1, 6, 2], [1, -2, 5]]) A.is_strongly_diagonally_dominant True</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_strongly_diagonally_dominant--notes","title":"Notes","text":"<p>If you want to test whether a matrix is column diagonally dominant, you can apply the test after transposing the matrix.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_hermitian","title":"<code>is_hermitian</code>  <code>property</code>","text":"<p>Checks if the matrix is Hermitian.</p> <p>In a Hermitian matrix element i,j is the complex conjugate of element j,i.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_hermitian--examples","title":"Examples","text":"<p>from sympy import Matrix from sympy import I from sympy.abc import x a = Matrix([[1, I], [-I, 1]]) a Matrix([ [ 1, I], [-I, 1]]) a.is_hermitian True a[0, 0] = 2I a.is_hermitian False a[0, 0] = x a.is_hermitian a[0, 1] = a[1, 0]I a.is_hermitian False</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_Identity","title":"<code>is_Identity: FuzzyBool</code>  <code>property</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_lower_hessenberg","title":"<code>is_lower_hessenberg</code>  <code>property</code>","text":"<p>Checks if the matrix is in the lower-Hessenberg form.</p> <p>The lower hessenberg matrix has zero entries above the first superdiagonal.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_lower_hessenberg--examples","title":"Examples","text":"<p>from sympy import Matrix a = Matrix([[1, 2, 0, 0], [5, 2, 3, 0], [3, 4, 3, 7], [5, 6, 1, 1]]) a Matrix([ [1, 2, 0, 0], [5, 2, 3, 0], [3, 4, 3, 7], [5, 6, 1, 1]]) a.is_lower_hessenberg True</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_lower_hessenberg--see-also","title":"See Also","text":"<p>is_upper_hessenberg is_lower</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_lower","title":"<code>is_lower</code>  <code>property</code>","text":"<p>Check if matrix is a lower triangular matrix. True can be returned even if the matrix is not square.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_lower--examples","title":"Examples","text":"<p>from sympy import Matrix m = Matrix(2, 2, [1, 0, 0, 1]) m Matrix([ [1, 0], [0, 1]]) m.is_lower True</p> <p>m = Matrix(4, 3, [0, 0, 0, 2, 0, 0, 1, 4, 0, 6, 6, 5]) m Matrix([ [0, 0, 0], [2, 0, 0], [1, 4, 0], [6, 6, 5]]) m.is_lower True</p> <p>from sympy.abc import x, y m = Matrix(2, 2, [x2 + y, y2 + x, 0, x + y]) m Matrix([ [x2 + y, x + y2], [       0,    x + y]]) m.is_lower False</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_lower--see-also","title":"See Also","text":"<p>is_upper is_diagonal is_lower_hessenberg</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_square","title":"<code>is_square</code>  <code>property</code>","text":"<p>Checks if a matrix is square.</p> <p>A matrix is square if the number of rows equals the number of columns. The empty matrix is square by definition, since the number of rows and the number of columns are both zero.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_square--examples","title":"Examples","text":"<p>from sympy import Matrix a = Matrix([[1, 2, 3], [4, 5, 6]]) b = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) c = Matrix([]) a.is_square False b.is_square True c.is_square True</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_upper_hessenberg","title":"<code>is_upper_hessenberg</code>  <code>property</code>","text":"<p>Checks if the matrix is the upper-Hessenberg form.</p> <p>The upper hessenberg matrix has zero entries below the first subdiagonal.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_upper_hessenberg--examples","title":"Examples","text":"<p>from sympy import Matrix a = Matrix([[1, 4, 2, 3], [3, 4, 1, 7], [0, 2, 3, 4], [0, 0, 1, 3]]) a Matrix([ [1, 4, 2, 3], [3, 4, 1, 7], [0, 2, 3, 4], [0, 0, 1, 3]]) a.is_upper_hessenberg True</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_upper_hessenberg--see-also","title":"See Also","text":"<p>is_lower_hessenberg is_upper</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_upper","title":"<code>is_upper</code>  <code>property</code>","text":"<p>Check if matrix is an upper triangular matrix. True can be returned even if the matrix is not square.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_upper--examples","title":"Examples","text":"<p>from sympy import Matrix m = Matrix(2, 2, [1, 0, 0, 1]) m Matrix([ [1, 0], [0, 1]]) m.is_upper True</p> <p>m = Matrix(4, 3, [5, 1, 9, 0, 4, 6, 0, 0, 5, 0, 0, 0]) m Matrix([ [5, 1, 9], [0, 4, 6], [0, 0, 5], [0, 0, 0]]) m.is_upper True</p> <p>m = Matrix(2, 3, [4, 2, 5, 6, 1, 1]) m Matrix([ [4, 2, 5], [6, 1, 1]]) m.is_upper False</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_upper--see-also","title":"See Also","text":"<p>is_lower is_diagonal is_upper_hessenberg</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_zero_matrix","title":"<code>is_zero_matrix</code>  <code>property</code>","text":"<p>Checks if a matrix is a zero matrix.</p> <p>A matrix is zero if every element is zero.  A matrix need not be square to be considered zero.  The empty matrix is zero by the principle of vacuous truth.  For a matrix that may or may not be zero (e.g. contains a symbol), this will be None</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_zero_matrix--examples","title":"Examples","text":"<p>from sympy import Matrix, zeros from sympy.abc import x a = Matrix([[0, 0], [0, 0]]) b = zeros(3, 4) c = Matrix([[0, 1], [0, 0]]) d = Matrix([]) e = Matrix([[x, 0], [0, 0]]) a.is_zero_matrix True b.is_zero_matrix True c.is_zero_matrix False d.is_zero_matrix True e.is_zero_matrix</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.H","title":"<code>H</code>  <code>property</code>","text":"<p>Return Hermite conjugate.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.H--examples","title":"Examples","text":"<p>from sympy import Matrix, I m = Matrix((0, 1 + I, 2, 3)) m Matrix([ [    0], [1 + I], [    2], [    3]]) m.H Matrix([[0, 1 - I, 2, 3]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.H--see-also","title":"See Also","text":"<p>conjugate: By-element conjugation sympy.matrices.matrixbase.MatrixBase.D: Dirac conjugation</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.C","title":"<code>C</code>  <code>property</code>","text":"<p>By-element conjugation</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_echelon","title":"<code>is_echelon</code>  <code>property</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.orthogonalize","title":"<code>orthogonalize = classmethod(orthogonalize)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_positive_definite","title":"<code>is_positive_definite</code>  <code>property</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_positive_semidefinite","title":"<code>is_positive_semidefinite</code>  <code>property</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_negative_definite","title":"<code>is_negative_definite</code>  <code>property</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_negative_semidefinite","title":"<code>is_negative_semidefinite</code>  <code>property</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_indefinite","title":"<code>is_indefinite</code>  <code>property</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.kind","title":"<code>kind: MatrixKind</code>  <code>property</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.D","title":"<code>D</code>  <code>property</code>","text":"<p>Return Dirac conjugate (if <code>self.rows == 4</code>).</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.D--examples","title":"Examples","text":"<p>from sympy import Matrix, I, eye m = Matrix((0, 1 + I, 2, 3)) m.D Matrix([[0, 1 - I, -2, -3]]) m = (eye(4) + I*eye(4)) m[0, 3] = 2 m.D Matrix([ [1 - I,     0,      0,      0], [    0, 1 - I,      0,      0], [    0,     0, -1 + I,      0], [    2,     0,      0, -1 + I]])</p> <p>If the matrix does not have 4 rows an AttributeError will be raised because this property is only defined for matrices with 4 rows.</p> <p>Matrix(eye(2)).D Traceback (most recent call last): ... AttributeError: Matrix has no attribute D.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.D--see-also","title":"See Also","text":"<p>sympy.matrices.matrixbase.MatrixBase.conjugate: By-element conjugation sympy.matrices.matrixbase.MatrixBase.H: Hermite conjugation</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix._sage_","title":"<code>_sage_ = Basic._sage_</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._rep","title":"<code>_rep: DomainMatrix</code>  <code>instance-attribute</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_zero","title":"<code>is_zero = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_MatrixExpr","title":"<code>is_MatrixExpr = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._mat","title":"<code>_mat</code>  <code>property</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._repr_disabled","title":"<code>_repr_disabled()</code>","text":"<p>No-op repr function used to disable jupyter display hooks.</p> <p>When :func:<code>sympy.init_printing</code> is used to disable certain display formats, this function is copied into the appropriate <code>_repr_*_</code> attributes.</p> <p>While we could just set the attributes to <code>None``, doing it this way allows derived classes to call</code>super()`.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix._repr_latex_","title":"<code>_repr_latex_()</code>","text":"<p>IPython/Jupyter LaTeX printing</p> <p>To change the behavior of this (e.g., pass in some settings to LaTeX), use init_printing(). init_printing() will also enable LaTeX printing for built in numeric types like ints and container types that contain SymPy objects, like lists and dictionaries of expressions.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix._new","title":"<code>_new(*args, copy=True, **kwargs)</code>  <code>classmethod</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.__getitem__","title":"<code>__getitem__(key)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_col_del","title":"<code>_eval_col_del(col)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_col_insert","title":"<code>_eval_col_insert(col, other)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_col_join","title":"<code>_eval_col_join(other)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_extract","title":"<code>_eval_extract(rowsList, colsList)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_get_diag_blocks","title":"<code>_eval_get_diag_blocks()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_row_del","title":"<code>_eval_row_del(row)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_row_insert","title":"<code>_eval_row_insert(row, other)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_row_join","title":"<code>_eval_row_join(other)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_tolist","title":"<code>_eval_tolist()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_todok","title":"<code>_eval_todok()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_from_dok","title":"<code>_eval_from_dok(rows, cols, dok)</code>  <code>classmethod</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_vec","title":"<code>_eval_vec()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_vech","title":"<code>_eval_vech(diagonal)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.col_del","title":"<code>col_del(col)</code>","text":"<p>Delete the specified column.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.col_insert","title":"<code>col_insert(pos, other)</code>","text":"<p>Insert one or more columns at the given column position.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.col_insert--examples","title":"Examples","text":"<p>from sympy import zeros, ones M = zeros(3) V = ones(3, 1) M.col_insert(1, V) Matrix([ [0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.col_insert--see-also","title":"See Also","text":"<p>col row_insert</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.col","title":"<code>col(j)</code>","text":"<p>Elementary column selector.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.col--examples","title":"Examples","text":"<p>from sympy import eye eye(2).col(0) Matrix([ [1], [0]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.col--see-also","title":"See Also","text":"<p>row col_del col_join col_insert</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.extract","title":"<code>extract(rowsList, colsList)</code>","text":"<p>Return a submatrix by specifying a list of rows and columns. Negative indices can be given. All indices must be in the range \\(-n \\le i &lt; n\\) where \\(n\\) is the number of rows or columns.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.extract--examples","title":"Examples","text":"<p>from sympy import Matrix m = Matrix(4, 3, range(12)) m Matrix([ [0,  1,  2], [3,  4,  5], [6,  7,  8], [9, 10, 11]]) m.extract([0, 1, 3], [0, 1]) Matrix([ [0,  1], [3,  4], [9, 10]])</p> <p>Rows or columns can be repeated:</p> <p>m.extract([0, 0, 1], [-1]) Matrix([ [2], [2], [5]])</p> <p>Every other row can be taken by using range to provide the indices:</p> <p>m.extract(range(0, m.rows, 2), [-1]) Matrix([ [2], [8]])</p> <p>RowsList or colsList can also be a list of booleans, in which case the rows or columns corresponding to the True values will be selected:</p> <p>m.extract([0, 1, 2, 3], [True, False, True]) Matrix([ [0,  2], [3,  5], [6,  8], [9, 11]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.get_diag_blocks","title":"<code>get_diag_blocks()</code>","text":"<p>Obtains the square sub-matrices on the main diagonal of a square matrix.</p> <p>Useful for inverting symbolic matrices or solving systems of linear equations which may be decoupled by having a block diagonal structure.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.get_diag_blocks--examples","title":"Examples","text":"<p>from sympy import Matrix from sympy.abc import x, y, z A = Matrix([[1, 3, 0, 0], [y, zz, 0, 0], [0, 0, x, 0], [0, 0, 0, 0]]) a1, a2, a3 = A.get_diag_blocks() a1 Matrix([ [1,    3], [y, z*2]]) a2 Matrix([[x]]) a3 Matrix([[0]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.hstack","title":"<code>hstack(*args)</code>  <code>classmethod</code>","text":"<p>Return a matrix formed by joining args horizontally (i.e. by repeated application of row_join).</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.hstack--examples","title":"Examples","text":"<p>from sympy import Matrix, eye Matrix.hstack(eye(2), 2*eye(2)) Matrix([ [1, 0, 2, 0], [0, 1, 0, 2]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.reshape","title":"<code>reshape(rows, cols)</code>","text":"<p>Reshape the matrix. Total number of elements must remain the same.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.reshape--examples","title":"Examples","text":"<p>from sympy import Matrix m = Matrix(2, 3, lambda i, j: 1) m Matrix([ [1, 1, 1], [1, 1, 1]]) m.reshape(1, 6) Matrix([[1, 1, 1, 1, 1, 1]]) m.reshape(3, 2) Matrix([ [1, 1], [1, 1], [1, 1]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.row_del","title":"<code>row_del(row)</code>","text":"<p>Delete the specified row.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.row_insert","title":"<code>row_insert(pos, other)</code>","text":"<p>Insert one or more rows at the given row position.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.row_insert--examples","title":"Examples","text":"<p>from sympy import zeros, ones M = zeros(3) V = ones(1, 3) M.row_insert(1, V) Matrix([ [0, 0, 0], [1, 1, 1], [0, 0, 0], [0, 0, 0]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.row_insert--see-also","title":"See Also","text":"<p>row col_insert</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.diagonal","title":"<code>diagonal(k=0)</code>","text":"<p>Returns the kth diagonal of self. The main diagonal corresponds to <code>k=0</code>; diagonals above and below correspond to <code>k &gt; 0</code> and <code>k &lt; 0</code>, respectively. The values of <code>self[i, j]</code> for which <code>j - i = k</code>, are returned in order of increasing <code>i + j</code>, starting with <code>i + j = |k|</code>.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.diagonal--examples","title":"Examples","text":"<p>from sympy import Matrix m = Matrix(3, 3, lambda i, j: j - i); m Matrix([ [ 0,  1, 2], [-1,  0, 1], [-2, -1, 0]]) _.diagonal() Matrix([[0, 0, 0]]) m.diagonal(1) Matrix([[1, 1]]) m.diagonal(-2) Matrix([[-2]])</p> <p>Even though the diagonal is returned as a Matrix, the element retrieval can be done with a single index:</p> <p>Matrix.diag(1, 2, 3).diagonal()[1]  # instead of [0, 1] 2</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.diagonal--see-also","title":"See Also","text":"<p>diag</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.row","title":"<code>row(i)</code>","text":"<p>Elementary row selector.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.row--examples","title":"Examples","text":"<p>from sympy import eye eye(2).row(0) Matrix([[1, 0]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.row--see-also","title":"See Also","text":"<p>col row_del row_join row_insert</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.todok","title":"<code>todok()</code>","text":"<p>Return the matrix as dictionary of keys.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.todok--examples","title":"Examples","text":"<p>from sympy import Matrix M = Matrix.eye(3) M.todok()</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.from_dok","title":"<code>from_dok(rows, cols, dok)</code>  <code>classmethod</code>","text":"<p>Create a matrix from a dictionary of keys.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.from_dok--examples","title":"Examples","text":"<p>from sympy import Matrix d = {(0, 0): 1, (1, 2): 3, (2, 1): 4} Matrix.from_dok(3, 3, d) Matrix([ [1, 0, 0], [0, 0, 3], [0, 4, 0]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.tolist","title":"<code>tolist()</code>","text":"<p>Return the Matrix as a nested Python list.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.tolist--examples","title":"Examples","text":"<p>from sympy import Matrix, ones m = Matrix(3, 3, range(9)) m Matrix([ [0, 1, 2], [3, 4, 5], [6, 7, 8]]) m.tolist() [[0, 1, 2], [3, 4, 5], [6, 7, 8]] ones(3, 0).tolist() [[], [], []]</p> <p>When there are no rows then it will not be possible to tell how many columns were in the original matrix:</p> <p>ones(0, 3).tolist() []</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.todod","title":"<code>todod(M)</code>","text":"<p>Returns matrix as dict of dicts containing non-zero elements of the Matrix</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.todod--examples","title":"Examples","text":"<p>from sympy import Matrix A = Matrix([[0, 1],[0, 3]]) A Matrix([ [0, 1], [0, 3]]) A.todod() {0: {1: 1}, 1: {1: 3}}</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.vec","title":"<code>vec()</code>","text":"<p>Return the Matrix converted into a one column matrix by stacking columns</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.vec--examples","title":"Examples","text":"<p>from sympy import Matrix m=Matrix([[1, 3], [2, 4]]) m Matrix([ [1, 3], [2, 4]]) m.vec() Matrix([ [1], [2], [3], [4]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.vec--see-also","title":"See Also","text":"<p>vech</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.vech","title":"<code>vech(diagonal=True, check_symmetry=True)</code>","text":"<p>Reshapes the matrix into a column vector by stacking the elements in the lower triangle.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.vech--parameters","title":"Parameters","text":"bool, optional <p>If <code>True</code>, it includes the diagonal elements.</p> bool, optional <p>If <code>True</code>, it checks whether the matrix is symmetric.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.vech--examples","title":"Examples","text":"<p>from sympy import Matrix m=Matrix([[1, 2], [2, 3]]) m Matrix([ [1, 2], [2, 3]]) m.vech() Matrix([ [1], [2], [3]]) m.vech(diagonal=False) Matrix([[2]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.vech--notes","title":"Notes","text":"<p>This should work for symmetric matrices and <code>vech</code> can represent symmetric matrices in vector form with less size than <code>vec</code>.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.vech--see-also","title":"See Also","text":"<p>vec</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.vstack","title":"<code>vstack(*args)</code>  <code>classmethod</code>","text":"<p>Return a matrix formed by joining args vertically (i.e. by repeated application of col_join).</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.vstack--examples","title":"Examples","text":"<p>from sympy import Matrix, eye Matrix.vstack(eye(2), 2*eye(2)) Matrix([ [1, 0], [0, 1], [2, 0], [0, 2]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_diag","title":"<code>_eval_diag(rows, cols, diag_dict)</code>  <code>classmethod</code>","text":"<p>diag_dict is a defaultdict containing all the entries of the diagonal matrix.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_eye","title":"<code>_eval_eye(rows, cols)</code>  <code>classmethod</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_jordan_block","title":"<code>_eval_jordan_block(size: int, eigenvalue, band='upper')</code>  <code>classmethod</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_ones","title":"<code>_eval_ones(rows, cols)</code>  <code>classmethod</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_zeros","title":"<code>_eval_zeros(rows, cols)</code>  <code>classmethod</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_wilkinson","title":"<code>_eval_wilkinson(n)</code>  <code>classmethod</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.jordan_block","title":"<code>jordan_block(kls, size=None, eigenvalue=None, *, band='upper', **kwargs)</code>  <code>classmethod</code>","text":"<p>Returns a Jordan block</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.jordan_block--parameters","title":"Parameters","text":"Integer, optional <p>Specifies the shape of the Jordan block matrix.</p> Number or Symbol <p>Specifies the value for the main diagonal of the matrix.</p> <p>.. note::     The keyword <code>eigenval</code> is also specified as an alias     of this keyword, but it is not recommended to use.</p> Text Only<pre><code>We may deprecate the alias in later release.\n</code></pre> 'upper' or 'lower', optional <p>Specifies the position of the off-diagonal to put <code>1</code> s on.</p> Matrix, optional <p>Specifies the matrix class of the output form.</p> <p>If it is not specified, the class type where the method is being executed on will be returned.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.jordan_block--returns","title":"Returns","text":"<p>Matrix     A Jordan block matrix.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.jordan_block--raises","title":"Raises","text":"<p>ValueError     If insufficient arguments are given for matrix size     specification, or no eigenvalue is given.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.jordan_block--examples","title":"Examples","text":"<p>Creating a default Jordan block:</p> <p>from sympy import Matrix from sympy.abc import x Matrix.jordan_block(4, x) Matrix([ [x, 1, 0, 0], [0, x, 1, 0], [0, 0, x, 1], [0, 0, 0, x]])</p> <p>Creating an alternative Jordan block matrix where <code>1</code> is on lower off-diagonal:</p> <p>Matrix.jordan_block(4, x, band='lower') Matrix([ [x, 0, 0, 0], [1, x, 0, 0], [0, 1, x, 0], [0, 0, 1, x]])</p> <p>Creating a Jordan block with keyword arguments</p> <p>Matrix.jordan_block(size=4, eigenvalue=x) Matrix([ [x, 1, 0, 0], [0, x, 1, 0], [0, 0, x, 1], [0, 0, 0, x]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.jordan_block--references","title":"References","text":"<p>.. [1] https://en.wikipedia.org/wiki/Jordan_matrix</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.companion","title":"<code>companion(kls, poly)</code>  <code>classmethod</code>","text":"<p>Returns a companion matrix of a polynomial.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.companion--examples","title":"Examples","text":"<p>from sympy import Matrix, Poly, Symbol, symbols x = Symbol('x') c0, c1, c2, c3, c4 = symbols('c0:5') p = Poly(c0 + c1x + c2x2 + c3*x3 + c4x4 + x*5, x) Matrix.companion(p) Matrix([ [0, 0, 0, 0, -c0], [1, 0, 0, 0, -c1], [0, 1, 0, 0, -c2], [0, 0, 1, 0, -c3], [0, 0, 0, 1, -c4]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.wilkinson","title":"<code>wilkinson(kls, n, **kwargs)</code>  <code>classmethod</code>","text":"<p>Returns two square Wilkinson Matrix of size 2*n + 1 \\(W_{2n + 1}^-, W_{2n + 1}^+ =\\) Wilkinson(n)</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.wilkinson--examples","title":"Examples","text":"<p>from sympy import Matrix wminus, wplus = Matrix.wilkinson(3) wminus Matrix([ [-3,  1,  0, 0, 0, 0, 0], [ 1, -2,  1, 0, 0, 0, 0], [ 0,  1, -1, 1, 0, 0, 0], [ 0,  0,  1, 0, 1, 0, 0], [ 0,  0,  0, 1, 1, 1, 0], [ 0,  0,  0, 0, 1, 2, 1], [ 0,  0,  0, 0, 0, 1, 3]]) wplus Matrix([ [3, 1, 0, 0, 0, 0, 0], [1, 2, 1, 0, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0], [0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 0, 1, 2, 1], [0, 0, 0, 0, 0, 1, 3]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.wilkinson--references","title":"References","text":"<p>.. [1] https://blogs.mathworks.com/cleve/2013/04/15/wilkinsons-matrices-2/ .. [2] J. H. Wilkinson, The Algebraic Eigenvalue Problem, Claredon Press, Oxford, 1965, 662 pp.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_iter_values","title":"<code>_eval_iter_values()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_values","title":"<code>_eval_values()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_iter_items","title":"<code>_eval_iter_items()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_atoms","title":"<code>_eval_atoms(*types)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_free_symbols","title":"<code>_eval_free_symbols()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_has","title":"<code>_eval_has(*patterns)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_is_symbolic","title":"<code>_eval_is_symbolic()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_is_matrix_hermitian","title":"<code>_eval_is_matrix_hermitian(simpfunc)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_is_zero_matrix","title":"<code>_eval_is_zero_matrix()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_is_Identity","title":"<code>_eval_is_Identity()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_is_diagonal","title":"<code>_eval_is_diagonal()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_is_lower","title":"<code>_eval_is_lower()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_is_upper","title":"<code>_eval_is_upper()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_is_lower_hessenberg","title":"<code>_eval_is_lower_hessenberg()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_is_upper_hessenberg","title":"<code>_eval_is_upper_hessenberg()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_is_symmetric","title":"<code>_eval_is_symmetric(simpfunc)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_is_anti_symmetric","title":"<code>_eval_is_anti_symmetric(simpfunc)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._has_positive_diagonals","title":"<code>_has_positive_diagonals()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._has_nonnegative_diagonals","title":"<code>_has_nonnegative_diagonals()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.atoms","title":"<code>atoms(*types)</code>","text":"<p>Returns the atoms that form the current object.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.atoms--examples","title":"Examples","text":"<p>from sympy.abc import x, y from sympy import Matrix Matrix([[x]]) Matrix([[x]]) .atoms() {x} Matrix([[x, y], [y, x]]) Matrix([ [x, y], [y, x]]) .atoms()</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.has","title":"<code>has(*patterns)</code>","text":"<p>Test whether any subexpression matches any of the patterns.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.has--examples","title":"Examples","text":"<p>from sympy import Matrix, SparseMatrix, Float from sympy.abc import x, y A = Matrix(((1, x), (0.2, 3))) B = SparseMatrix(((1, x), (0.2, 3))) A.has(x) True A.has(y) False A.has(Float) True B.has(x) True B.has(y) False B.has(Float) True</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_anti_symmetric","title":"<code>is_anti_symmetric(simplify=True)</code>","text":"<p>Check if matrix M is an antisymmetric matrix, that is, M is a square matrix with all M[i, j] == -M[j, i].</p> <p>When <code>simplify=True</code> (default), the sum M[i, j] + M[j, i] is simplified before testing to see if it is zero. By default, the SymPy simplify function is used. To use a custom function set simplify to a function that accepts a single argument which returns a simplified expression. To skip simplification, set simplify to False but note that although this will be faster, it may induce false negatives.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_anti_symmetric--examples","title":"Examples","text":"<p>from sympy import Matrix, symbols m = Matrix(2, 2, [0, 1, -1, 0]) m Matrix([ [ 0, 1], [-1, 0]]) m.is_anti_symmetric() True x, y = symbols('x y') m = Matrix(2, 3, [0, 0, x, -y, 0, 0]) m Matrix([ [ 0, 0, x], [-y, 0, 0]]) m.is_anti_symmetric() False</p> <p>from sympy.abc import x, y m = Matrix(3, 3, [0, x2 + 2*x + 1, y, ...                   -(x + 1)2, 0, xy, ...                   -y, -xy, 0])</p> <p>Simplification of matrix elements is done by default so even though two elements which should be equal and opposite would not pass an equality test, the matrix is still reported as anti-symmetric:</p> <p>m[0, 1] == -m[1, 0] False m.is_anti_symmetric() True</p> <p>If <code>simplify=False</code> is used for the case when a Matrix is already simplified, this will speed things up. Here, we see that without simplification the matrix does not appear anti-symmetric:</p> <p>print(m.is_anti_symmetric(simplify=False)) None</p> <p>But if the matrix were already expanded, then it would appear anti-symmetric and simplification in the is_anti_symmetric routine is not needed:</p> <p>m = m.expand() m.is_anti_symmetric(simplify=False) True</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_diagonal","title":"<code>is_diagonal()</code>","text":"<p>Check if matrix is diagonal, that is matrix in which the entries outside the main diagonal are all zero.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_diagonal--examples","title":"Examples","text":"<p>from sympy import Matrix, diag m = Matrix(2, 2, [1, 0, 0, 2]) m Matrix([ [1, 0], [0, 2]]) m.is_diagonal() True</p> <p>m = Matrix(2, 2, [1, 1, 0, 2]) m Matrix([ [1, 1], [0, 2]]) m.is_diagonal() False</p> <p>m = diag(1, 2, 3) m Matrix([ [1, 0, 0], [0, 2, 0], [0, 0, 3]]) m.is_diagonal() True</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_diagonal--see-also","title":"See Also","text":"<p>is_lower is_upper sympy.matrices.matrixbase.MatrixBase.is_diagonalizable diagonalize</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_symbolic","title":"<code>is_symbolic()</code>","text":"<p>Checks if any elements contain Symbols.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_symbolic--examples","title":"Examples","text":"<p>from sympy import Matrix from sympy.abc import x, y M = Matrix([[x, y], [1, 0]]) M.is_symbolic() True</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_symmetric","title":"<code>is_symmetric(simplify=True)</code>","text":"<p>Check if matrix is symmetric matrix, that is square matrix and is equal to its transpose.</p> <p>By default, simplifications occur before testing symmetry. They can be skipped using 'simplify=False'; while speeding things a bit, this may however induce false negatives.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_symmetric--examples","title":"Examples","text":"<p>from sympy import Matrix m = Matrix(2, 2, [0, 1, 1, 2]) m Matrix([ [0, 1], [1, 2]]) m.is_symmetric() True</p> <p>m = Matrix(2, 2, [0, 1, 2, 0]) m Matrix([ [0, 1], [2, 0]]) m.is_symmetric() False</p> <p>m = Matrix(2, 3, [0, 0, 0, 0, 0, 0]) m Matrix([ [0, 0, 0], [0, 0, 0]]) m.is_symmetric() False</p> <p>from sympy.abc import x, y m = Matrix(3, 3, [1, x2 + 2*x + 1, y, (x + 1)2, 2, 0, y, 0, 3]) m Matrix([ [         1, x2 + 2*x + 1, y], [(x + 1)2,              2, 0], [         y,              0, 3]]) m.is_symmetric() True</p> <p>If the matrix is already simplified, you may speed-up is_symmetric() test by using 'simplify=False'.</p> <p>bool(m.is_symmetric(simplify=False)) False m1 = m.expand() m1.is_symmetric(simplify=False) True</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.values","title":"<code>values()</code>","text":"<p>Return non-zero values of self.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.values--examples","title":"Examples","text":"<p>from sympy import Matrix m = Matrix([[0, 1], [2, 3]]) m.values() [1, 2, 3]</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.values--see-also","title":"See Also","text":"<p>iter_values tolist flat</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.iter_values","title":"<code>iter_values()</code>","text":"<p>Iterate over non-zero values of self.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.iter_values--examples","title":"Examples","text":"<p>from sympy import Matrix m = Matrix([[0, 1], [2, 3]]) list(m.iter_values()) [1, 2, 3]</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.iter_values--see-also","title":"See Also","text":"<p>values</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.iter_items","title":"<code>iter_items()</code>","text":"<p>Iterate over indices and values of nonzero items.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.iter_items--examples","title":"Examples","text":"<p>from sympy import Matrix m = Matrix([[0, 1], [2, 3]]) list(m.iter_items()) [((0, 1), 1), ((1, 0), 2), ((1, 1), 3)]</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.iter_items--see-also","title":"See Also","text":"<p>iter_values todok</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_adjoint","title":"<code>_eval_adjoint()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_applyfunc","title":"<code>_eval_applyfunc(f)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_as_real_imag","title":"<code>_eval_as_real_imag()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_conjugate","title":"<code>_eval_conjugate()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_permute_cols","title":"<code>_eval_permute_cols(perm)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_permute_rows","title":"<code>_eval_permute_rows(perm)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_trace","title":"<code>_eval_trace()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_transpose","title":"<code>_eval_transpose()</code>","text":"<p>Returns the transposed SparseMatrix of this SparseMatrix.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_transpose--examples","title":"Examples","text":"<p>from sympy import SparseMatrix a = SparseMatrix(((1, 2), (3, 4))) a Matrix([ [1, 2], [3, 4]]) a.T Matrix([ [1, 3], [2, 4]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.applyfunc","title":"<code>applyfunc(f)</code>","text":"<p>Apply a function to each element of the matrix.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.applyfunc--examples","title":"Examples","text":"<p>from sympy import Matrix m = Matrix(2, 2, lambda i, j: i2+j) m Matrix([ [0, 1], [2, 3]]) m.applyfunc(lambda i: 2i) Matrix([ [0, 2], [4, 6]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.as_real_imag","title":"<code>as_real_imag(deep=True, **hints)</code>","text":"<p>Returns a tuple containing the (real, imaginary) part of matrix.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.conjugate","title":"<code>conjugate()</code>","text":"<p>Return the by-element conjugation.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.conjugate--examples","title":"Examples","text":"<p>from sympy import SparseMatrix, I a = SparseMatrix(((1, 2 + I), (3, 4), (I, -I))) a Matrix([ [1, 2 + I], [3,     4], [I,    -I]]) a.C Matrix([ [ 1, 2 - I], [ 3,     4], [-I,     I]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.conjugate--see-also","title":"See Also","text":"<p>transpose: Matrix transposition H: Hermite conjugation sympy.matrices.matrixbase.MatrixBase.D: Dirac conjugation</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.doit","title":"<code>doit(**hints)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.evalf","title":"<code>evalf(n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False)</code>","text":"<p>Apply evalf() to each element of self.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.expand","title":"<code>expand(deep=True, modulus=None, power_base=True, power_exp=True, mul=True, log=True, multinomial=True, basic=True, **hints)</code>","text":"<p>Apply core.function.expand to each entry of the matrix.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.expand--examples","title":"Examples","text":"<p>from sympy.abc import x from sympy import Matrix Matrix(1, 1, [x(x+1)]) Matrix([[x(x + 1)]]) _.expand() Matrix([[x**2 + x]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.permute","title":"<code>permute(perm, orientation='rows', direction='forward')</code>","text":"<p>Permute the rows or columns of a matrix by the given list of swaps.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.permute--parameters","title":"Parameters","text":"Permutation, list, or list of lists <p>A representation for the permutation.</p> <p>If it is <code>Permutation</code>, it is used directly with some resizing with respect to the matrix size.</p> <p>If it is specified as list of lists, (e.g., <code>[[0, 1], [0, 2]]</code>), then the permutation is formed from applying the product of cycles. The direction how the cyclic product is applied is described in below.</p> <p>If it is specified as a list, the list should represent an array form of a permutation. (e.g., <code>[1, 2, 0]</code>) which would would form the swapping function <code>0 \\mapsto 1, 1 \\mapsto 2, 2\\mapsto 0</code>.</p> 'rows', 'cols' <p>A flag to control whether to permute the rows or the columns</p> 'forward', 'backward' <p>A flag to control whether to apply the permutations from the start of the list first, or from the back of the list first.</p> <p>For example, if the permutation specification is <code>[[0, 1], [0, 2]]</code>,</p> <p>If the flag is set to <code>'forward'</code>, the cycle would be formed as <code>0 \\mapsto 2, 2 \\mapsto 1, 1 \\mapsto 0</code>.</p> <p>If the flag is set to <code>'backward'</code>, the cycle would be formed as <code>0 \\mapsto 1, 1 \\mapsto 2, 2 \\mapsto 0</code>.</p> <p>If the argument <code>perm</code> is not in a form of list of lists, this flag takes no effect.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.permute--examples","title":"Examples","text":"<p>from sympy import eye M = eye(3) M.permute([[0, 1], [0, 2]], orientation='rows', direction='forward') Matrix([ [0, 0, 1], [1, 0, 0], [0, 1, 0]])</p> <p>from sympy import eye M = eye(3) M.permute([[0, 1], [0, 2]], orientation='rows', direction='backward') Matrix([ [0, 1, 0], [0, 0, 1], [1, 0, 0]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.permute--notes","title":"Notes","text":"<p>If a bijective function <code>\\sigma : \\mathbb{N}_0 \\rightarrow \\mathbb{N}_0</code> denotes the permutation.</p> <p>If the matrix <code>A</code> is the matrix to permute, represented as a horizontal or a vertical stack of vectors:</p> <p>.. math::     A =     \\begin{bmatrix}     a_0 \\ a_1 \\ \\vdots \\ a_{n-1}     \\end{bmatrix} =     \\begin{bmatrix}     \\alpha_0 &amp; \\alpha_1 &amp; \\cdots &amp; \\alpha_{n-1}     \\end{bmatrix}</p> <p>If the matrix <code>B</code> is the result, the permutation of matrix rows is defined as:</p> <p>.. math::     B := \\begin{bmatrix}     a_{\\sigma(0)} \\ a_{\\sigma(1)} \\ \\vdots \\ a_{\\sigma(n-1)}     \\end{bmatrix}</p> <p>And the permutation of matrix columns is defined as:</p> <p>.. math::     B := \\begin{bmatrix}     \\alpha_{\\sigma(0)} &amp; \\alpha_{\\sigma(1)} &amp;     \\cdots &amp; \\alpha_{\\sigma(n-1)}     \\end{bmatrix}</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.permute_cols","title":"<code>permute_cols(swaps, direction='forward')</code>","text":"<p>Alias for <code>self.permute(swaps, orientation='cols', direction=direction)</code></p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.permute_cols--see-also","title":"See Also","text":"<p>permute</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.permute_rows","title":"<code>permute_rows(swaps, direction='forward')</code>","text":"<p>Alias for <code>self.permute(swaps, orientation='rows', direction=direction)</code></p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.permute_rows--see-also","title":"See Also","text":"<p>permute</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.refine","title":"<code>refine(assumptions=True)</code>","text":"<p>Apply refine to each element of the matrix.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.refine--examples","title":"Examples","text":"<p>from sympy import Symbol, Matrix, Abs, sqrt, Q x = Symbol('x') Matrix([[Abs(x)2, sqrt(x2)],[sqrt(x2), Abs(x)2]]) Matrix([ [ Abs(x)2, sqrt(x2)], [sqrt(x2),  Abs(x)2]]) _.refine(Q.real(x)) Matrix([ [  x2, Abs(x)], [Abs(x),   x2]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.replace","title":"<code>replace(F, G, map=False, simultaneous=True, exact=None)</code>","text":"<p>Replaces Function F in Matrix entries with Function G.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.replace--examples","title":"Examples","text":"<p>from sympy import symbols, Function, Matrix F, G = symbols('F, G', cls=Function) M = Matrix(2, 2, lambda i, j: F(i+j)) ; M Matrix([ [F(0), F(1)], [F(1), F(2)]]) N = M.replace(F,G) N Matrix([ [G(0), G(1)], [G(1), G(2)]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.rot90","title":"<code>rot90(k=1)</code>","text":"<p>Rotates Matrix by 90 degrees</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.rot90--parameters","title":"Parameters","text":"int <p>Specifies how many times the matrix is rotated by 90 degrees (clockwise when positive, counter-clockwise when negative).</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.rot90--examples","title":"Examples","text":"<p>from sympy import Matrix, symbols A = Matrix(2, 2, symbols('a:d')) A Matrix([ [a, b], [c, d]])</p> <p>Rotating the matrix clockwise one time:</p> <p>A.rot90(1) Matrix([ [c, a], [d, b]])</p> <p>Rotating the matrix anticlockwise two times:</p> <p>A.rot90(-2) Matrix([ [d, c], [b, a]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.trace","title":"<code>trace()</code>","text":"<p>Returns the trace of a square matrix i.e. the sum of the diagonal elements.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.trace--examples","title":"Examples","text":"<p>from sympy import Matrix A = Matrix(2, 2, [1, 2, 3, 4]) A.trace() 5</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.transpose","title":"<code>transpose()</code>","text":"<p>Returns the transpose of the matrix.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.transpose--examples","title":"Examples","text":"<p>from sympy import Matrix A = Matrix(2, 2, [1, 2, 3, 4]) A.transpose() Matrix([ [1, 3], [2, 4]])</p> <p>from sympy import Matrix, I m=Matrix(((1, 2+I), (3, 4))) m Matrix([ [1, 2 + I], [3,     4]]) m.transpose() Matrix([ [    1, 3], [2 + I, 4]]) m.T == m.transpose() True</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.transpose--see-also","title":"See Also","text":"<p>conjugate: By-element conjugation</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.n","title":"<code>n(*args, **kwargs)</code>","text":"<p>Apply evalf() to each element of self.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.xreplace","title":"<code>xreplace(rule)</code>","text":"<p>Return a new matrix with xreplace applied to each entry.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.xreplace--examples","title":"Examples","text":"<p>from sympy.abc import x, y from sympy import SparseMatrix, Matrix SparseMatrix(1, 1, [x]) Matrix([[x]]) .xreplace({x: y}) Matrix([[y]]) Matrix().xreplace({y: x}) Matrix([[x]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_simplify","title":"<code>_eval_simplify(**kwargs)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_trigsimp","title":"<code>_eval_trigsimp(**opts)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.upper_triangular","title":"<code>upper_triangular(k=0)</code>","text":"<p>Return the elements on and above the kth diagonal of a matrix. If k is not specified then simply returns upper-triangular portion of a matrix</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.upper_triangular--examples","title":"Examples","text":"<p>from sympy import ones A = ones(4) A.upper_triangular() Matrix([ [1, 1, 1, 1], [0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1]])</p> <p>A.upper_triangular(2) Matrix([ [0, 0, 1, 1], [0, 0, 0, 1], [0, 0, 0, 0], [0, 0, 0, 0]])</p> <p>A.upper_triangular(-1) Matrix([ [1, 1, 1, 1], [1, 1, 1, 1], [0, 1, 1, 1], [0, 0, 1, 1]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.lower_triangular","title":"<code>lower_triangular(k=0)</code>","text":"<p>Return the elements on and below the kth diagonal of a matrix. If k is not specified then simply returns lower-triangular portion of a matrix</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.lower_triangular--examples","title":"Examples","text":"<p>from sympy import ones A = ones(4) A.lower_triangular() Matrix([ [1, 0, 0, 0], [1, 1, 0, 0], [1, 1, 1, 0], [1, 1, 1, 1]])</p> <p>A.lower_triangular(-2) Matrix([ [0, 0, 0, 0], [0, 0, 0, 0], [1, 0, 0, 0], [1, 1, 0, 0]])</p> <p>A.lower_triangular(1) Matrix([ [1, 1, 0, 0], [1, 1, 1, 0], [1, 1, 1, 1], [1, 1, 1, 1]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_Abs","title":"<code>_eval_Abs()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_add","title":"<code>_eval_add(other)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_matrix_mul","title":"<code>_eval_matrix_mul(other)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_matrix_mul_elementwise","title":"<code>_eval_matrix_mul_elementwise(other)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_matrix_rmul","title":"<code>_eval_matrix_rmul(other)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_pow_by_recursion","title":"<code>_eval_pow_by_recursion(num)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_pow_by_cayley","title":"<code>_eval_pow_by_cayley(exp)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_pow_by_recursion_dotprodsimp","title":"<code>_eval_pow_by_recursion_dotprodsimp(num, prevsimp=None)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_scalar_mul","title":"<code>_eval_scalar_mul(other)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_scalar_rmul","title":"<code>_eval_scalar_rmul(other)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_Mod","title":"<code>_eval_Mod(other)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.__truediv__","title":"<code>__truediv__(other)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.__matmul__","title":"<code>__matmul__(other)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.__mod__","title":"<code>__mod__(other)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.multiply","title":"<code>multiply(other, dotprodsimp=None)</code>","text":"<p>Same as mul() but with optional simplification.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.multiply--parameters","title":"Parameters","text":"bool, optional <p>Specifies whether intermediate term algebraic simplification is used during matrix multiplications to control expression blowup and thus speed up calculation. Default is off.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.multiply_elementwise","title":"<code>multiply_elementwise(other)</code>","text":"<p>Return the Hadamard product (elementwise product) of A and B</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.multiply_elementwise--examples","title":"Examples","text":"<p>from sympy import Matrix A = Matrix([[0, 1, 2], [3, 4, 5]]) B = Matrix([[1, 10, 100], [100, 10, 1]]) A.multiply_elementwise(B) Matrix([ [  0, 10, 200], [300, 40,   5]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.multiply_elementwise--see-also","title":"See Also","text":"<p>sympy.matrices.matrixbase.MatrixBase.cross sympy.matrices.matrixbase.MatrixBase.dot multiply</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.__pow__","title":"<code>__pow__(exp)</code>","text":"<p>Return self**exp a scalar or symbol.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.pow","title":"<code>pow(exp, method=None)</code>","text":"<p>Return self**exp a scalar or symbol.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.pow--parameters","title":"Parameters","text":"multiply, mulsimp, jordan, cayley <p>If multiply then it returns exponentiation using recursion. If jordan then Jordan form exponentiation will be used. If cayley then the exponentiation is done using Cayley-Hamilton theorem. If mulsimp then the exponentiation is done using recursion with dotprodsimp. This specifies whether intermediate term algebraic simplification is used during naive matrix power to control expression blowup and thus speed up calculation. If None, then it heuristically decides which method to use.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.__radd__","title":"<code>__radd__(other)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.__rmatmul__","title":"<code>__rmatmul__(other)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.rmultiply","title":"<code>rmultiply(other, dotprodsimp=None)</code>","text":"<p>Same as rmul() but with optional simplification.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.rmultiply--parameters","title":"Parameters","text":"bool, optional <p>Specifies whether intermediate term algebraic simplification is used during matrix multiplications to control expression blowup and thus speed up calculation. Default is off.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.__rsub__","title":"<code>__rsub__(a)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.__sub__","title":"<code>__sub__(a)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_det_bareiss","title":"<code>_eval_det_bareiss(iszerofunc=_is_zero_after_expand_mul)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_det_berkowitz","title":"<code>_eval_det_berkowitz()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_det_lu","title":"<code>_eval_det_lu(iszerofunc=_iszero, simpfunc=None)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_det_bird","title":"<code>_eval_det_bird()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_det_laplace","title":"<code>_eval_det_laplace()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_determinant","title":"<code>_eval_determinant()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.adjugate","title":"<code>adjugate(method='berkowitz')</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.charpoly","title":"<code>charpoly(x='lambda', simplify=_utilities_simplify)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.cofactor","title":"<code>cofactor(i, j, method='berkowitz')</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.cofactor_matrix","title":"<code>cofactor_matrix(method='berkowitz')</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.det","title":"<code>det(method='bareiss', iszerofunc=None)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.per","title":"<code>per()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.minor","title":"<code>minor(i, j, method='berkowitz')</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.minor_submatrix","title":"<code>minor_submatrix(i, j)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.echelon_form","title":"<code>echelon_form(iszerofunc=_iszero, simplify=False, with_pivots=False)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.rank","title":"<code>rank(iszerofunc=_iszero, simplify=False)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.rref_rhs","title":"<code>rref_rhs(rhs)</code>","text":"<p>Return reduced row-echelon form of matrix, matrix showing rhs after reduction steps. <code>rhs</code> must have the same number of rows as <code>self</code>.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.rref_rhs--examples","title":"Examples","text":"<p>from sympy import Matrix, symbols r1, r2 = symbols('r1 r2') Matrix([[1, 1], [2, 1]]).rref_rhs(Matrix([r1, r2])) (Matrix([ [1, 0], [0, 1]]), Matrix([ [ -r1 + r2], [2*r1 - r2]]))</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix._normalize_op_args","title":"<code>_normalize_op_args(op, col, k, col1, col2, error_str='col')</code>","text":"<p>Validate the arguments for a row/column operation.  <code>error_str</code> can be one of \"row\" or \"col\" depending on the arguments being parsed.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_col_op_multiply_col_by_const","title":"<code>_eval_col_op_multiply_col_by_const(col, k)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_col_op_swap","title":"<code>_eval_col_op_swap(col1, col2)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_col_op_add_multiple_to_other_col","title":"<code>_eval_col_op_add_multiple_to_other_col(col, k, col2)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_row_op_swap","title":"<code>_eval_row_op_swap(row1, row2)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_row_op_multiply_row_by_const","title":"<code>_eval_row_op_multiply_row_by_const(row, k)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_row_op_add_multiple_to_other_row","title":"<code>_eval_row_op_add_multiple_to_other_row(row, k, row2)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.elementary_col_op","title":"<code>elementary_col_op(op='n-&gt;kn', col=None, k=None, col1=None, col2=None)</code>","text":"<p>Performs the elementary column operation <code>op</code>.</p> <p><code>op</code> may be one of</p> Text Only<pre><code>* ``\"n-&gt;kn\"`` (column n goes to k*n)\n* ``\"n&lt;-&gt;m\"`` (swap column n and column m)\n* ``\"n-&gt;n+km\"`` (column n goes to column n + k*column m)\n</code></pre>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.elementary_col_op--parameters","title":"Parameters","text":"<p>op : string; the elementary row operation col : the column to apply the column operation k : the multiple to apply in the column operation col1 : one column of a column swap col2 : second column of a column swap or column \"m\" in the column operation        \"n-&gt;n+km\"</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.elementary_row_op","title":"<code>elementary_row_op(op='n-&gt;kn', row=None, k=None, row1=None, row2=None)</code>","text":"<p>Performs the elementary row operation <code>op</code>.</p> <p><code>op</code> may be one of</p> Text Only<pre><code>* ``\"n-&gt;kn\"`` (row n goes to k*n)\n* ``\"n&lt;-&gt;m\"`` (swap row n and row m)\n* ``\"n-&gt;n+km\"`` (row n goes to row n + k*row m)\n</code></pre>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.elementary_row_op--parameters","title":"Parameters","text":"<p>op : string; the elementary row operation row : the row to apply the row operation k : the multiple to apply in the row operation row1 : one row of a row swap row2 : second row of a row swap or row \"m\" in the row operation        \"n-&gt;n+km\"</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.columnspace","title":"<code>columnspace(simplify=False)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.rowspace","title":"<code>rowspace(simplify=False)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.eigenvals","title":"<code>eigenvals(error_when_incomplete=True, **flags)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.eigenvects","title":"<code>eigenvects(error_when_incomplete=True, iszerofunc=_iszero, **flags)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.bidiagonalize","title":"<code>bidiagonalize(upper=True)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.bidiagonal_decomposition","title":"<code>bidiagonal_decomposition(upper=True)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.jordan_form","title":"<code>jordan_form(calc_transform=True, **kwargs)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.left_eigenvects","title":"<code>left_eigenvects(**flags)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.singular_values","title":"<code>singular_values()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.diff","title":"<code>diff(*args, evaluate=True, **kwargs)</code>","text":"<p>Calculate the derivative of each element in the matrix.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.diff--examples","title":"Examples","text":"<p>from sympy import Matrix from sympy.abc import x, y M = Matrix([[x, y], [1, 0]]) M.diff(x) Matrix([ [1, 0], [0, 0]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.diff--see-also","title":"See Also","text":"<p>integrate limit</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_derivative","title":"<code>_eval_derivative(arg)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.integrate","title":"<code>integrate(*args, **kwargs)</code>","text":"<p>Integrate each element of the matrix.  <code>args</code> will be passed to the <code>integrate</code> function.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.integrate--examples","title":"Examples","text":"<p>from sympy import Matrix from sympy.abc import x, y M = Matrix([[x, y], [1, 0]]) M.integrate((x, )) Matrix([ [x2/2, xy], [     x,   0]]) M.integrate((x, 0, 2)) Matrix([ [2, 2y], [2,   0]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.integrate--see-also","title":"See Also","text":"<p>limit diff</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.jacobian","title":"<code>jacobian(X)</code>","text":"<p>Calculates the Jacobian matrix (derivative of a vector-valued function).</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.jacobian--parameters","title":"Parameters","text":"<p><code>self</code> : vector of expressions representing functions f_i(x_1, ..., x_n). X : set of x_i's in order, it can be a list or a Matrix</p> <p>Both <code>self</code> and X can be a row or a column matrix in any order (i.e., jacobian() should always work).</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.jacobian--examples","title":"Examples","text":"<p>from sympy import sin, cos, Matrix from sympy.abc import rho, phi X = Matrix([rhocos(phi), rhosin(phi), rho2]) Y = Matrix([rho, phi]) X.jacobian(Y) Matrix([ [cos(phi), -rhosin(phi)], [sin(phi),  rhocos(phi)], [   2rho,             0]]) X = Matrix([rhocos(phi), rhosin(phi)]) X.jacobian(Y) Matrix([ [cos(phi), -rhosin(phi)], [sin(phi),  rho*cos(phi)]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.jacobian--see-also","title":"See Also","text":"<p>hessian wronskian</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.limit","title":"<code>limit(*args)</code>","text":"<p>Calculate the limit of each element in the matrix. <code>args</code> will be passed to the <code>limit</code> function.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.limit--examples","title":"Examples","text":"<p>from sympy import Matrix from sympy.abc import x, y M = Matrix([[x, y], [1, 0]]) M.limit(x, 2) Matrix([ [2, y], [1, 0]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.limit--see-also","title":"See Also","text":"<p>integrate diff</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.berkowitz_charpoly","title":"<code>berkowitz_charpoly(x=Dummy('lambda'), simplify=_utilities_simplify)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.berkowitz_det","title":"<code>berkowitz_det()</code>","text":"<p>Computes determinant using Berkowitz method.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.berkowitz_det--see-also","title":"See Also","text":"<p>det</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.berkowitz_eigenvals","title":"<code>berkowitz_eigenvals(**flags)</code>","text":"<p>Computes eigenvalues of a Matrix using Berkowitz method.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.berkowitz_minors","title":"<code>berkowitz_minors()</code>","text":"<p>Computes principal minors using Berkowitz method.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.berkowitz","title":"<code>berkowitz()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.cofactorMatrix","title":"<code>cofactorMatrix(method='berkowitz')</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.det_bareis","title":"<code>det_bareis()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.det_LU_decomposition","title":"<code>det_LU_decomposition()</code>","text":"<p>Compute matrix determinant using LU decomposition.</p> <p>Note that this method fails if the LU decomposition itself fails. In particular, if the matrix has no inverse this method will fail.</p> <p>TODO: Implement algorithm for sparse matrices (SFF), http://www.eecis.udel.edu/~saunders/papers/sffge/it5.ps.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.det_LU_decomposition--see-also","title":"See Also","text":"<p>det berkowitz_det</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.jordan_cell","title":"<code>jordan_cell(eigenval, n)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.jordan_cells","title":"<code>jordan_cells(calc_transformation=True)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.minorEntry","title":"<code>minorEntry(i, j, method='berkowitz')</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.minorMatrix","title":"<code>minorMatrix(i, j)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.permuteBkwd","title":"<code>permuteBkwd(perm)</code>","text":"<p>Permute the rows of the matrix with the given permutation in reverse.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.permuteFwd","title":"<code>permuteFwd(perm)</code>","text":"<p>Permute the rows of the matrix with the given permutation.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.flat","title":"<code>flat()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.__array__","title":"<code>__array__(dtype=object, copy=None)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of elements of <code>self</code>.</p> <p>Implemented mainly so bool(Matrix()) == False.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix._matrix_pow_by_jordan_blocks","title":"<code>_matrix_pow_by_jordan_blocks(num)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._format_str","title":"<code>_format_str(printer=None)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.irregular","title":"<code>irregular(ntop, *matrices, **kwargs)</code>  <code>classmethod</code>","text":"<p>Return a matrix filled by the given matrices which are listed in order of appearance from left to right, top to bottom as they first appear in the matrix. They must fill the matrix completely.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.irregular--examples","title":"Examples","text":"<p>from sympy import ones, Matrix Matrix.irregular(3, ones(2,1), ones(3,3)2, ones(2,2)3, ...   ones(1,1)4, ones(2,2)5, ones(1,2)6, ones(1,2)7) Matrix([   [1, 2, 2, 2, 3, 3],   [1, 2, 2, 2, 3, 3],   [4, 2, 2, 2, 5, 5],   [6, 6, 7, 7, 5, 5]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix._handle_ndarray","title":"<code>_handle_ndarray(arg)</code>  <code>classmethod</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._handle_creation_inputs","title":"<code>_handle_creation_inputs(*args, **kwargs)</code>  <code>classmethod</code>","text":"<p>Return the number of rows, cols and flat matrix elements.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix._handle_creation_inputs--examples","title":"Examples","text":"<p>from sympy import Matrix, I</p> <p>Matrix can be constructed as follows:</p> <ul> <li>from a nested list of iterables</li> </ul> <p>Matrix( ((1, 2+I), (3, 4)) ) Matrix([ [1, 2 + I], [3,     4]])</p> <ul> <li>from un-nested iterable (interpreted as a column)</li> </ul> <p>Matrix( [1, 2] ) Matrix([ [1], [2]])</p> <ul> <li>from un-nested iterable with dimensions</li> </ul> <p>Matrix(1, 2, [1, 2] ) Matrix([[1, 2]])</p> <ul> <li>from no arguments (a 0 x 0 matrix)</li> </ul> <p>Matrix() Matrix(0, 0, [])</p> <ul> <li>from a rule</li> </ul> <p>Matrix(2, 2, lambda i, j: i/(j + 1) ) Matrix([ [0,   0], [1, 1/2]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix._handle_creation_inputs--see-also","title":"See Also","text":"<p>irregular - filling a matrix with irregular blocks</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix._setitem","title":"<code>_setitem(key, value)</code>","text":"<p>Helper to set value at location given by key.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix._setitem--examples","title":"Examples","text":"<p>from sympy import Matrix, I, zeros, ones m = Matrix(((1, 2+I), (3, 4))) m Matrix([ [1, 2 + I], [3,     4]]) m[1, 0] = 9 m Matrix([ [1, 2 + I], [9,     4]]) m[1, 0] = [[0, 1]]</p> <p>To replace row r you assign to position r*m where m is the number of columns:</p> <p>M = zeros(4) m = M.cols M[3m] = ones(1, m)2; M Matrix([ [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 2, 2, 2]])</p> <p>And to replace column c you can assign to position c:</p> <p>M[2] = ones(m, 1)*4; M Matrix([ [0, 0, 4, 0], [0, 0, 4, 0], [0, 0, 4, 0], [2, 2, 4, 2]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.add","title":"<code>add(b)</code>","text":"<p>Return self + b.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.condition_number","title":"<code>condition_number()</code>","text":"<p>Returns the condition number of a matrix.</p> <p>This is the maximum singular value divided by the minimum singular value</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.condition_number--examples","title":"Examples","text":"<p>from sympy import Matrix, S A = Matrix([[1, 0, 0], [0, 10, 0], [0, 0, S.One/10]]) A.condition_number() 100</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.condition_number--see-also","title":"See Also","text":"<p>singular_values</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.cross","title":"<code>cross(b)</code>","text":"<p>Return the cross product of <code>self</code> and <code>b</code> relaxing the condition of compatible dimensions: if each has 3 elements, a matrix of the same type and shape as <code>self</code> will be returned. If <code>b</code> has the same shape as <code>self</code> then common identities for the cross product (like <code>a \\times b = - b \\times a</code>) will hold.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.cross--parameters","title":"Parameters","text":"Text Only<pre><code>b : 3x1 or 1x3 Matrix\n</code></pre>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.cross--see-also","title":"See Also","text":"<p>dot hat vee multiply multiply_elementwise</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.hat","title":"<code>hat()</code>","text":"<p>Return the skew-symmetric matrix representing the cross product, so that <code>self.hat() * b</code> is equivalent to  <code>self.cross(b)</code>.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.hat--examples","title":"Examples","text":"<p>Calling <code>hat</code> creates a skew-symmetric 3x3 Matrix from a 3x1 Matrix:</p> <p>from sympy import Matrix a = Matrix([1, 2, 3]) a.hat() Matrix([ [ 0, -3,  2], [ 3,  0, -1], [-2,  1,  0]])</p> <p>Multiplying it with another 3x1 Matrix calculates the cross product:</p> <p>b = Matrix([3, 2, 1]) a.hat() * b Matrix([ [-4], [ 8], [-4]])</p> <p>Which is equivalent to calling the <code>cross</code> method:</p> <p>a.cross(b) Matrix([ [-4], [ 8], [-4]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.hat--see-also","title":"See Also","text":"<p>dot cross vee multiply multiply_elementwise</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.vee","title":"<code>vee()</code>","text":"<p>Return a 3x1 vector from a skew-symmetric matrix representing the cross product, so that <code>self * b</code> is equivalent to  <code>self.vee().cross(b)</code>.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.vee--examples","title":"Examples","text":"<p>Calling <code>vee</code> creates a vector from a skew-symmetric Matrix:</p> <p>from sympy import Matrix A = Matrix([[0, -3, 2], [3, 0, -1], [-2, 1, 0]]) a = A.vee() a Matrix([ [1], [2], [3]])</p> <p>Calculating the matrix product of the original matrix with a vector is equivalent to a cross product:</p> <p>b = Matrix([3, 2, 1]) A * b Matrix([ [-4], [ 8], [-4]])</p> <p>a.cross(b) Matrix([ [-4], [ 8], [-4]])</p> <p><code>vee</code> can also be used to retrieve angular velocity expressions. Defining a rotation matrix:</p> <p>from sympy import rot_ccw_axis3, trigsimp from sympy.physics.mechanics import dynamicsymbols theta = dynamicsymbols('theta') R = rot_ccw_axis3(theta) R Matrix([ [cos(theta(t)), -sin(theta(t)), 0], [sin(theta(t)),  cos(theta(t)), 0], [            0,              0, 1]])</p> <p>We can retrive the angular velocity:</p> <p>Omega = R.T * R.diff() Omega = trigsimp(Omega) Omega.vee() Matrix([ [                      0], [                      0], [Derivative(theta(t), t)]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.vee--see-also","title":"See Also","text":"<p>dot cross hat multiply multiply_elementwise</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.dot","title":"<code>dot(b, hermitian=None, conjugate_convention=None)</code>","text":"<p>Return the dot or inner product of two vectors of equal length. Here <code>self</code> must be a <code>Matrix</code> of size 1 x n or n x 1, and <code>b</code> must be either a matrix of size 1 x n, n x 1, or a list/tuple of length n. A scalar is returned.</p> <p>By default, <code>dot</code> does not conjugate <code>self</code> or <code>b</code>, even if there are complex entries. Set <code>hermitian=True</code> (and optionally a <code>conjugate_convention</code>) to compute the hermitian inner product.</p> <p>Possible kwargs are <code>hermitian</code> and <code>conjugate_convention</code>.</p> <p>If <code>conjugate_convention</code> is <code>\"left\"</code>, <code>\"math\"</code> or <code>\"maths\"</code>, the conjugate of the first vector (<code>self</code>) is used.  If <code>\"right\"</code> or <code>\"physics\"</code> is specified, the conjugate of the second vector <code>b</code> is used.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.dot--examples","title":"Examples","text":"<p>from sympy import Matrix M = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) v = Matrix([1, 1, 1]) M.row(0).dot(v) 6 M.col(0).dot(v) 12 v = [3, 2, 1] M.row(0).dot(v) 10</p> <p>from sympy import I q = Matrix([1I, 1I, 1*I]) q.dot(q, hermitian=False) -3</p> <p>q.dot(q, hermitian=True) 3</p> <p>q1 = Matrix([1, 1, 1I]) q.dot(q1, hermitian=True, conjugate_convention=\"maths\") 1 - 2I q.dot(q1, hermitian=True, conjugate_convention=\"physics\") 1 + 2*I</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.dot--see-also","title":"See Also","text":"<p>cross multiply multiply_elementwise</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.dual","title":"<code>dual()</code>","text":"<p>Returns the dual of a matrix.</p> <p>A dual of a matrix is:</p> <p><code>(1/2)*levicivita(i, j, k, l)*M(k, l)</code> summed over indices <code>k</code> and <code>l</code></p> <p>Since the levicivita method is anti_symmetric for any pairwise exchange of indices, the dual of a symmetric matrix is the zero matrix. Strictly speaking the dual defined here assumes that the 'matrix' <code>M</code> is a contravariant anti_symmetric second rank tensor, so that the dual is a covariant second rank tensor.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_matrix_exp_jblock","title":"<code>_eval_matrix_exp_jblock()</code>","text":"<p>A helper function to compute an exponential of a Jordan block matrix</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_matrix_exp_jblock--examples","title":"Examples","text":"<p>from sympy import Symbol, Matrix l = Symbol('lamda')</p> <p>A trivial example of 1*1 Jordan block:</p> <p>m = Matrix.jordan_block(1, l) m._eval_matrix_exp_jblock() Matrix([[exp(lamda)]])</p> <p>An example of 3*3 Jordan block:</p> <p>m = Matrix.jordan_block(3, l) m._eval_matrix_exp_jblock() Matrix([ [exp(lamda), exp(lamda), exp(lamda)/2], [         0, exp(lamda),   exp(lamda)], [         0,          0,   exp(lamda)]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_matrix_exp_jblock--references","title":"References","text":"<p>.. [1] https://en.wikipedia.org/wiki/Matrix_function#Jordan_decomposition</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.analytic_func","title":"<code>analytic_func(f, x)</code>","text":"<p>Computes f(A) where A is a Square Matrix and f is an analytic function.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.analytic_func--examples","title":"Examples","text":"<p>from sympy import Symbol, Matrix, S, log</p> <p>x = Symbol('x') m = Matrix([[S(5)/4, S(3)/4], [S(3)/4, S(5)/4]]) f = log(x) m.analytic_func(f, x) Matrix([ [     0, log(2)], [log(2),      0]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.analytic_func--parameters","title":"Parameters","text":"Expr <p>Analytic Function</p> <p>x : Symbol     parameter of f</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.exp","title":"<code>exp()</code>","text":"<p>Return the exponential of a square matrix.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.exp--examples","title":"Examples","text":"<p>from sympy import Symbol, Matrix</p> <p>t = Symbol('t') m = Matrix([[0, 1], [-1, 0]]) * t m.exp() Matrix([ [    exp(It)/2 + exp(-It)/2, -Iexp(It)/2 + Iexp(-It)/2], [Iexp(It)/2 - Iexp(-It)/2,      exp(It)/2 + exp(-It)/2]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_matrix_log_jblock","title":"<code>_eval_matrix_log_jblock()</code>","text":"<p>Helper function to compute logarithm of a jordan block.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_matrix_log_jblock--examples","title":"Examples","text":"<p>from sympy import Symbol, Matrix l = Symbol('lamda')</p> <p>A trivial example of 1*1 Jordan block:</p> <p>m = Matrix.jordan_block(1, l) m._eval_matrix_log_jblock() Matrix([[log(lamda)]])</p> <p>An example of 3*3 Jordan block:</p> <p>m = Matrix.jordan_block(3, l) m._eval_matrix_log_jblock() Matrix([ [log(lamda),    1/lamda, -1/(2lamda*2)], [         0, log(lamda),         1/lamda], [         0,          0,      log(lamda)]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.log","title":"<code>log(simplify=cancel)</code>","text":"<p>Return the logarithm of a square matrix.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.log--parameters","title":"Parameters","text":"function, bool <p>The function to simplify the result with.</p> <p>Default is <code>cancel</code>, which is effective to reduce the expression growing for taking reciprocals and inverses for symbolic matrices.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.log--examples","title":"Examples","text":"<p>from sympy import S, Matrix</p> <p>Examples for positive-definite matrices:</p> <p>m = Matrix([[1, 1], [0, 1]]) m.log() Matrix([ [0, 1], [0, 0]])</p> <p>m = Matrix([[S(5)/4, S(3)/4], [S(3)/4, S(5)/4]]) m.log() Matrix([ [     0, log(2)], [log(2),      0]])</p> <p>Examples for non positive-definite matrices:</p> <p>m = Matrix([[S(3)/4, S(5)/4], [S(5)/4, S(3)/4]]) m.log() Matrix([ [         Ipi/2, log(2) - Ipi/2], [log(2) - Ipi/2,          Ipi/2]])</p> <p>m = Matrix( ...     [[0, 0, 0, 1], ...      [0, 0, 1, 0], ...      [0, 1, 0, 0], ...      [1, 0, 0, 0]]) m.log() Matrix([ [ Ipi/2,       0,       0, -Ipi/2], [      0,  Ipi/2, -Ipi/2,       0], [      0, -Ipi/2,  Ipi/2,       0], [-Ipi/2,       0,       0,  Ipi/2]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_nilpotent","title":"<code>is_nilpotent()</code>","text":"<p>Checks if a matrix is nilpotent.</p> <p>A matrix B is nilpotent if for some integer k, B**k is a zero matrix.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.is_nilpotent--examples","title":"Examples","text":"<p>from sympy import Matrix a = Matrix([[0, 0, 0], [1, 0, 0], [1, 1, 0]]) a.is_nilpotent() True</p> <p>a = Matrix([[1, 0, 1], [1, 0, 0], [1, 1, 0]]) a.is_nilpotent() False</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.key2bounds","title":"<code>key2bounds(keys)</code>","text":"<p>Converts a key with potentially mixed types of keys (integer and slice) into a tuple of ranges and raises an error if any index is out of <code>self</code>'s range.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.key2bounds--see-also","title":"See Also","text":"<p>key2ij</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.key2ij","title":"<code>key2ij(key)</code>","text":"<p>Converts key into canonical form, converting integers or indexable items into valid integers for <code>self</code>'s range or returning slices unchanged.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.key2ij--see-also","title":"See Also","text":"<p>key2bounds</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.norm","title":"<code>norm(ord=None)</code>","text":"<p>Return the Norm of a Matrix or Vector.</p> <p>In the simplest case this is the geometric size of the vector Other norms can be specified by the ord parameter</p> <p>=====  ============================  ========================== ord    norm for matrices             norm for vectors =====  ============================  ========================== None   Frobenius norm                2-norm 'fro'  Frobenius norm                - does not exist inf    maximum row sum               max(abs(x)) -inf   --                            min(abs(x)) 1      maximum column sum            as below -1     --                            as below 2      2-norm (largest sing. value)  as below -2     smallest singular value       as below other  - does not exist              sum(abs(x)ord)(1./ord) =====  ============================  ==========================</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.norm--examples","title":"Examples","text":"<p>from sympy import Matrix, Symbol, trigsimp, cos, sin, oo x = Symbol('x', real=True) v = Matrix([cos(x), sin(x)]) trigsimp( v.norm() ) 1 v.norm(10) (sin(x)10 + cos(x)10)**(1/10) A = Matrix([[1, 1], [1, 1]]) A.norm(1) # maximum sum of absolute values of A is 2 2 A.norm(2) # Spectral norm (max of |Ax|/|x| under 2-vector-norm) 2 A.norm(-2) # Inverse spectral norm (smallest singular value) 0 A.norm() # Frobenius Norm 2 A.norm(oo) # Infinity Norm 2 Matrix([1, -2]).norm(oo) 2 Matrix([-1, 2]).norm(-oo) 1</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.norm--see-also","title":"See Also","text":"<p>normalized</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.print_nonzero","title":"<code>print_nonzero(symb='X')</code>","text":"<p>Shows location of non-zero entries for fast shape lookup.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.print_nonzero--examples","title":"Examples","text":"<p>from sympy import Matrix, eye m = Matrix(2, 3, lambda i, j: i*3+j) m Matrix([ [0, 1, 2], [3, 4, 5]]) m.print_nonzero() [ XX][XXX] m = eye(4) m.print_nonzero(\"x\") [x   ][ x  ] [  x ][   x]</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.project","title":"<code>project(v)</code>","text":"<p>Return the projection of <code>self</code> onto the line containing <code>v</code>.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.project--examples","title":"Examples","text":"<p>from sympy import Matrix, S, sqrt V = Matrix([sqrt(3)/2, S.Half]) x = Matrix([[1, 0]]) V.project(x) Matrix([[sqrt(3)/2, 0]]) V.project(-x) Matrix([[sqrt(3)/2, 0]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.table","title":"<code>table(printer, rowstart='[', rowend=']', rowsep='\\n', colsep=', ', align='right')</code>","text":"<p>String form of Matrix as a table.</p> <p><code>printer</code> is the printer to use for on the elements (generally something like StrPrinter())</p> <p><code>rowstart</code> is the string used to start each row (by default '[').</p> <p><code>rowend</code> is the string used to end each row (by default ']').</p> <p><code>rowsep</code> is the string used to separate rows (by default a newline).</p> <p><code>colsep</code> is the string used to separate columns (by default ', ').</p> <p><code>align</code> defines how the elements are aligned. Must be one of 'left', 'right', or 'center'.  You can also use '&lt;', '&gt;', and '^' to mean the same thing, respectively.</p> <p>This is used by the string printer for Matrix.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.table--examples","title":"Examples","text":"<p>from sympy import Matrix, StrPrinter M = Matrix([[1, 2], [-33, 4]]) printer = StrPrinter() M.table(printer) '[  1, 2]\\n[-33, 4]' print(M.table(printer)) [  1, 2][-33, 4] print(M.table(printer, rowsep=',\\n')) [  1, 2], [-33, 4] print('[%s]' % M.table(printer, rowsep=',\\n')) [[  1, 2], [-33, 4]] print(M.table(printer, colsep=' ')) [  1 2][-33 4] print(M.table(printer, align='center')) [ 1 , 2][-33, 4] print(M.table(printer, rowstart='{', rowend='}')) {  1, 2}</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.rank_decomposition","title":"<code>rank_decomposition(iszerofunc=_iszero, simplify=False)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.cholesky","title":"<code>cholesky(hermitian=True)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.LDLdecomposition","title":"<code>LDLdecomposition(hermitian=True)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.LUdecomposition","title":"<code>LUdecomposition(iszerofunc=_iszero, simpfunc=None, rankcheck=False)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.LUdecomposition_Simple","title":"<code>LUdecomposition_Simple(iszerofunc=_iszero, simpfunc=None, rankcheck=False)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.LUdecompositionFF","title":"<code>LUdecompositionFF()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.upper_hessenberg_decomposition","title":"<code>upper_hessenberg_decomposition()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.diagonal_solve","title":"<code>diagonal_solve(rhs)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.lower_triangular_solve","title":"<code>lower_triangular_solve(rhs)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.upper_triangular_solve","title":"<code>upper_triangular_solve(rhs)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.cholesky_solve","title":"<code>cholesky_solve(rhs)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.LDLsolve","title":"<code>LDLsolve(rhs)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.LUsolve","title":"<code>LUsolve(rhs, iszerofunc=_iszero)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.QRsolve","title":"<code>QRsolve(b)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.gauss_jordan_solve","title":"<code>gauss_jordan_solve(B, freevar=False)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.pinv_solve","title":"<code>pinv_solve(B, arbitrary_matrix=None)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.pinv","title":"<code>pinv(method='RD')</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.inverse_ADJ","title":"<code>inverse_ADJ(iszerofunc=_iszero)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.inverse_BLOCK","title":"<code>inverse_BLOCK(iszerofunc=_iszero)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.inverse_GE","title":"<code>inverse_GE(iszerofunc=_iszero)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.inverse_LU","title":"<code>inverse_LU(iszerofunc=_iszero)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.inverse_CH","title":"<code>inverse_CH(iszerofunc=_iszero)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.inverse_LDL","title":"<code>inverse_LDL(iszerofunc=_iszero)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.inverse_QR","title":"<code>inverse_QR(iszerofunc=_iszero)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.inv","title":"<code>inv(method=None, iszerofunc=_iszero, try_block_diag=False)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.connected_components","title":"<code>connected_components()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.connected_components_decomposition","title":"<code>connected_components_decomposition()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.strongly_connected_components","title":"<code>strongly_connected_components()</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.strongly_connected_components_decomposition","title":"<code>strongly_connected_components_decomposition(lower=True)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.to_DM","title":"<code>to_DM(domain=None, **kwargs)</code>","text":"<p>Convert to a :class:<code>~.DomainMatrix</code>.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.to_DM--examples","title":"Examples","text":"<p>from sympy import Matrix M = Matrix([[1, 2], [3, 4]]) M.to_DM() DomainMatrix({0: {0: 1, 1: 2}, 1: {0: 3, 1: 4}}, (2, 2), ZZ)</p> <p>The :meth:<code>DomainMatrix.to_Matrix</code> method can be used to convert back:</p> <p>M.to_DM().to_Matrix() == M True</p> <p>The domain can be given explicitly or otherwise it will be chosen by :func:<code>construct_domain</code>. Any keyword arguments (besides <code>domain</code>) are passed to :func:<code>construct_domain</code>:</p> <p>from sympy import QQ, symbols x = symbols('x') M = Matrix([[x, 1], [1, x]]) M Matrix([ [x, 1], [1, x]]) M.to_DM().domain ZZ[x] M.to_DM(field=True).domain ZZ(x) M.to_DM(domain=QQ[x]).domain QQ[x]</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.to_DM--see-also","title":"See Also","text":"<p>DomainMatrix DomainMatrix.to_Matrix DomainMatrix.convert_to DomainMatrix.choose_domain construct_domain</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix._unify_element_sympy","title":"<code>_unify_element_sympy(rep, element)</code>  <code>classmethod</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._dod_to_DomainMatrix","title":"<code>_dod_to_DomainMatrix(rows, cols, dod, types)</code>  <code>classmethod</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._flat_list_to_DomainMatrix","title":"<code>_flat_list_to_DomainMatrix(rows, cols, flat_list)</code>  <code>classmethod</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._smat_to_DomainMatrix","title":"<code>_smat_to_DomainMatrix(rows, cols, smat)</code>  <code>classmethod</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.equals","title":"<code>equals(other, failing_expression=False)</code>","text":"<p>Applies <code>equals</code> to corresponding elements of the matrices, trying to prove that the elements are equivalent, returning True if they are, False if any pair is not, and None (or the first failing expression if failing_expression is True) if it cannot be decided if the expressions are equivalent or not. This is, in general, an expensive operation.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.equals--examples","title":"Examples","text":"<p>from sympy import Matrix from sympy.abc import x A = Matrix([x(x - 1), 0]) B = Matrix([x*2 - x, 0]) A == B False A.simplify() == B.simplify() True A.equals(B) True A.equals(2) False</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.equals--see-also","title":"See Also","text":"<p>sympy.core.expr.Expr.equals</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.inv_mod","title":"<code>inv_mod(M, m)</code>","text":"<p>Returns the inverse of the integer matrix <code>M</code> modulo <code>m</code>.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.inv_mod--examples","title":"Examples","text":"<p>from sympy import Matrix A = Matrix(2, 2, [1, 2, 3, 4]) A.inv_mod(5) Matrix([ [3, 1], [4, 2]]) A.inv_mod(3) Matrix([ [1, 1], [0, 1]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.lll","title":"<code>lll(delta=0.75)</code>","text":"<p>LLL-reduced basis for the rowspace of a matrix of integers.</p> <p>Performs the Lenstra\u2013Lenstra\u2013Lov\u00e1sz (LLL) basis reduction algorithm.</p> <p>The implementation is provided by :class:<code>~DomainMatrix</code>. See :meth:<code>~DomainMatrix.lll</code> for more details.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.lll--examples","title":"Examples","text":"<p>from sympy import Matrix M = Matrix([[1, 0, 0, 0, -20160], ...             [0, 1, 0, 0, 33768], ...             [0, 0, 1, 0, 39578], ...             [0, 0, 0, 1, 47757]]) M.lll() Matrix([ [ 10, -3,  -2,  8,  -4], [  3, -9,   8,  1, -11], [ -3, 13,  -9, -3,  -9], [-12, -7, -11,  9,  -1]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.lll--see-also","title":"See Also","text":"<p>lll_transform sympy.polys.matrices.domainmatrix.DomainMatrix.lll</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.lll_transform","title":"<code>lll_transform(delta=0.75)</code>","text":"<p>LLL-reduced basis and transformation matrix.</p> <p>Performs the Lenstra\u2013Lenstra\u2013Lov\u00e1sz (LLL) basis reduction algorithm.</p> <p>The implementation is provided by :class:<code>~DomainMatrix</code>. See :meth:<code>~DomainMatrix.lll_transform</code> for more details.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.lll_transform--examples","title":"Examples","text":"<p>from sympy import Matrix M = Matrix([[1, 0, 0, 0, -20160], ...             [0, 1, 0, 0, 33768], ...             [0, 0, 1, 0, 39578], ...             [0, 0, 0, 1, 47757]]) B, T = M.lll_transform() B Matrix([ [ 10, -3,  -2,  8,  -4], [  3, -9,   8,  1, -11], [ -3, 13,  -9, -3,  -9], [-12, -7, -11,  9,  -1]]) T Matrix([ [ 10, -3,  -2,  8], [  3, -9,   8,  1], [ -3, 13,  -9, -3], [-12, -7, -11,  9]])</p> <p>The transformation matrix maps the original basis to the LLL-reduced basis:</p> <p>T * M == B True</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.lll_transform--see-also","title":"See Also","text":"<p>lll sympy.polys.matrices.domainmatrix.DomainMatrix.lll_transform</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.__new__","title":"<code>__new__(*args, **kwargs)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix._fromrep","title":"<code>_fromrep(rep)</code>  <code>classmethod</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.as_mutable","title":"<code>as_mutable()</code>","text":"<p>Returns a mutable version of this matrix</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.as_mutable--examples","title":"Examples","text":"<p>from sympy import ImmutableMatrix X = ImmutableMatrix([[1, 2], [3, 4]]) Y = X.as_mutable() Y[1, 1] = 5 # Can set values in Y Y Matrix([ [1, 2], [3, 5]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.__setitem__","title":"<code>__setitem__(key, value)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.__setitem__--examples","title":"Examples","text":"<p>from sympy import Matrix, I, zeros, ones m = Matrix(((1, 2+I), (3, 4))) m Matrix([ [1, 2 + I], [3,     4]]) m[1, 0] = 9 m Matrix([ [1, 2 + I], [9,     4]]) m[1, 0] = [[0, 1]]</p> <p>To replace row r you assign to position r*m where m is the number of columns:</p> <p>M = zeros(4) m = M.cols M[3m] = ones(1, m)2; M Matrix([ [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 2, 2, 2]])</p> <p>And to replace column c you can assign to position c:</p> <p>M[2] = ones(m, 1)*4; M Matrix([ [0, 0, 4, 0], [0, 0, 4, 0], [0, 0, 4, 0], [2, 2, 4, 2]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.col_op","title":"<code>col_op(j, f)</code>","text":"<p>In-place operation on col j using two-arg functor whose args are interpreted as (self[i, j], i).</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.col_op--examples","title":"Examples","text":"<p>from sympy import eye M = eye(3) M.col_op(1, lambda v, i: v + 2*M[i, 0]); M Matrix([ [1, 2, 0], [0, 1, 0], [0, 0, 1]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.col_op--see-also","title":"See Also","text":"<p>col row_op</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.col_swap","title":"<code>col_swap(i, j)</code>","text":"<p>Swap the two given columns of the matrix in-place.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.col_swap--examples","title":"Examples","text":"<p>from sympy import Matrix M = Matrix([[1, 0], [1, 0]]) M Matrix([ [1, 0], [1, 0]]) M.col_swap(0, 1) M Matrix([ [0, 1], [0, 1]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.col_swap--see-also","title":"See Also","text":"<p>col row_swap</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.row_op","title":"<code>row_op(i, f)</code>","text":"<p>In-place operation on row <code>i</code> using two-arg functor whose args are interpreted as <code>(self[i, j], j)</code>.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.row_op--examples","title":"Examples","text":"<p>from sympy import eye M = eye(3) M.row_op(1, lambda v, j: v + 2*M[0, j]); M Matrix([ [1, 0, 0], [2, 1, 0], [0, 0, 1]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.row_op--see-also","title":"See Also","text":"<p>row zip_row_op col_op</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.row_mult","title":"<code>row_mult(i, factor)</code>","text":"<p>Multiply the given row by the given factor in-place.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.row_mult--examples","title":"Examples","text":"<p>from sympy import eye M = eye(3) M.row_mult(1,7); M Matrix([ [1, 0, 0], [0, 7, 0], [0, 0, 1]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.row_add","title":"<code>row_add(s, t, k)</code>","text":"<p>Add k times row s (source) to row t (target) in place.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.row_add--examples","title":"Examples","text":"<p>from sympy import eye M = eye(3) M.row_add(0, 2,3); M Matrix([ [1, 0, 0], [0, 1, 0], [3, 0, 1]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.row_swap","title":"<code>row_swap(i, j)</code>","text":"<p>Swap the two given rows of the matrix in-place.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.row_swap--examples","title":"Examples","text":"<p>from sympy import Matrix M = Matrix([[0, 1], [1, 0]]) M Matrix([ [0, 1], [1, 0]]) M.row_swap(0, 1) M Matrix([ [1, 0], [0, 1]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.row_swap--see-also","title":"See Also","text":"<p>row col_swap</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.zip_row_op","title":"<code>zip_row_op(i, k, f)</code>","text":"<p>In-place operation on row <code>i</code> using two-arg functor whose args are interpreted as <code>(self[i, j], self[k, j])</code>.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.zip_row_op--examples","title":"Examples","text":"<p>from sympy import eye M = eye(3) M.zip_row_op(1, 0, lambda v, u: v + 2*u); M Matrix([ [1, 0, 0], [2, 1, 0], [0, 0, 1]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.zip_row_op--see-also","title":"See Also","text":"<p>row row_op col_op</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.copyin_list","title":"<code>copyin_list(key, value)</code>","text":"<p>Copy in elements from a list.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.copyin_list--parameters","title":"Parameters","text":"slice <p>The section of this matrix to replace.</p> <p>value : iterable     The iterable to copy values from.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.copyin_list--examples","title":"Examples","text":"<p>from sympy import eye I = eye(3) I[:2, 0] = [1, 2] # col I Matrix([ [1, 0, 0], [2, 1, 0], [0, 0, 1]]) I[1, :2] = [[3, 4]] I Matrix([ [1, 0, 0], [3, 4, 0], [0, 0, 1]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.copyin_list--see-also","title":"See Also","text":"<p>copyin_matrix</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.copyin_matrix","title":"<code>copyin_matrix(key, value)</code>","text":"<p>Copy in values from a matrix into the given bounds.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.copyin_matrix--parameters","title":"Parameters","text":"slice <p>The section of this matrix to replace.</p> <p>value : Matrix     The matrix to copy values from.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.copyin_matrix--examples","title":"Examples","text":"<p>from sympy import Matrix, eye M = Matrix([[0, 1], [2, 3], [4, 5]]) I = eye(3) I[:3, :2] = M I Matrix([ [0, 1, 0], [2, 3, 0], [4, 5, 1]]) I[0, 1] = M I Matrix([ [0, 0, 1], [2, 2, 3], [4, 4, 5]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.copyin_matrix--see-also","title":"See Also","text":"<p>copyin_list</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.fill","title":"<code>fill(value)</code>","text":"<p>Fill self with the given value.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.fill--notes","title":"Notes","text":"<p>Unless many values are going to be deleted (i.e. set to zero) this will create a matrix that is slower than a dense matrix in operations.</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.fill--examples","title":"Examples","text":"<p>from sympy import SparseMatrix M = SparseMatrix.zeros(3); M Matrix([ [0, 0, 0], [0, 0, 0], [0, 0, 0]]) M.fill(1); M Matrix([ [1, 1, 1], [1, 1, 1], [1, 1, 1]])</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix.fill--see-also","title":"See Also","text":"<p>zeros ones</p>"},{"location":"api/inherited/#ma1522.symbolic.Matrix._eval_inverse","title":"<code>_eval_inverse(**kwargs)</code>","text":""},{"location":"api/inherited/#ma1522.symbolic.Matrix.as_immutable","title":"<code>as_immutable()</code>","text":"<p>Returns an Immutable version of this Matrix</p>"},{"location":"api/symbolic/","title":"symbolic","text":""},{"location":"api/symbolic/#ma1522.symbolic.Matrix","title":"<code>ma1522.symbolic.Matrix(*args, aug_pos: Iterable[int] | int | None = None, **kwargs)</code>","text":"<p>               Bases: <code>MutableDenseMatrix</code></p> <p>A symbolic matrix class extending <code>MutableDenseMatrix</code> with enhanced linear algebra operations.</p> <p>The inherited methods from <code>MutableDenseMatrix</code> can be found in the SymPy Matrices Documentation. A summary of the inherited attributes and methods is also available on the Inherited Methods Summary page.</p> This class provides comprehensive linear algebra functionality with support for <ul> <li>Matrix creation from various sources (lists, \\(\\rm\\LaTeX\\), random values)</li> <li>Matrix decompositions (REF, RREF, LU, QR, SVD, diagonalization)</li> <li>Vector space operations (orthogonalization, projections, basis manipulation)</li> <li>Eigenvalue/eigenvector computations</li> <li>Custom printing and \\(\\rm\\LaTeX\\) formatting with augmented matrix support</li> </ul> Key Features <ul> <li>Maintains symbolic expressions throughout operations</li> <li>Follows MA1522 syllabus conventions for linear algebra</li> <li>Provides detailed step-by-step output for learning purposes</li> <li>Supports both exact symbolic and numerical computations</li> </ul> <p>Attributes:</p> <ul> <li> <code>_aug_pos</code>               (<code>set[int]</code>)           \u2013            <p>Set of column indices where augmentation lines should be drawn for displaying augmented matrices.</p> </li> </ul> <p>Examples:</p> <p>Basic matrix operations:</p> Python Console Session<pre><code>&gt;&gt;&gt; A = Matrix([[1, 2], [3, 4]])\n&gt;&gt;&gt; A.rref()\nRREF(rref=Matrix([\n[1, 0]\n[0, 1]\n]), pivots=(0, 1))\n</code></pre> <p>Creating from LaTeX:</p> Python Console Session<pre><code>&gt;&gt;&gt; B = Matrix.from_latex(r'\\begin{pmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\end{pmatrix}')\n\u23a11  2\u23a4\n\u23a2    \u23a5\n\u23a33  4\u23a6\n</code></pre> <p>Eigenvalue decomposition:</p> Python Console Session<pre><code>&gt;&gt;&gt; P, D = A.diagonalize(verbosity=0)\n&gt;&gt;&gt; P, D\n(Matrix([\n[-sqrt(33)/6 - 1/2, -1/2 + sqrt(33)/6]\n[                1,                 1]\n]), Matrix([\n[5/2 - sqrt(33)/2,                0]\n[               0, 5/2 + sqrt(33)/2]\n]))\n</code></pre> <p>Methods:</p> <ul> <li> <code>from_latex</code>             \u2013              <p>Converts a \\(\\rm\\LaTeX\\) matrix/vector expression into a Matrix object.</p> </li> <li> <code>from_str</code>             \u2013              <p>Parses a string representation of a matrix into a Matrix.</p> </li> <li> <code>from_list</code>             \u2013              <p>Creates a Matrix object from a list of vectors.</p> </li> <li> <code>create_unk_matrix</code>             \u2013              <p>Creates a symbolic matrix with unknown entries.</p> </li> <li> <code>create_rand_matrix</code>             \u2013              <p>Creates a matrix with random entries.</p> </li> <li> <code>copy</code>             \u2013              <p>Creates a copy of the matrix, preserving augmentation lines.</p> </li> <li> <code>subs</code>             \u2013              <p>Substitutes values in the matrix entries.</p> </li> <li> <code>simplify</code>             \u2013              <p>Simplifies the matrix by applying various simplification techniques.</p> </li> <li> <code>identify</code>             \u2013              <p>Identifies the matrix by applying a transformation function to each entry.</p> </li> <li> <code>select_cols</code>             \u2013              <p>Selects columns from the matrix based on the provided column indices.</p> </li> <li> <code>select_rows</code>             \u2013              <p>Selects rows from the matrix based on the provided row indices.</p> </li> <li> <code>sep_part_gen</code>             \u2013              <p>Separates a matrix into its particular and general solution parts.</p> </li> <li> <code>sep_unk</code>             \u2013              <p>Separates the matrix into matrices with each free symbol set to 1.</p> </li> <li> <code>scalar_factor</code>             \u2013              <p>Factorizes a matrix into the form \\(\\mathbf{A} = \\mathbf{FD}\\), where \\(\\mathbf{D}\\) is a diagonal matrix</p> </li> <li> <code>aug_line</code>             \u2013              <p>Inserts an augmented line at the specified position.</p> </li> <li> <code>rm_aug_line</code>             \u2013              <p>Remove an augmentation line from the matrix.</p> </li> <li> <code>row_join</code>             \u2013              <p>Joins two matrices horizontally (column-wise), preserving augmentation lines.</p> </li> <li> <code>col_join</code>             \u2013              <p>Joins two matrices vertically (row-wise), preserving augmentation lines.</p> </li> <li> <code>scale_row</code>             \u2013              <p>Scales a row of the matrix by a scalar and simplifies the result.</p> </li> <li> <code>swap_row</code>             \u2013              <p>Swaps two rows of the matrix.</p> </li> <li> <code>reduce_row</code>             \u2013              <p>Reduces a row by subtracting a scalar multiple of another row.</p> </li> <li> <code>get_pivot_row</code>             \u2013              <p>Finds the row index of the pivot element in a given column.</p> </li> <li> <code>get_pivot_pos</code>             \u2013              <p>Finds the positions of the pivot elements in the matrix.</p> </li> <li> <code>get_pivot_elements</code>             \u2013              <p>Retrieves the pivot elements from the matrix.</p> </li> <li> <code>ref</code>             \u2013              <p>Find the Row Echelon Form (REF) of the matrix.</p> </li> <li> <code>evaluate_cases</code>             \u2013              <p>Evaluates and displays all possible cases for solutions to a linear system involving the matrix.</p> </li> <li> <code>rref</code>             \u2013              <p>Computes the Reduced Row Echelon Form (RREF) of the matrix.</p> </li> <li> <code>solve</code>             \u2013              <p>Solves the linear system <code>Ax = rhs</code> for <code>x</code>.</p> </li> <li> <code>inverse</code>             \u2013              <p>Computes the left or right inverse of a matrix, depending on its rank and the specified option.</p> </li> <li> <code>elem</code>             \u2013              <p>Returns the identity matrix with the same number of rows as the current matrix.</p> </li> <li> <code>adjoint</code>             \u2013              <p>Computes the adjugate (classical adjoint) of the matrix.</p> </li> <li> <code>adj</code>             \u2013              <p>Alias for the <code>adjoint</code> method.</p> </li> <li> <code>cramer_solve</code>             \u2013              <p>Solves the linear system using Cramer's Rule.</p> </li> <li> <code>column_constraints</code>             \u2013              <p>Computes the column constraints for the matrix by appending a symbolic vector.</p> </li> <li> <code>normalized</code>             \u2013              <p>Normalizes the column vectors of the matrix (scaling each vector to have a unit norm).</p> </li> <li> <code>is_linearly_independent</code>             \u2013              <p>Determines if the vectors in the matrix are linearly independent.</p> </li> <li> <code>get_linearly_independent_vectors</code>             \u2013              <p>Returns a matrix containing the linearly independent vectors from the column space or row space.</p> </li> <li> <code>simplify_basis</code>             \u2013              <p>Returns a simplified basis for the column space or row space of the matrix.</p> </li> <li> <code>extend_basis</code>             \u2013              <p>Extends the matrix to form a basis for the span of the given subspace.</p> </li> <li> <code>intersect_subspace</code>             \u2013              <p>Computes the intersection of two subspaces by finding the nullspace of their orthogonal complements.</p> </li> <li> <code>is_subspace_of</code>             \u2013              <p>Checks if the current matrix is a subspace of another matrix.</p> </li> <li> <code>is_same_subspace</code>             \u2013              <p>Checks if two subspaces are the same by verifying if each subspace is a subspace of the other.</p> </li> <li> <code>coords_relative</code>             \u2013              <p>Computes the coordinates of the current vector relative to a given basis.</p> </li> <li> <code>transition_matrix</code>             \u2013              <p>Computes the transition matrix that transforms this matrix to another matrix.</p> </li> <li> <code>nullspace</code>             \u2013              <p>Computes the null space (kernel) of the matrix, i.e., the set of vectors that satisfy <code>self @ x = 0</code>.</p> </li> <li> <code>nullity</code>             \u2013              <p>Computes the nullity of the matrix, which is the dimension of its null space.</p> </li> <li> <code>orthogonal_complement</code>             \u2013              <p>Computes the orthogonal complement of the matrix (the null space of its transpose).</p> </li> <li> <code>is_vec_orthogonal</code>             \u2013              <p>Checks if the column vectors of the matrix are orthogonal to each other.</p> </li> <li> <code>is_mat_orthogonal</code>             \u2013              <p>Checks if the matrix is orthogonal (i.e., its columns are orthonormal).</p> </li> <li> <code>orthogonal_decomposition</code>             \u2013              <p>Decomposes the current vector (or matrix) into its orthogonal projection onto a subspace and its orthogonal complement.</p> </li> <li> <code>proj_comp</code>             \u2013              <p>Computes the orthogonal projection of the current vector (or matrix) onto the subspace spanned by the columns of another matrix.</p> </li> <li> <code>norm_comp</code>             \u2013              <p>Computes the component of the current vector (or matrix) orthogonal to the subspace spanned by the columns of another matrix.</p> </li> <li> <code>gram_schmidt</code>             \u2013              <p>Performs Gram-Schmidt orthogonalization to convert a set of vectors (columns of the matrix) into</p> </li> <li> <code>QRdecomposition</code>             \u2013              <p>Computes the QR decomposition of the matrix. Optionally computes the full QR decomposition.</p> </li> <li> <code>solve_least_squares</code>             \u2013              <p>Solves the least squares problem \\(\\min || \\mathrm{self} \\, \\mathbf{x} - \\mathrm{rhs}||^2\\).</p> </li> <li> <code>create_vander</code>             \u2013              <p>Creates a Vandermonde matrix with symbolic entries.</p> </li> <li> <code>apply_vander</code>             \u2013              <p>Applies a Vandermonde transformation to the current matrix using the given vector.</p> </li> <li> <code>cpoly</code>             \u2013              <p>Computes the characteristic polynomial of the matrix and attempts to factor it into real and complex parts.</p> </li> <li> <code>is_diagonalizable</code>             \u2013              <p>Checks if the matrix is diagonalizable, with the option to focus only on real eigenvalues.</p> </li> <li> <code>eigenvects_associated</code>             \u2013              <p>Computes the eigenvectors associated with a given eigenvalue.</p> </li> <li> <code>diagonalize</code>             \u2013              <p>Diagonalizes the matrix if possible, focusing on real eigenvalues unless specified otherwise.</p> </li> <li> <code>is_orthogonally_diagonalizable</code>             \u2013              <p>Determines whether the matrix is orthogonally diagonalizable.</p> </li> <li> <code>orthogonally_diagonalize</code>             \u2013              <p>Orthogonally diagonalizes the matrix, ensuring that eigenvectors corresponding to different eigenvalues are orthogonal.</p> </li> <li> <code>is_stochastic</code>             \u2013              <p>Checks if the matrix is stochastic.</p> </li> <li> <code>equilibrium_vectors</code>             \u2013              <p>Computes the equilibrium vectors of the matrix, i.e., the nullspace of (I - A).</p> </li> <li> <code>singular_value_decomposition</code>             \u2013              <p>Performs Singular Value Decomposition (SVD) on the matrix, following the MA1522 syllabus.</p> </li> <li> <code>fast_svd</code>             \u2013              <p>A faster version of SVD that computes numerically using NumPy's SVD function.</p> </li> <li> <code>standard_matrix</code>             \u2013              <p>Returns the standard matrix for the transformation from self to out.</p> </li> </ul> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def __init__(\n    self,\n    *args,\n    aug_pos: Iterable[int] | int | None = None,\n    **kwargs,\n) -&gt; None:\n    if aug_pos is None:\n        self._aug_pos = set()\n    elif isinstance(aug_pos, int):\n        self._aug_pos = set([aug_pos])\n    elif isinstance(aug_pos, Iterable) and all(isinstance(i, int) for i in aug_pos):\n        self._aug_pos = set(aug_pos)\n    else:\n        raise TypeError(\n            f\"Invalid type for aug_pos: {type(aug_pos)}. Expected Iterable[int].\"\n        )\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.from_latex","title":"<code>from_latex(expr: str, verbosity: int = 1, row_join: bool = True, norm: bool = False, aug_pos: Iterable[int] | int | None = None) -&gt; Matrix</code>  <code>staticmethod</code>","text":"<p>Converts a \\(\\rm\\LaTeX\\) matrix/vector expression into a Matrix object.</p> <p>Parses \\(\\rm\\LaTeX\\) matrix environments (pmatrix, array) and vector lists into a Matrix. Handles matrix multiplication expressions and normalizes vectors when requested.</p> <p>Parameters:</p> <ul> <li> <code>expr</code>               (<code>str</code>)           \u2013            <p>\\(\\rm\\LaTeX\\) string containing:</p> <ul> <li>Matrix environments:     <code>\\begin{pmatrix} ... \\end{pmatrix}</code>, <code>\\begin{array}{ccc} ... \\end{array}</code></li> <li>Vector lists:     <code>\\{ \\begin{pmatrix} ... \\end{pmatrix}, \\begin{pmatrix} ... \\end{pmatrix}\\}</code></li> <li>Matrix products:     <code>\\begin{pmatrix}...\\end{pmatrix}\\begin{pmatrix} ... \\end{pmatrix}</code></li> </ul> </li> <li> <code>verbosity</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Controls output detail level: - 0: No output - 1: Display parsed matrix</p> </li> <li> <code>row_join</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, vector lists are treated as columns. If False, vectors are treated as rows.</p> </li> <li> <code>norm</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, normalizes vectors to unit length.</p> </li> <li> <code>aug_pos</code>               (<code>Iterable[int] | int | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, specifies the column indices where augmentation lines should be drawn in the output matrix. This is useful for displaying augmented matrices in a visually clear manner. If <code>None</code>, no augmentation lines are drawn.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>The parsed matrix with optional normalization.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>If the \\(\\rm\\LaTeX\\) expression is empty, invalid or cannot be parsed.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; Matrix.from_latex(r'\\begin{pmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\end{pmatrix}', verbosity=0)\nMatrix([\n[1, 2]\n[3, 4]\n])\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; Matrix.from_latex(r'\\begin{pmatrix} 1 \\\\ 2 \\\\ 3 \\end{pmatrix}', verbosity=0, norm=True)\nMatrix([\n[  sqrt(14)/14]\n[   sqrt(14)/7]\n[3*sqrt(14)/14]\n])\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>@staticmethod\ndef from_latex(\n    expr: str,\n    verbosity: int = 1,\n    row_join: bool = True,\n    norm: bool = False,\n    aug_pos: Iterable[int] | int | None = None,\n) -&gt; Matrix:\n    r\"\"\"Converts a $\\rm\\LaTeX$ matrix/vector expression into a Matrix object.\n\n    Parses $\\rm\\LaTeX$ matrix environments (pmatrix, array) and vector lists into a Matrix.\n    Handles matrix multiplication expressions and normalizes vectors when requested.\n\n    Args:\n        expr (str): $\\rm\\LaTeX$ string containing:\n\n            - Matrix environments:\n                `\\begin{pmatrix} ... \\end{pmatrix}`, `\\begin{array}{ccc} ... \\end{array}`\n            - Vector lists:\n                `\\{ \\begin{pmatrix} ... \\end{pmatrix}, \\begin{pmatrix} ... \\end{pmatrix}\\}`\n            - Matrix products:\n                `\\begin{pmatrix}...\\end{pmatrix}\\begin{pmatrix} ... \\end{pmatrix}`\n\n        verbosity (int): Controls output detail level:\n            - 0: No output\n            - 1: Display parsed matrix\n\n        row_join (bool): If True, vector lists are treated as columns.\n            If False, vectors are treated as rows.\n\n        norm (bool): If True, normalizes vectors to unit length.\n\n        aug_pos (Iterable[int] | int | None): If provided, specifies the column indices\n            where augmentation lines should be drawn in the output matrix. This is useful for displaying\n            augmented matrices in a visually clear manner. If `None`, no augmentation lines are drawn.\n\n    Returns:\n        (Matrix): The parsed matrix with optional normalization.\n\n    Raises:\n        Exception: If the $\\rm\\LaTeX$ expression is empty, invalid or cannot be parsed.\n\n    Examples:\n        &gt;&gt;&gt; Matrix.from_latex(r'\\begin{pmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\end{pmatrix}', verbosity=0)\n        Matrix([\n        [1, 2]\n        [3, 4]\n        ])\n\n        &gt;&gt;&gt; Matrix.from_latex(r'\\begin{pmatrix} 1 \\\\ 2 \\\\ 3 \\end{pmatrix}', verbosity=0, norm=True)\n        Matrix([\n        [  sqrt(14)/14]\n        [   sqrt(14)/7]\n        [3*sqrt(14)/14]\n        ])\n    \"\"\"\n\n    # Step 1: Modify the LaTeX string to ensure compatibility with the parser.\n    # Convert array-like LaTeX to pmatrix for proper matrix formatting\n    # Replace \\begin{array}{ccc*} with \\begin{pmatrix}\n    modified_latex = re.sub(\n        r\"\\\\begin\\{array\\}(?:\\{[^}]*\\})?\", r\"\\\\begin{pmatrix}\", expr\n    )\n    # Replace \\end{array} with \\end{pmatrix}\n    modified_latex = re.sub(r\"\\\\end\\{array\\}\", r\"\\\\end{pmatrix}\", modified_latex)\n    # Remove LaTeX semicolon for cleaner parsing\n    modified_latex = re.sub(r\"\\\\;\", \"\", modified_latex)\n\n    # Step 2: Use latex2sympy to parse the modified LaTeX expression into SymPy Matrix\n    res = latex2sympy(modified_latex)\n    if verbosity &gt;= 1:\n        display(res)\n\n    # Step 3: Handle the parsed result based on its type (list, MatMul, or Matrix)\n    mat = Matrix()\n    if isinstance(res, list):\n        vector_list = []\n        for vector in res:\n            vector = vector.expand()\n            vector_list.append(vector)\n        mat = Matrix.from_list(vector_list, row_join)\n    elif isinstance(res, sym.MatMul):\n        # If the matrix is a product of matrices, evaluate the product directly\n        mat = Matrix(res.doit())\n    elif isinstance(res, sym.Matrix):\n        # Directly converts the SymPy Matrix into the custom Matrix object to inherit the custom methods\n        mat = Matrix(res)\n    else:\n        # If the result is neither a list nor a matrix expression, return the raw result\n        mat = res\n\n    if aug_pos is not None:\n        mat = Matrix(mat, aug_pos=aug_pos)\n\n    # Step 4: Normalisation\n    if norm and isinstance(mat, Matrix):\n        return mat.normalized(factor=False)  # type: ignore\n    return mat\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.from_str","title":"<code>from_str(matrix_str: str, row_sep: str = ';', col_sep: str = ' ', aug_pos: Iterable[int] | int | None = None, is_real: bool = True) -&gt; Matrix</code>  <code>staticmethod</code>","text":"<p>Parses a string representation of a matrix into a Matrix.</p> <p>This method enables quick creation of a Matrix object from a string format similar to the one used in MATLAB. It supports both row and column separators and uses SymPy's <code>parse_expr</code> to convert the entries of the matrix from a string format into a Matrix object.</p> <p>Parameters:</p> <ul> <li> <code>matrix_str</code>               (<code>str</code>)           \u2013            <p>The string representation of the matrix.</p> </li> <li> <code>row_sep</code>               (<code>str</code>, default:                   <code>';'</code> )           \u2013            <p>The separator for rows in the string.</p> </li> <li> <code>col_sep</code>               (<code>str</code>, default:                   <code>' '</code> )           \u2013            <p>The separator for columns in the string.</p> </li> <li> <code>aug_pos</code>               (<code>Iterable[int] | int | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, specifies the column indices where augmentation lines should be drawn in the output matrix. This is useful for displaying augmented matrices in a visually clear manner. If <code>None</code>, no augmentation lines are drawn.</p> </li> <li> <code>is_real</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the symbols in the matrix are considered real-valued. Otherwise, they are complex.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>A Matrix object representing the parsed matrix.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SyntaxError</code>             \u2013            <p>If the string cannot be parsed into a matrix.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; Matrix.from_str(\"[1 2; 3 4]\")\nMatrix([\n[1, 2]\n[3, 4]\n])\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>@staticmethod\ndef from_str(\n    matrix_str: str,\n    row_sep: str = \";\",\n    col_sep: str = \" \",\n    aug_pos: Iterable[int] | int | None = None,\n    is_real: bool = True,\n) -&gt; Matrix:\n    \"\"\"Parses a string representation of a matrix into a Matrix.\n\n    This method enables quick creation of a Matrix object from a string format similar to\n    the one used in MATLAB. It supports both row and column separators and\n    uses SymPy's [`parse_expr`][sympy.parsing.sympy_parser.parse_expr] to convert\n    the entries of the matrix from a string format into a Matrix object.\n\n    Args:\n        matrix_str (str): The string representation of the matrix.\n        row_sep (str, optional): The separator for rows in the string.\n        col_sep (str): The separator for columns in the string.\n        aug_pos (Iterable[int] | int | None, optional): If provided, specifies the column indices\n            where augmentation lines should be drawn in the output matrix. This is useful for displaying\n            augmented matrices in a visually clear manner. If `None`, no augmentation lines are drawn.\n        is_real (bool, optional): If True, the symbols in the matrix are considered real-valued. Otherwise, they are complex.\n\n    Returns:\n        (Matrix): A Matrix object representing the parsed matrix.\n\n    Raises:\n        SyntaxError: If the string cannot be parsed into a matrix.\n\n    Examples:\n        &gt;&gt;&gt; Matrix.from_str(\"[1 2; 3 4]\")\n        Matrix([\n        [1, 2]\n        [3, 4]\n        ])\n    \"\"\"\n\n    matrix_str = (\n        matrix_str.strip().removeprefix(\"[\").removesuffix(\"]\")\n    )  # remove surrounding brackets\n    rows = matrix_str.strip().split(row_sep)\n    matrix = []\n    for row in rows:\n        cols = row.strip().split(col_sep)\n        matrix.append([parse_expr(col.strip()) for col in cols])\n\n    if aug_pos is not None:\n        matrix = Matrix(matrix, aug_pos=aug_pos)\n    else:\n        matrix = Matrix(matrix)\n\n    symbols = matrix.free_symbols\n    new_symbols = _standardise_symbol(symbols, is_real=is_real)\n    matrix = matrix.subs({s: n for s, n in zip(symbols, new_symbols)})\n    return matrix\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.from_list","title":"<code>from_list(vectors: list[Matrix], row_join: bool = True, aug_pos: Iterable[int] | int | None = None) -&gt; Matrix</code>  <code>staticmethod</code>","text":"<p>Creates a Matrix object from a list of vectors.</p> <p>This method takes a list of vectors (each represented as a Matrix object) and combines them into a single matrix.</p> <p>Parameters:</p> <ul> <li> <code>vectors</code>               (<code>list[Matrix]</code>)           \u2013            <p>A list of Matrix objects, where each Matrix represents a row or column vector.</p> </li> <li> <code>row_join</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the vectors are joined horizontally. If False, the vectors are stacked vertically.</p> </li> <li> <code>aug_pos</code>               (<code>Iterable[int] | int | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, specifies the column indices where augmentation lines should be drawn in the output matrix. This is useful for displaying augmented matrices in a visually clear manner. If <code>None</code>, no augmentation lines are drawn.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>A matrix constructed from the list of vectors.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ShapeError</code>             \u2013            <p>If the vectors do not have compatible dimensions for joining.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; vec1 = Matrix([[1], [2]])\n&gt;&gt;&gt; vec2 = Matrix([[3], [4]])\n&gt;&gt;&gt; Matrix.from_list([vec1, vec2])\nMatrix([\n[1, 3]\n[2, 4]\n])\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; Matrix.from_list([vec1, vec2], row_join=False)\nMatrix([\n[1]\n[2]\n[3]\n[4]\n])\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>@staticmethod\ndef from_list(\n    vectors: list[Matrix],\n    row_join: bool = True,\n    aug_pos: Iterable[int] | int | None = None,\n) -&gt; Matrix:\n    \"\"\"Creates a Matrix object from a list of vectors.\n\n    This method takes a list of vectors (each represented as a Matrix object)\n    and combines them into a single matrix.\n\n    Args:\n        vectors (list[Matrix]): A list of Matrix objects, where each Matrix\n            represents a row or column vector.\n\n        row_join (bool, optional): If True, the vectors are joined horizontally.\n            If False, the vectors are stacked vertically.\n\n        aug_pos (Iterable[int] | int | None, optional): If provided, specifies the column indices\n            where augmentation lines should be drawn in the output matrix. This is useful for displaying\n            augmented matrices in a visually clear manner. If `None`, no augmentation lines are drawn.\n\n    Returns:\n        (Matrix): A matrix constructed from the list of vectors.\n\n    Raises:\n        sympy.matrices.exceptions.ShapeError: If the vectors do not have compatible dimensions for joining.\n\n    Examples:\n        &gt;&gt;&gt; vec1 = Matrix([[1], [2]])\n        &gt;&gt;&gt; vec2 = Matrix([[3], [4]])\n        &gt;&gt;&gt; Matrix.from_list([vec1, vec2])\n        Matrix([\n        [1, 3]\n        [2, 4]\n        ])\n\n        &gt;&gt;&gt; Matrix.from_list([vec1, vec2], row_join=False)\n        Matrix([\n        [1]\n        [2]\n        [3]\n        [4]\n        ])\n    \"\"\"\n    if not vectors:\n        return Matrix([])\n    res = Matrix(vectors.pop(0))\n    for vec in vectors:\n        if row_join:\n            res = res.row_join(vec, aug_line=False)\n        else:\n            res = res.col_join(vec)\n    if aug_pos is not None:\n        return Matrix(res, aug_pos=aug_pos)\n    return res\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.create_unk_matrix","title":"<code>create_unk_matrix(r: int = 1, c: int = 1, symbol: str | None = None, is_real: bool | None = True, shape: Shape | None = None) -&gt; Matrix</code>  <code>staticmethod</code>","text":"<p>Creates a symbolic matrix with unknown entries.</p> <p>This method generates a matrix of size \\(r \\times c\\) with symbolic entries. The entries are named based on the provided <code>symbol</code> parameter and indexed by their row and column positions. The <code>is_real</code> flag determines whether the symbols are real-valued.</p> Note <ul> <li>For a column vector without a specified symbol, the entries will be named     following conventions, i.e., \\(\\begin{pmatrix} x \\end{pmatrix}\\),     \\(\\begin{pmatrix} x \\\\ y \\end{pmatrix}\\),     \\(\\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix}\\), for 1, 2 and 3 rows respectively.</li> </ul> <p>Parameters:</p> <ul> <li> <code>r</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The number of rows in the matrix.</p> </li> <li> <code>c</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The number of columns in the matrix.</p> </li> <li> <code>symbol</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The base name for the symbols used in the matrix entries.</p> </li> <li> <code>is_real</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the symbols are real-valued. Otherwise, they are complex.</p> </li> <li> <code>shape</code>               (<code>Shape</code>, default:                   <code>None</code> )           \u2013            <p>If provided, the matrix will be reshaped to this specific shape. Supported shapes include:</p> <ul> <li>DIAGONAL: Returns a diagonal matrix.</li> <li>SCALAR: Returns a scalar matrix.</li> <li>UPPER: Returns an upper triangular matrix.</li> <li>LOWER: Returns a lower triangular matrix.</li> <li>STRICT_UPPER: Returns an upper triangular matrix without the diagonal.</li> <li>STRICT_LOWER: Returns a lower triangular matrix without the diagonal.</li> <li>SYMMETRIC: Returns a symmetric matrix.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>A matrix with symbolic entries of the specified size.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NonSquareMatrixError</code>             \u2013            <p>If <code>shape</code> is ill-defined on a non-square matrix.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; Matrix.create_unk_matrix(2, 2, symbol='a')\nMatrix([\n[a_1,1, a_1,2],\n[a_2,1, a_2,2]])\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; Matrix.create_unk_matrix(3, 1, symbol='y')\nMatrix([\n[y_1]\n[y_2]\n[y_3]\n])\n</code></pre> See Also <ul> <li><code>create_rand_matrix</code>: Creates a matrix with random entries.</li> </ul> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>@staticmethod\ndef create_unk_matrix(\n    r: int = 1,\n    c: int = 1,\n    symbol: str | None = None,\n    is_real: bool | None = True,\n    shape: Shape | None = None,\n) -&gt; Matrix:\n    r\"\"\"Creates a symbolic matrix with unknown entries.\n\n    This method generates a matrix of size $r \\times c$ with symbolic\n    entries. The entries are named based on the provided `symbol` parameter and\n    indexed by their row and column positions. The `is_real` flag determines whether\n    the symbols are real-valued.\n\n    Note:\n        - For a column vector without a specified symbol, the entries will be named\n            following conventions, i.e., $\\begin{pmatrix} x \\end{pmatrix}$,\n            $\\begin{pmatrix} x \\\\ y \\end{pmatrix}$,\n            $\\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix}$, for 1, 2 and 3 rows respectively.\n\n    Args:\n        r (int, optional): The number of rows in the matrix.\n        c (int, optional): The number of columns in the matrix.\n        symbol (str, optional): The base name for the symbols used in the matrix entries.\n        is_real (bool, optional): If True, the symbols are real-valued. Otherwise, they are complex.\n        shape (Shape, optional): If provided, the matrix will be reshaped to this\n            specific shape. Supported shapes include:\n\n            - [DIAGONAL][(p).Shape.DIAGONAL]: Returns a diagonal matrix.\n            - [SCALAR][(p).Shape.SCALAR]: Returns a scalar matrix.\n            - [UPPER][(p).Shape.UPPER]: Returns an upper triangular matrix.\n            - [LOWER][(p).Shape.LOWER]: Returns a lower triangular matrix.\n            - [STRICT_UPPER][(p).Shape.STRICT_UPPER]: Returns an upper triangular matrix without the diagonal.\n            - [STRICT_LOWER][(p).Shape.STRICT_LOWER]: Returns a lower triangular matrix without the diagonal.\n            - [SYMMETRIC][(p).Shape.SYMMETRIC]: Returns a symmetric matrix.\n\n    Returns:\n        (Matrix): A matrix with symbolic entries of the specified size.\n\n    Raises:\n        sympy.matrices.exceptions.NonSquareMatrixError: If `shape` is ill-defined on a non-square matrix.\n\n    Examples:\n        &gt;&gt;&gt; Matrix.create_unk_matrix(2, 2, symbol='a')\n        Matrix([\n        [a_1,1, a_1,2],\n        [a_2,1, a_2,2]])\n\n        &gt;&gt;&gt; Matrix.create_unk_matrix(3, 1, symbol='y')\n        Matrix([\n        [y_1]\n        [y_2]\n        [y_3]\n        ])\n\n    See Also:\n        - [`create_rand_matrix`][..]: Creates a matrix with random entries.\n    \"\"\"\n\n    # Create a vector of size rows with entries (x, y) or (..., y, z)\n    if r &lt;= 26 and c == 1 and symbol is None:\n        ls = []\n        match r:\n            case 1:\n                ls = list(\"x\")\n            case 2:\n                ls = list(\"xy\")\n            case 3:\n                ls = list(\"xyz\")\n            case _:\n                ascii_lowercase = list(\"abcdefghijklmnopqrstuvwxyz\")\n                ls = ascii_lowercase[26 - r :]\n        entries = sym.symbols(ls, real=is_real)\n        return Matrix(entries)\n\n    if symbol and c == 1:\n        entries = sym.symbols(f\"{symbol}_(1:{r + 1})\", real=is_real)\n        return Matrix(entries)\n\n    # Creates a matrix of size rows * cols with entries symbol_i,j\n    symbol = symbol or \"x\"  # default is \"x\"\n    entries = sym.symbols(f\"{symbol}_(1:{r + 1})\\\\,(1:{c + 1})\", real=is_real)\n\n    res = Matrix(entries).reshape(r, c)\n    if shape:\n        return res._shape(shape)\n    else:\n        return res\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.create_rand_matrix","title":"<code>create_rand_matrix(r: int = 1, c: int = 1, shape: Shape | None = None, *args, **kwargs) -&gt; Matrix</code>  <code>staticmethod</code>","text":"<p>Creates a matrix with random entries.</p> <p>This method generates a matrix of size \\(r \\times c\\) where the entries are real integers. The values in the matrix are generated using SymPy's <code>randMatrix</code> function.</p> Note <ul> <li>The entries in the matrix are generated randomly and will change each time     the function is called. Setting a random seed using <code>seed</code> in <code>**kwargs</code>     will ensure reproducibility of the random values.</li> </ul> <p>Parameters:</p> <ul> <li> <code>r</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The number of rows in the matrix.</p> </li> <li> <code>c</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The number of columns in the matrix.</p> </li> <li> <code>shape</code>               (<code>Shape</code>, default:                   <code>None</code> )           \u2013            <p>If provided, the matrix will be reshaped to this specific shape. Supported shapes include:</p> <ul> <li>DIAGONAL: Returns a diagonal matrix.</li> <li>SCALAR: Returns a scalar matrix.</li> <li>UPPER: Returns an upper triangular matrix.</li> <li>LOWER: Returns a lower triangular matrix.</li> <li>STRICT_UPPER: Returns an upper triangular matrix without the diagonal.</li> <li>STRICT_LOWER: Returns a lower triangular matrix without the diagonal.</li> <li>SYMMETRIC: Returns a symmetric matrix.</li> </ul> </li> <li> <code>*args</code>           \u2013            <p>Additional arguments passed to the <code>randMatrix</code> function.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional arguments passed to the <code>randMatrix</code> function.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>A Matrix with random entries of the specified size.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NonSquareMatrixError</code>             \u2013            <p>If <code>shape</code> is ill-defined on a non-square matrix.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; Matrix.create_rand_matrix(2, 3, seed=42)\nMatrix([\n[81, 14,  3]\n[94, 35, 31]\n])\n</code></pre> See Also <ul> <li><code>create_unk_matrix</code>: Creates a matrix with symbolic entries.</li> <li><code>randMatrix</code>: SymPy function to create a random matrix.</li> </ul> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>@staticmethod\ndef create_rand_matrix(\n    r: int = 1,\n    c: int = 1,\n    shape: Shape | None = None,\n    *args,\n    **kwargs,\n) -&gt; Matrix:\n    r\"\"\"Creates a matrix with random entries.\n\n    This method generates a matrix of size $r \\times c$ where the\n    entries are real integers. The values in the matrix are generated using SymPy's\n    [`randMatrix`][sympy.matrices.dense.randMatrix] function.\n\n    Note:\n        - The entries in the matrix are generated randomly and will change each time\n            the function is called. Setting a random seed using `seed` in `**kwargs`\n            will ensure reproducibility of the random values.\n\n    Args:\n        r (int, optional): The number of rows in the matrix.\n        c (int, optional): The number of columns in the matrix.\n        shape (Shape, optional): If provided, the matrix will be reshaped to this\n            specific shape. Supported shapes include:\n\n            - [DIAGONAL][(p).Shape.DIAGONAL]: Returns a diagonal matrix.\n            - [SCALAR][(p).Shape.SCALAR]: Returns a scalar matrix.\n            - [UPPER][(p).Shape.UPPER]: Returns an upper triangular matrix.\n            - [LOWER][(p).Shape.LOWER]: Returns a lower triangular matrix.\n            - [STRICT_UPPER][(p).Shape.STRICT_UPPER]: Returns an upper triangular matrix without the diagonal.\n            - [STRICT_LOWER][(p).Shape.STRICT_LOWER]: Returns a lower triangular matrix without the diagonal.\n            - [SYMMETRIC][(p).Shape.SYMMETRIC]: Returns a symmetric matrix.\n        *args: Additional arguments passed to the [`randMatrix`][sympy.matrices.dense.randMatrix]\n            function.\n        **kwargs: Additional arguments passed to the [`randMatrix`][sympy.matrices.dense.randMatrix]\n            function.\n\n    Returns:\n        (Matrix): A Matrix with random entries of the specified size.\n\n    Raises:\n        sympy.matrices.exceptions.NonSquareMatrixError: If `shape` is ill-defined on a non-square matrix.\n\n    Examples:\n        &gt;&gt;&gt; Matrix.create_rand_matrix(2, 3, seed=42)\n        Matrix([\n        [81, 14,  3]\n        [94, 35, 31]\n        ])\n\n    See Also:\n        - [`create_unk_matrix`][..]: Creates a matrix with symbolic entries.\n        - [`randMatrix`][sympy.matrices.dense.randMatrix]: SymPy function to create a random matrix.\n    \"\"\"\n    res = Matrix(sym.randMatrix(*args, r=r, c=c, **kwargs))\n    if shape:\n        return res._shape(shape)\n    else:\n        return res\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.copy","title":"<code>copy() -&gt; Matrix</code>","text":"<p>Creates a copy of the matrix, preserving augmentation lines.</p> <p>This method returns a new <code>Matrix</code> object that is a deep copy of the current matrix, including any augmentation line positions (used for displaying augmented matrices).</p> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>A new matrix object with the same entries and augmentation lines as the original.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 2], [3, 4]], aug_pos={1})\n&gt;&gt;&gt; mat_copy = mat.copy()\n&gt;&gt;&gt; mat_copy == mat\nTrue\n&gt;&gt;&gt; mat_copy is mat\nFalse\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def copy(self) -&gt; Matrix:\n    \"\"\"\n    Creates a copy of the matrix, preserving augmentation lines.\n\n    This method returns a new [`Matrix`][...] object that is a deep copy of the current matrix,\n    including any augmentation line positions (used for displaying augmented matrices).\n\n    Returns:\n        (Matrix): A new matrix object with the same entries and augmentation lines as the original.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[1, 2], [3, 4]], aug_pos={1})\n        &gt;&gt;&gt; mat_copy = mat.copy()\n        &gt;&gt;&gt; mat_copy == mat\n        True\n        &gt;&gt;&gt; mat_copy is mat\n        False\n    \"\"\"\n    new_mat = super().copy()\n    aug = self._aug_pos.copy() if hasattr(self, \"_aug_pos\") else set()\n    return Matrix(new_mat, aug_pos=aug)\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.subs","title":"<code>subs(*args, **kwargs) -&gt; Matrix</code>","text":"<p>Substitutes values in the matrix entries.</p> <p>This method overrides SymPy's <code>subs</code> method to ensure that the augmentation lines are preserved after substitution.</p> <p>Parameters:</p> <ul> <li> <code>*args</code>           \u2013            <p>Positional arguments for substitution.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Keyword arguments for substitution.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>A new matrix with substituted values, preserving augmentation lines.</p> </li> </ul> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def subs(self, *args, **kwargs) -&gt; Matrix:\n    \"\"\"Substitutes values in the matrix entries.\n\n    This method overrides SymPy's [`subs`][sympy.matrices.matrixbase.MatrixBase.subs]\n    method to ensure that the augmentation lines are preserved after substitution.\n\n    Args:\n        *args: Positional arguments for substitution.\n        **kwargs: Keyword arguments for substitution.\n\n    Returns:\n        (Matrix): A new matrix with substituted values, preserving augmentation lines.\n    \"\"\"\n    new_mat = super().subs(*args, **kwargs)\n    aug = self._aug_pos.copy() if hasattr(self, \"_aug_pos\") else set()\n    return Matrix(new_mat, aug_pos=aug)\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.simplify","title":"<code>simplify(rational: bool = True, suppress_warnings: bool = False, tolerance: float = 0.0001, simplify: bool = True, expand: bool = True, collect_sym: Symbol | None = None, *args, **kwargs) -&gt; None</code>","text":"<p>Simplifies the matrix by applying various simplification techniques.</p> This method performs several operations on the matrix to simplify its entries <ul> <li>Rational simplification.</li> <li>General symbolic simplification.</li> <li>Expansion or factoring of expressions.</li> <li>Collecting terms involving a specific symbol (if provided).</li> </ul> Note <ul> <li>Rational simplification attempts to convert entries into rational numbers if possible.     If there is a residue (e.g. attempting to convert a non-rational number into a rational),     a warning is printed with the approximation error.</li> <li>Expansion and factoring can be controlled by the <code>expand</code> parameter.</li> <li>The matrix is modified in place.</li> </ul> <p>Parameters:</p> <ul> <li> <code>rational</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, applies rational simplification to the matrix entries using <code>sym.nsimplify</code>.</p> </li> <li> <code>suppress_warnings</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, suppresses warnings about non-zero residues after rational simplification.</p> </li> <li> <code>tolerance</code>               (<code>float</code>, default:                   <code>0.0001</code> )           \u2013            <p>The tolerance for rational simplification.</p> </li> <li> <code>simplify</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, applies general symbolic simplification using <code>sym.simplify</code>.</p> </li> <li> <code>expand</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, applies expansion to the matrix entries. If False, applies factoring instead.</p> </li> <li> <code>collect_sym</code>               (<code>Symbol</code>, default:                   <code>None</code> )           \u2013            <p>A symbol to collect terms with. If provided, <code>sym.collect</code> will be applied to all entries of the matrix with respect to this symbol.</p> </li> <li> <code>*args</code>           \u2013            <p>Additional arguments passed to the <code>sym.simplify</code> function.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional arguments passed to the <code>sym.simplify</code> function.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>A new simplified matrix with the applied operations.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[sym.symbols('x') + 1, sym.symbols('x') + 2], [sym.symbols('x') + 3, sym.symbols('x') + 4]])\n&gt;&gt;&gt; mat.simplify(rational=False, expand=True)\n&gt;&gt;&gt; mat\nMatrix([\n[x + 1, x + 2]\n[x + 3, x + 4]\n])\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def simplify(\n    self,\n    rational: bool = True,\n    suppress_warnings: bool = False,\n    tolerance: float = 1e-4,\n    simplify: bool = True,\n    expand: bool = True,\n    collect_sym: Symbol | None = None,\n    *args,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Simplifies the matrix by applying various simplification techniques.\n\n    This method performs several operations on the matrix to simplify its entries:\n        - Rational simplification.\n        - General symbolic simplification.\n        - Expansion or factoring of expressions.\n        - Collecting terms involving a specific symbol (if provided).\n\n    Note:\n        - Rational simplification attempts to convert entries into rational numbers if possible.\n            If there is a residue (e.g. attempting to convert a non-rational number into a rational),\n            a warning is printed with the approximation error.\n        - Expansion and factoring can be controlled by the `expand` parameter.\n        - The matrix is modified in place.\n\n    Args:\n        rational (bool, optional): If True, applies rational simplification\n            to the matrix entries using [`sym.nsimplify`][sympy.simplify.simplify.nsimplify].\n        suppress_warnings (bool, optional): If True, suppresses warnings about non-zero residues\n            after rational simplification.\n        tolerance (float, optional): The tolerance for rational simplification.\n        simplify (bool, optional): If True, applies general symbolic simplification using [`sym.simplify`][sympy.simplify.simplify.simplify].\n        expand (bool, optional): If True, applies expansion to the matrix entries. If False, applies factoring instead.\n        collect_sym (Symbol, optional): A symbol to collect terms with. If provided,\n            [`sym.collect`][sympy.simplify.radsimp.collect] will be applied to all entries of the matrix with respect to this symbol.\n        *args: Additional arguments passed to the [`sym.simplify`][sympy.simplify.simplify.simplify] function.\n        **kwargs: Additional arguments passed to the [`sym.simplify`][sympy.simplify.simplify.simplify] function.\n\n    Returns:\n        (Matrix): A new simplified matrix with the applied operations.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[sym.symbols('x') + 1, sym.symbols('x') + 2], [sym.symbols('x') + 3, sym.symbols('x') + 4]])\n        &gt;&gt;&gt; mat.simplify(rational=False, expand=True)\n        &gt;&gt;&gt; mat\n        Matrix([\n        [x + 1, x + 2]\n        [x + 3, x + 4]\n        ])\n    \"\"\"\n\n    temp = self.copy()\n    if rational:\n        temp = sym.nsimplify(temp, tolerance=tolerance, rational=True)\n        residues = (temp - self).norm()\n        if residues != 0 and not suppress_warnings:\n            res = residues.evalf()\n            warn(\n                f\"\"\"\n                Non-zero Approximation Error: {res}\n                Rational approximation might have failed. Try lower tolerance.\"\"\",\n                RuntimeWarning,\n                stacklevel=2,\n            )\n    if simplify:\n        temp = sym.simplify(temp, *args, **kwargs)\n    if expand:\n        temp = sym.expand(temp)\n    else:\n        temp = temp.applyfunc(lambda x: sym.factor(x))\n    if collect_sym is not None:\n        temp = temp.applyfunc(lambda x: sym.collect(x, collect_sym))\n\n    # Create a new Matrix object from the simplified list and update the original object\n    aug = self._aug_pos.copy() if hasattr(self, \"_aug_pos\") else set()\n    temp = Matrix(temp, aug_pos=aug)  # prevent SymPy from losing _aug_pos\n    self.__dict__.update(temp.__dict__)\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.identify","title":"<code>identify(tol: float | None = None, suppress_warnings: bool = False, *args, **kwargs) -&gt; Matrix</code>","text":"<p>Identifies the matrix by applying a transformation function to each entry.</p> <p>This method applies a transformation to each element of the matrix using the <code>identify</code> function from the <code>mp</code> module. After identification, the method checks if there is any residue (i.e., if the matrix has been modified).</p> Note <ul> <li>If there is a residue (i.e., unable to identify an entry, such as \\(\\pi\\)),     a warning is printed with the approximation error. This can be resolved by     lowering <code>tolerance</code> or supplying appropriate <code>constants</code> as <code>**kwargs</code> to     the <code>identify</code> function.</li> </ul> <p>Parameters:</p> <ul> <li> <code>tol</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>A tolerance value that is passed to the <code>identify</code> function. If None, no tolerance is applied.</p> </li> <li> <code>suppress_warnings</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, suppresses warnings about non-zero residues after identification.</p> </li> <li> <code>*args</code>           \u2013            <p>Additional positional arguments passed to the <code>identify</code> function.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments passed to the <code>identify</code> function.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>A new matrix that results from applying the transformation to each element of the original matrix.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import math\n&gt;&gt;&gt; mat = Matrix([[math.sqrt(4), math.e], [1/math.sqrt(2), 0.0]])\n&gt;&gt;&gt; mat.identify()\nMatrix([\n[        2, E]\n[sqrt(2)/2, 0]\n])\n</code></pre> See Also <ul> <li><code>mpmath.identify</code>: The function used to identify   the entries of the matrix.</li> <li><code>simplify</code>:   For general simplification of the matrix entries.</li> </ul> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def identify(\n    self, tol: float | None = None, suppress_warnings: bool = False, *args, **kwargs\n) -&gt; Matrix:\n    r\"\"\"Identifies the matrix by applying a transformation function to each entry.\n\n    This method applies a transformation to each element of the matrix using\n    the [`identify`][mpmath.identify] function from the `mp` module. After identification,\n    the method checks if there is any residue (i.e., if the matrix has been modified).\n\n    Note:\n        - If there is a residue (i.e., unable to identify an entry, such as $\\pi$),\n            a warning is printed with the approximation error. This can be resolved by\n            lowering `tolerance` or supplying appropriate `constants` as `**kwargs` to\n            the `identify` function.\n\n    Args:\n        tol (float, optional): A tolerance value that is passed to the\n            [`identify`][mpmath.identify] function. If None, no tolerance is applied.\n        suppress_warnings (bool, optional): If True, suppresses warnings about non-zero residues\n            after identification.\n        *args: Additional positional arguments passed to the\n            [`identify`][mpmath.identify] function.\n        **kwargs: Additional keyword arguments passed to the\n            [`identify`][mpmath.identify] function.\n\n    Returns:\n        (Matrix): A new matrix that results from applying the transformation to\n            each element of the original matrix.\n\n    Examples:\n        &gt;&gt;&gt; import math\n        &gt;&gt;&gt; mat = Matrix([[math.sqrt(4), math.e], [1/math.sqrt(2), 0.0]])\n        &gt;&gt;&gt; mat.identify()\n        Matrix([\n        [        2, E]\n        [sqrt(2)/2, 0]\n        ])\n\n    See Also:\n        - [`mpmath.identify`][mpmath.identify]: The function used to identify\n          the entries of the matrix.\n        - [`simplify`][..simplify]:\n          For general simplification of the matrix entries.\n    \"\"\"\n\n    temp = self.applyfunc(lambda x: mp.identify(x, tol=tol, *args, **kwargs))\n    residues = (temp - self).norm()\n    if residues != 0 and not suppress_warnings:\n        res = residues.evalf()\n        warn(f\"Non-zero Identification Error: {res}\", RuntimeWarning, stacklevel=2)\n    return temp\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.select_cols","title":"<code>select_cols(*args: int) -&gt; Matrix</code>","text":"<p>Selects columns from the matrix based on the provided column indices.</p> <p>This method returns a new matrix consisting of the columns specified by the provided indices. The columns are selected from the original matrix, and the result is returned as a new matrix.</p> <p>Parameters:</p> <ul> <li> <code>*args</code>               (<code>int</code>, default:                   <code>()</code> )           \u2013            <p>One or more column indices (0-based) to select from the matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>A new matrix consisting of the selected columns.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 2, 3], [4, 5, 6]])\n&gt;&gt;&gt; mat.select_cols(0, 2)\nMatrix([\n[1, 3]\n[4, 6]\n])\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def select_cols(self, *args: int) -&gt; Matrix:\n    \"\"\"Selects columns from the matrix based on the provided column indices.\n\n    This method returns a new matrix consisting of the columns specified by the\n    provided indices. The columns are selected from the original matrix, and the\n    result is returned as a new matrix.\n\n    Args:\n        *args (int): One or more column indices (0-based) to select from the matrix.\n\n    Returns:\n        (Matrix): A new matrix consisting of the selected columns.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[1, 2, 3], [4, 5, 6]])\n        &gt;&gt;&gt; mat.select_cols(0, 2)\n        Matrix([\n        [1, 3]\n        [4, 6]\n        ])\n    \"\"\"\n\n    res = []\n    for idx in args:\n        res.append(list(self.col(idx)))\n    return Matrix(res).T\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.select_rows","title":"<code>select_rows(*args: int) -&gt; Matrix</code>","text":"<p>Selects rows from the matrix based on the provided row indices.</p> <p>This method returns a new matrix consisting of the rows specified by the provided indices. The rows are selected from the original matrix, and the result is returned as a new matrix.</p> <p>Parameters:</p> <ul> <li> <code>*args</code>               (<code>int</code>, default:                   <code>()</code> )           \u2013            <p>One or more row indices (0-based) to select from the matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>A new matrix consisting of the selected rows.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 2, 3], [4, 5, 6]])\n&gt;&gt;&gt; mat.select_rows(0)\nMatrix([[1, 2, 3]\n])\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def select_rows(self, *args: int) -&gt; Matrix:\n    \"\"\"Selects rows from the matrix based on the provided row indices.\n\n    This method returns a new matrix consisting of the rows specified by the\n    provided indices. The rows are selected from the original matrix, and the\n    result is returned as a new matrix.\n\n    Args:\n        *args (int): One or more row indices (0-based) to select from the matrix.\n\n    Returns:\n        (Matrix): A new matrix consisting of the selected rows.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[1, 2, 3], [4, 5, 6]])\n        &gt;&gt;&gt; mat.select_rows(0)\n        Matrix([[1, 2, 3]\n        ])\n    \"\"\"\n\n    res = []\n    for idx in args:\n        res.append(list(self.row(idx)))\n    return Matrix(res)\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.sep_part_gen","title":"<code>sep_part_gen() -&gt; PartGen</code>","text":"<p>Separates a matrix into its particular and general solution parts.</p> This method separates the matrix into two components <ul> <li>The particular solution, which is the solution to the system when     all free variables are set to zero.</li> <li>The general solution, which is the full solution including the     homogeneous part.</li> </ul> <p>It assumes that the matrix is in symbolic form and contains free variables that can be set to zero.</p> <p>Returns:</p> <ul> <li> <code>PartGen</code>           \u2013            <p>A dataclass containing two matrices:</p> <ul> <li><code>part_sol</code> (<code>Matrix</code>): The particular solution     (with free variables set to zero).</li> <li><code>gen_sol</code> (<code>Matrix</code>): The general solution (the original matrix     minus the particular solution).</li> </ul> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from sympy import symbols\n&gt;&gt;&gt; x = symbols('x')\n&gt;&gt;&gt; mat = Matrix([[x + 2, 3], [3*x, x - 2]])\n&gt;&gt;&gt; PG = mat.sep_part_gen()\n&gt;&gt;&gt; PG.part_sol # Particular solution\nMatrix([\n[2,  3]\n[0, -2]\n])\n&gt;&gt;&gt; PG.gen_sol # General solution\nMatrix([\n[  x, 0]\n[3*x, x]\n])\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def sep_part_gen(self) -&gt; PartGen:\n    \"\"\"\n    Separates a matrix into its particular and general solution parts.\n\n    This method separates the matrix into two components:\n        - The **particular solution**, which is the solution to the system when\n            all free variables are set to zero.\n        - The **general solution**, which is the full solution including the\n            homogeneous part.\n\n    It assumes that the matrix is in symbolic form and contains free variables that can be set to zero.\n\n    Returns:\n        (PartGen): A dataclass containing two matrices:\n\n            - `part_sol` ([`Matrix`][...]): The particular solution\n                (with free variables set to zero).\n            - `gen_sol` ([`Matrix`][...]): The general solution (the original matrix\n                minus the particular solution).\n\n    Examples:\n        &gt;&gt;&gt; from sympy import symbols\n        &gt;&gt;&gt; x = symbols('x')\n        &gt;&gt;&gt; mat = Matrix([[x + 2, 3], [3*x, x - 2]])\n        &gt;&gt;&gt; PG = mat.sep_part_gen()\n        &gt;&gt;&gt; PG.part_sol # Particular solution\n        Matrix([\n        [2,  3]\n        [0, -2]\n        ])\n        &gt;&gt;&gt; PG.gen_sol # General solution\n        Matrix([\n        [  x, 0]\n        [3*x, x]\n        ])\n    \"\"\"\n\n    set_0 = dict(((symbol, 0) for symbol in self.free_symbols))\n    part_sol = self.subs(set_0)\n    gen_sol = self - part_sol\n    return PartGen(part_sol, gen_sol)\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.sep_unk","title":"<code>sep_unk() -&gt; dict[Expr, Matrix]</code>","text":"<p>Separates the matrix into matrices with each free symbol set to 1.</p> <p>Returns:</p> <ul> <li> <code>dict[Expr, Matrix]</code>           \u2013            <p>Returns a dictionary where the sum of the key*value pairs reconstructs the original matrix. Each key is a free symbol, and each value is a matrix with that symbol set to 1 and all other free symbols set to 0.</p> </li> </ul> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def sep_unk(self) -&gt; dict[Expr, Matrix]:\n    \"\"\"Separates the matrix into matrices with each free symbol set to 1.\n\n    Returns:\n        (dict[Expr, Matrix]): Returns a dictionary where the sum of the key*value pairs\n            reconstructs the original matrix. Each key is a free symbol, and each value is a\n            matrix with that symbol set to 1 and all other free symbols set to 0.\n    \"\"\"\n    syms = self.free_symbols\n    res: dict[Expr, Matrix] = defaultdict(Matrix)\n    for s in syms:\n        sub = dict(((symbol, 0) for symbol in syms if symbol != sym))\n        sub[s] = 1  # type: ignore\n        res[s] = self.subs(sub)\n    return res\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.scalar_factor","title":"<code>scalar_factor(column: bool = True) -&gt; ScalarFactor</code>","text":"<p>Factorizes a matrix into the form \\(\\mathbf{A} = \\mathbf{FD}\\), where \\(\\mathbf{D}\\) is a diagonal matrix and \\(\\mathbf{F}\\) contains the vectors with common divisors factored out (if <code>column=True</code>). If <code>column=False</code>, then returns \\(\\mathbf{A} = \\mathbf{DF}\\) instead.</p> <p>Parameters:</p> <ul> <li> <code>column</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>True</code>, factorizes by columns. If <code>False</code>, factorizes by rows.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ScalarFactor</code>           \u2013            <p>A dataclass of two matrices (F, D) and order (FD or DF)</p> <ul> <li><code>diag</code> (<code>Matrix</code>): The diagonal matrix containing the common divisors.</li> <li><code>full</code> (<code>Matrix</code>): The matrix with common divisors factored out.</li> <li><code>order</code> (str): The order of the factorization, either \"FD\" (for column factorization) or \"DF\" (for row factorization).</li> </ul> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[6, 9], [12, 15]])\n&gt;&gt;&gt; SF = mat.scalar_factor(column=True)\n&gt;&gt;&gt; SF.full, SF.diag\n(Matrix([\n[1, 3]\n[2, 5]\n]), Matrix([\n[6, 0]\n[0, 3]\n]))\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def scalar_factor(self, column: bool = True) -&gt; ScalarFactor:\n    r\"\"\"Factorizes a matrix into the form $\\mathbf{A} = \\mathbf{FD}$, where $\\mathbf{D}$ is a diagonal matrix\n    and $\\mathbf{F}$ contains the vectors with common divisors factored out (if `column=True`). If `column=False`,\n    then returns $\\mathbf{A} = \\mathbf{DF}$ instead.\n\n    Args:\n        column (bool): If `True`, factorizes by columns. If `False`, factorizes by rows.\n\n    Returns:\n        (ScalarFactor): A dataclass of two matrices (F, D) and order (FD or DF)\n\n            - `diag` ([`Matrix`][...]): The diagonal matrix containing the common divisors.\n            - `full` ([`Matrix`][...]): The matrix with common divisors factored out.\n            - `order` (str): The order of the factorization, either \"FD\" (for column factorization) or \"DF\" (for row factorization).\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[6, 9], [12, 15]])\n        &gt;&gt;&gt; SF = mat.scalar_factor(column=True)\n        &gt;&gt;&gt; SF.full, SF.diag\n        (Matrix([\n        [1, 3]\n        [2, 5]\n        ]), Matrix([\n        [6, 0]\n        [0, 3]\n        ]))\n    \"\"\"\n\n    def prettify(scalar: Expr) -&gt; Expr:\n        num, den = sym.fraction(scalar)\n        if den == 1:\n            # return non-fractions as it is\n            return num\n        # for scalar in the form sqrt(x * k**2) / x, return k / sqrt(x)\n        # most notable case is sqrt(x) / x, which should return 1/sqrt(x)\n        k = sym.sqrt(num / sym.sqrt(den), evaluate=True)  # type: ignore\n        if k.is_integer:  # type: ignore\n            with sym.evaluate(False):\n                return k / sym.sqrt(den)  # type: ignore\n        else:\n            return scalar\n\n    scalars = []\n    F = self.copy()\n    if column:\n        for i in range(self.cols):\n            g = sym.gcd(tuple(self.col(i)))\n            F[:, i] /= g\n            scalars.append(prettify(g))\n        D = Matrix.diag(*scalars)\n        assert self == (F @ D).doit(), \"Matrix factorization failed.\"\n        return ScalarFactor(diag=D, full=F, order=\"FD\")\n    else:\n        for i in range(self.rows):\n            g = sym.gcd(tuple(self.row(i)))\n            F[i, :] /= g\n            scalars.append(prettify(g))\n        D = Matrix.diag(*scalars)\n        assert self == (D @ F).doit(), \"Matrix factorization failed.\"\n        return ScalarFactor(diag=D, full=F, order=\"DF\")\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.aug_line","title":"<code>aug_line(pos: int = -1) -&gt; Matrix</code>","text":"<p>Inserts an augmented line at the specified position.</p> <p>This method adds an augmented line (i.e., a visual vertical line) to the matrix at the specified column position. If no position is provided (default: -1), the line is inserted at the last column.</p> Note <ul> <li>The method updates the <code>_aug_pos</code> attribute to track the position of the inserted line.</li> <li>Negative <code>pos</code> will be converted before inserting it into <code>_aug_pos</code>.</li> </ul> <p>Parameters:</p> <ul> <li> <code>pos</code>               (<code>int</code>, default:                   <code>-1</code> )           \u2013            <p>The position (column index) where the augmented line will be inserted. Default -1 means the augmented line is added at the end of the matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>The current matrix with the augmented line added at the specified position.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>IndexError</code>             \u2013            <p>If the <code>pos</code> is out of range.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 2], [3, 4]])\n&gt;&gt;&gt; mat.aug_line(0)\nMatrix([\n[1 | 2]\n[3 | 4]\n])\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 2], [3, 4]])\n&gt;&gt;&gt; mat.aug_line().row_join(mat)\nMatrix([\n[1, 2 | 1, 2]\n[3, 4 | 3, 4]\n])\n</code></pre> See Also <ul> <li><code>rm_aug_line</code>: Removes an augmentation line from the matrix.</li> </ul> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def aug_line(self, pos: int = -1) -&gt; Matrix:\n    \"\"\"Inserts an augmented line at the specified position.\n\n    This method adds an augmented line (i.e., a visual vertical line)\n    to the matrix at the specified column position. If no position is provided (default: -1),\n    the line is inserted at the last column.\n\n    Note:\n        - The method updates the `_aug_pos` attribute to track the position of the inserted line.\n        - Negative `pos` will be converted before inserting it into `_aug_pos`.\n\n    Args:\n        pos (int, optional):\n            The position (column index) where the augmented line will be inserted.\n            Default -1 means the augmented line is added at the end of the matrix.\n\n    Returns:\n        (Matrix): The current matrix with the augmented line added at the specified position.\n\n    Raises:\n        IndexError: If the `pos` is out of range.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[1, 2], [3, 4]])\n        &gt;&gt;&gt; mat.aug_line(0)\n        Matrix([\n        [1 | 2]\n        [3 | 4]\n        ])\n\n        &gt;&gt;&gt; mat = Matrix([[1, 2], [3, 4]])\n        &gt;&gt;&gt; mat.aug_line().row_join(mat)\n        Matrix([\n        [1, 2 | 1, 2]\n        [3, 4 | 3, 4]\n        ])\n\n    See Also:\n        - [`rm_aug_line`][..]: Removes an augmentation line from the matrix.\n    \"\"\"\n\n    new_pos = pos\n    if new_pos &lt; 0:\n        new_pos += self.cols\n\n    if not 0 &lt;= new_pos &lt; self.cols:\n        raise IndexError(\n            f\"Position for augmented line ({pos}) out of range ({self.cols}).\"\n        )\n\n    if not hasattr(self, \"_aug_pos\"):\n        self._aug_pos: set[int] = set()\n    self._aug_pos.add(new_pos)\n    return self\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.rm_aug_line","title":"<code>rm_aug_line(pos: int | None = None) -&gt; Matrix</code>","text":"<p>Remove an augmentation line from the matrix.</p> <p>Removes the specified position from the matrix's augmentation line tracking. If the matrix has no augmentation lines tracked or the position is not currently marked as an augmentation line, the matrix remains unchanged.</p> Note <p>This method modifies the matrix's internal <code>_aug_pos</code> attribute which tracks augmentation line positions. If no <code>_aug_pos</code> attribute exists, it will be initialized as an empty set.</p> <p>Parameters:</p> <ul> <li> <code>pos</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The column position of the augmentation line to remove. If it is not set, all augmentation lines will be removed</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>The matrix instance (supports method chaining).</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 2], [3, 4]], aug_pos=0)\n&gt;&gt;&gt; mat.rm_aug_line(0)\nMatrix([\n[1, 2]\n[3, 4]\n])\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def rm_aug_line(self, pos: int | None = None) -&gt; Matrix:\n    \"\"\"Remove an augmentation line from the matrix.\n\n    Removes the specified position from the matrix's augmentation line tracking.\n    If the matrix has no augmentation lines tracked or the position is not\n    currently marked as an augmentation line, the matrix remains unchanged.\n\n    Note:\n        This method modifies the matrix's internal `_aug_pos` attribute which\n        tracks augmentation line positions. If no `_aug_pos` attribute exists,\n        it will be initialized as an empty set.\n\n    Args:\n        pos (int, optional): The column position of the augmentation line to remove.\n            If it is not set, all augmentation lines will be removed\n\n    Returns:\n        (Matrix): The matrix instance (supports method chaining).\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[1, 2], [3, 4]], aug_pos=0)\n        &gt;&gt;&gt; mat.rm_aug_line(0)\n        Matrix([\n        [1, 2]\n        [3, 4]\n        ])\n    \"\"\"\n    if not hasattr(self, \"_aug_pos\") or pos is None:\n        self._aug_pos = set()\n        return self\n    if pos in self._aug_pos:\n        self._aug_pos.remove(pos)\n    return self\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.row_join","title":"<code>row_join(other: Matrix, aug_line: bool = True) -&gt; Matrix</code>","text":"<p>Joins two matrices horizontally (column-wise), preserving augmentation lines.</p> <p>This method concatenates the columns of <code>self</code> and <code>other</code> to form a new matrix. Any augmentation lines (vertical lines for augmented matrices) tracked in either matrix are preserved and adjusted for the new column positions.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>Matrix</code>)           \u2013            <p>The matrix to join to the right of <code>self</code>.</p> </li> <li> <code>aug_line</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>True</code>, adds an augmentation line between the two matrices.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>A new matrix formed by joining <code>self</code> and <code>other</code> column-wise, with updated augmentation lines.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ShapeError</code>             \u2013            <p>If the number of rows in <code>self</code> and <code>other</code> do not match.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; A = Matrix([[1, 2], [3, 4]])\n&gt;&gt;&gt; B = Matrix([[5], [6]])\n&gt;&gt;&gt; A.row_join(B)\nMatrix([\n[1, 2 | 5]\n[3, 4 | 6]\n])\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def row_join(self, other: Matrix, aug_line: bool = True) -&gt; Matrix:\n    \"\"\"Joins two matrices horizontally (column-wise), preserving augmentation lines.\n\n    This method concatenates the columns of `self` and `other` to form a new matrix. Any augmentation lines\n    (vertical lines for augmented matrices) tracked in either matrix are preserved and adjusted for the new column positions.\n\n    Args:\n        other (Matrix): The matrix to join to the right of `self`.\n        aug_line (bool, optional): If `True`, adds an augmentation line between the two matrices.\n\n    Returns:\n        (Matrix): A new matrix formed by joining `self` and `other` column-wise, with updated augmentation lines.\n\n    Raises:\n        sympy.matrices.exceptions.ShapeError: If the number of rows in `self` and `other` do not match.\n\n    Examples:\n        &gt;&gt;&gt; A = Matrix([[1, 2], [3, 4]])\n        &gt;&gt;&gt; B = Matrix([[5], [6]])\n        &gt;&gt;&gt; A.row_join(B)\n        Matrix([\n        [1, 2 | 5]\n        [3, 4 | 6]\n        ])\n    \"\"\"\n    if not hasattr(self, \"_aug_pos\"):\n        self._aug_pos = set()\n    if not hasattr(other, \"_aug_pos\"):\n        other._aug_pos = set()\n\n    offset = self.cols\n    # Iterate over a copy of the set to prevent runtime errors\n    for pos in list(other._aug_pos):\n        self._aug_pos.add(pos + offset)\n    if aug_line:\n        self._aug_pos.add(offset - 1)\n    return Matrix(super().row_join(other), aug_pos=self._aug_pos)\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.col_join","title":"<code>col_join(other: Matrix) -&gt; Matrix</code>","text":"<p>Joins two matrices vertically (row-wise), preserving augmentation lines.</p> <p>This method concatenates the rows of <code>self</code> and <code>other</code> to form a new matrix. Only augmentation lines (vertical lines for augmented matrices) that are present in both matrices at the same column positions are preserved.</p> Note <ul> <li>Both <code>self</code> and <code>other</code> matrices should have the same number of columns for the join to be valid.</li> <li>The method updates the <code>_aug_pos</code> attribute to include only those positions that are common   in both matrices, ensuring that the augmentation lines are correctly aligned after the join.</li> </ul> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>Matrix</code>)           \u2013            <p>The matrix to join below <code>self</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>A new matrix formed by joining <code>self</code> and <code>other</code> row-wise, with preserved augmentation lines.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ShapeError</code>             \u2013            <p>If the number of columns in <code>self</code> and <code>other</code> do not match.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; A = Matrix([[1, 2]], aug_pos={0})\n&gt;&gt;&gt; B = Matrix([[3, 4]], aug_pos={0})\n&gt;&gt;&gt; A.col_join(B)\nMatrix([\n[1 | 2]\n[3 | 4]\n])\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def col_join(self, other: Matrix) -&gt; Matrix:\n    \"\"\"\n    Joins two matrices vertically (row-wise), preserving augmentation lines.\n\n    This method concatenates the rows of `self` and `other` to form a new matrix. Only augmentation lines\n    (vertical lines for augmented matrices) that are present in both matrices at the same column positions are preserved.\n\n    Note:\n        - Both `self` and `other` matrices should have the same number of columns for the join to be valid.\n        - The method updates the `_aug_pos` attribute to include only those positions that are common\n          in both matrices, ensuring that the augmentation lines are correctly aligned after the join.\n\n    Args:\n        other (Matrix): The matrix to join below `self`.\n\n    Returns:\n        (Matrix): A new matrix formed by joining `self` and `other` row-wise, with preserved augmentation lines.\n\n    Raises:\n        sympy.matrices.exceptions.ShapeError: If the number of columns in `self` and `other` do not match.\n\n    Examples:\n        &gt;&gt;&gt; A = Matrix([[1, 2]], aug_pos={0})\n        &gt;&gt;&gt; B = Matrix([[3, 4]], aug_pos={0})\n        &gt;&gt;&gt; A.col_join(B)\n        Matrix([\n        [1 | 2]\n        [3 | 4]\n        ])\n    \"\"\"\n    if not hasattr(self, \"_aug_pos\"):\n        self._aug_pos = set()\n    if not hasattr(other, \"_aug_pos\"):\n        other._aug_pos = set()\n\n    aug = self._aug_pos &amp; other._aug_pos\n    return Matrix(super().col_join(other), aug_pos=aug)\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.scale_row","title":"<code>scale_row(idx: int, scalar: Expr | float | int, verbosity: int = 2) -&gt; Matrix</code>","text":"<p>Scales a row of the matrix by a scalar and simplifies the result.</p> <p>This method scales a specified row of the matrix by multiplying it with a scalar and then simplifies the matrix. The result is stored back in the matrix. Optionally, the method can print information about the row scaling and display the matrix, depending on the verbosity level.</p> Note <ul> <li>The method modifies the matrix in-place and returns the updated matrix.</li> <li>After scaling the row, the matrix is simplified using <code>simplify</code>.</li> </ul> <p>Parameters:</p> <ul> <li> <code>idx</code>               (<code>int</code>)           \u2013            <p>The index of the row to scale (0-based).</p> </li> <li> <code>scalar</code>               (<code>(Expr, float, int)</code>)           \u2013            <p>The scalar by which to multiply the row.</p> </li> <li> <code>verbosity</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>The level of verbosity for output.</p> <ul> <li>0: No output.</li> <li>1: Print the row scaling operation.</li> <li>2: Print the row scaling operation and display the matrix.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>The modified matrix with the scaled row.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>IndexError</code>             \u2013            <p>If the <code>idx</code> is out of range for the number of rows in the matrix.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 2], [3, 4]])\n&gt;&gt;&gt; mat.scale_row(0, 2, verbosity=0)\nMatrix([\n[2, 4]\n[3, 4]\n])\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def scale_row(\n    self, idx: int, scalar: Expr | float | int, verbosity: int = 2\n) -&gt; Matrix:\n    \"\"\"\n    Scales a row of the matrix by a scalar and simplifies the result.\n\n    This method scales a specified row of the matrix by multiplying it with a scalar\n    and then simplifies the matrix. The result is stored back in the matrix. Optionally,\n    the method can print information about the row scaling and display the matrix,\n    depending on the verbosity level.\n\n    Note:\n        - The method modifies the matrix in-place and returns the updated matrix.\n        - After scaling the row, the matrix is simplified using [`simplify`][..].\n\n    Args:\n        idx (int): The index of the row to scale (0-based).\n        scalar (Expr, float, int): The scalar by which to multiply the row.\n        verbosity (int, optional): The level of verbosity for output.\n\n            - 0: No output.\n            - 1: Print the row scaling operation.\n            - 2: Print the row scaling operation and display the matrix.\n\n    Returns:\n        (Matrix): The modified matrix with the scaled row.\n\n    Raises:\n        IndexError: If the `idx` is out of range for the number of rows in the matrix.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[1, 2], [3, 4]])\n        &gt;&gt;&gt; mat.scale_row(0, 2, verbosity=0)\n        Matrix([\n        [2, 4]\n        [3, 4]\n        ])\n    \"\"\"\n\n    if scalar == 0:\n        warn(\"Matrix rows should not be scaled by 0\", UserWarning, stacklevel=2)\n\n    scalar = sym.sympify(scalar)\n    self[idx, :] *= scalar  # type: ignore\n    self.simplify(suppress_warnings=True)\n\n    if verbosity &gt;= 1:\n        display(\n            f\"\\\\left({sym.latex(scalar)}\\\\right) R_{idx + 1} \\\\rightarrow R_{idx + 1}\",\n            opt=\"math\",\n        )\n    if verbosity &gt;= 2:\n        display(self)\n        print(\"\\n\")\n\n    return self\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.swap_row","title":"<code>swap_row(idx_1: int, idx_2: int, verbosity: int = 2) -&gt; Matrix</code>","text":"<p>Swaps two rows of the matrix.</p> <p>This method swaps the contents of two rows in the matrix. The operation is performed in-place, and the modified matrix is returned. Optionally, the method can print information about the row swap and display the matrix, depending on the verbosity level.</p> Note <ul> <li>The method modifies the matrix in-place and returns the updated matrix.</li> <li>After performing the row swaps, the matrix is simplified using <code>simplify</code>.</li> </ul> <p>Parameters:</p> <ul> <li> <code>idx_1</code>               (<code>int</code>)           \u2013            <p>The index of the first row to swap (0-based).</p> </li> <li> <code>idx_2</code>               (<code>int</code>)           \u2013            <p>The index of the second row to swap (0-based).</p> </li> <li> <code>verbosity</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>The level of verbosity for output.</p> <ul> <li>0: No output.</li> <li>1: Print the row swap operation.</li> <li>2: Print the row swap operation and display the matrix.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>The modified matrix after the row swap.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>IndexError</code>             \u2013            <p>If the <code>idx_1</code> or <code>idx_2</code> is out of range for the number of rows in the matrix.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 2], [3, 4]])\n&gt;&gt;&gt; mat.swap_row(0, 1, verbosity=0)\nMatrix([\n[3, 4]\n[1, 2]\n])\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def swap_row(self, idx_1: int, idx_2: int, verbosity: int = 2) -&gt; Matrix:\n    \"\"\"Swaps two rows of the matrix.\n\n    This method swaps the contents of two rows in the matrix. The operation is performed\n    in-place, and the modified matrix is returned. Optionally, the method can print\n    information about the row swap and display the matrix, depending on the verbosity level.\n\n    Note:\n        - The method modifies the matrix in-place and returns the updated matrix.\n        - After performing the row swaps, the matrix is simplified using [`simplify`][..].\n\n    Args:\n        idx_1 (int): The index of the first row to swap (0-based).\n        idx_2 (int): The index of the second row to swap (0-based).\n        verbosity (int, optional): The level of verbosity for output.\n\n            - 0: No output.\n            - 1: Print the row swap operation.\n            - 2: Print the row swap operation and display the matrix.\n\n    Returns:\n        (Matrix): The modified matrix after the row swap.\n\n    Raises:\n        IndexError: If the `idx_1` or `idx_2` is out of range for the number of rows in the matrix.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[1, 2], [3, 4]])\n        &gt;&gt;&gt; mat.swap_row(0, 1, verbosity=0)\n        Matrix([\n        [3, 4]\n        [1, 2]\n        ])\n    \"\"\"\n\n    self[idx_1, :], self[idx_2, :] = self[idx_2, :], self[idx_1, :]\n\n    if verbosity &gt;= 1:\n        display(f\"R_{idx_1 + 1} \\\\leftrightarrow R_{idx_2 + 1}\", opt=\"math\")\n    if verbosity &gt;= 2:\n        display(self)\n        print(\"\\n\")\n\n    return self\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.reduce_row","title":"<code>reduce_row(idx_1: int, scalar: Expr | float | int, idx_2: int, verbosity: int = 2) -&gt; Matrix</code>","text":"<p>Reduces a row by subtracting a scalar multiple of another row.</p> <p>This method modifies a row by subtracting a specified scalar multiple of another row. The result is stored back in the matrix. Optionally, the method can print information about the row reduction and display the matrix, depending on the verbosity level.</p> Note <ul> <li>The method modifies the matrix in-place and returns the updated matrix.</li> <li>After performing the row reduction, the matrix is simplified using <code>simplify</code>.</li> </ul> <p>Parameters:</p> <ul> <li> <code>idx_1</code>               (<code>int</code>)           \u2013            <p>The index of the row to reduce (0-based).</p> </li> <li> <code>scalar</code>               (<code>(Expr, float, int)</code>)           \u2013            <p>The scalar by which to multiply the second row.</p> </li> <li> <code>idx_2</code>               (<code>int</code>)           \u2013            <p>The index of the row from which to subtract the scalar multiple (0-based).</p> </li> <li> <code>verbosity</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>The level of verbosity for output.</p> <ul> <li>0: No output.</li> <li>1: Print the row reduction operation.</li> <li>2: Print the row reduction operation and display the matrix.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>The modified matrix after the row reduction.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>IndexError</code>             \u2013            <p>If the <code>idx_1</code> or <code>idx_2</code> is out of range for the number of rows in the matrix.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 2], [3, 4]])\n&gt;&gt;&gt; mat.reduce_row(0, 2, 1, verbosity=0)\nMatrix([\n[-5, -6]\n[ 3,  4]\n])\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def reduce_row(\n    self, idx_1: int, scalar: Expr | float | int, idx_2: int, verbosity: int = 2\n) -&gt; Matrix:\n    \"\"\"Reduces a row by subtracting a scalar multiple of another row.\n\n    This method modifies a row by subtracting a specified scalar multiple of another row.\n    The result is stored back in the matrix. Optionally, the method can print information\n    about the row reduction and display the matrix, depending on the verbosity level.\n\n    Note:\n        - The method modifies the matrix in-place and returns the updated matrix.\n        - After performing the row reduction, the matrix is simplified using [`simplify`][..].\n\n    Args:\n        idx_1 (int): The index of the row to reduce (0-based).\n        scalar (Expr, float, int): The scalar by which to multiply the second row.\n        idx_2 (int): The index of the row from which to subtract the scalar multiple (0-based).\n        verbosity (int, optional): The level of verbosity for output.\n\n            - 0: No output.\n            - 1: Print the row reduction operation.\n            - 2: Print the row reduction operation and display the matrix.\n\n    Returns:\n        (Matrix): The modified matrix after the row reduction.\n\n    Raises:\n        IndexError: If the `idx_1` or `idx_2` is out of range for the number of rows in the matrix.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[1, 2], [3, 4]])\n        &gt;&gt;&gt; mat.reduce_row(0, 2, 1, verbosity=0)\n        Matrix([\n        [-5, -6]\n        [ 3,  4]\n        ])\n    \"\"\"\n\n    scalar = sym.sympify(scalar)\n    self[idx_1, :] = self[idx_1, :] - scalar * self[idx_2, :]  # type: ignore\n    self.simplify(suppress_warnings=True)\n\n    if verbosity &gt;= 1:\n        display(\n            f\"R_{idx_1 + 1} - \\\\left({sym.latex(scalar)}\\\\right)R_{idx_2 + 1} \\\\rightarrow R_{idx_1 + 1}\",\n            opt=\"math\",\n        )\n    if verbosity &gt;= 2:\n        display(self)\n        print(\"\\n\")\n\n    return self\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.get_pivot_row","title":"<code>get_pivot_row(col_idx: int, row_start_idx: int, follow_GE: bool = False) -&gt; int | None</code>","text":"<p>Finds the row index of the pivot element in a given column.</p> <p>This method attempts to find a row that contains a non-zero element in the specified column. If the <code>follow_GE</code> flag is <code>False</code>, it first looks for a non-zero constant that does not contain any symbolic expressions. If no such element is found, it will return the first non-zero element. If the entire column contains only zeros, the method returns -1.</p> <p>Parameters:</p> <ul> <li> <code>col_idx</code>               (<code>int</code>)           \u2013            <p>The index of the column to search for the pivot.</p> </li> <li> <code>row_start_idx</code>               (<code>int</code>)           \u2013            <p>The row index to start searching from.</p> </li> <li> <code>follow_GE</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to control whether to follow Gaussian elimination strategy.</p> <ul> <li><code>True</code>: Always return the first non-zero element, even if it is symbolic.</li> <li><code>False</code>: First look for non-zero constants that are not symbolic expressions.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The index of the row containing the pivot element, or None if no pivot is found.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 2, 3], [4, 5, 6], [0, 0, 0]])\n&gt;&gt;&gt; mat.get_pivot_row(0, 0)\n0\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def get_pivot_row(\n    self, col_idx: int, row_start_idx: int, follow_GE: bool = False\n) -&gt; int | None:\n    \"\"\"Finds the row index of the pivot element in a given column.\n\n    This method attempts to find a row that contains a non-zero element in the\n    specified column. If the `follow_GE` flag is `False`, it first looks for\n    a non-zero constant that does not contain any symbolic expressions. If no\n    such element is found, it will return the first non-zero element. If the\n    entire column contains only zeros, the method returns -1.\n\n    Args:\n        col_idx (int): The index of the column to search for the pivot.\n        row_start_idx (int): The row index to start searching from.\n        follow_GE (bool, optional): Flag to control whether to follow Gaussian elimination strategy.\n\n            - `True`: Always return the first non-zero element, even if it is symbolic.\n            - `False`: First look for non-zero constants that are not symbolic expressions.\n\n    Returns:\n        (int): The index of the row containing the pivot element, or None if no pivot is found.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[1, 2, 3], [4, 5, 6], [0, 0, 0]])\n        &gt;&gt;&gt; mat.get_pivot_row(0, 0)\n        0\n    \"\"\"\n\n    # Step 1: Search for a non-zero constant that is not symbolic (if not following Gaussian elimination)\n    # that it is easier to reduce other rows\n    if not follow_GE:\n        for row_idx in range(row_start_idx, self.rows):\n            term = self[row_idx, col_idx]\n            if term != 0:\n                # Check if it's not a symbolic expression\n                if not isinstance(term, Expr):\n                    return row_idx\n                # Check if it's a non-symbolic constant\n                elif len(term.free_symbols) == 0:\n                    return row_idx\n\n    # Step 2: If no non-zero constant is found, return the first non-zero element (symbolic or not)\n    for row_idx in range(row_start_idx, self.rows):\n        term = self[row_idx, col_idx]\n        if term != 0:\n            return row_idx\n\n    # Step 3: If no non-zero element is found, return None (indicating no pivot)\n    return None\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.get_pivot_pos","title":"<code>get_pivot_pos() -&gt; list[tuple[int, int]]</code>","text":"<p>Finds the positions of the pivot elements in the matrix.</p> <p>This method checks the matrix to determine the positions of the pivots (the first non-zero entry in each row) by examining each column one-by-one. It assumes that the matrix is in Row Echelon Form (REF), as checked by the <code>is_echelon</code> property.</p> <p>It uses <code>get_pivot_row</code> to find the pivot row for each column. For each pivot found, a tuple (row, column) is added to the result list.</p> <p>Returns:</p> <ul> <li> <code>list[tuple[int, int]]</code>           \u2013            <p>A list of lists, where each sublist contains a tuple representing the position (row, column) of a pivot.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 2, 3], [0, 0, 5], [0, 0, 0]])\n&gt;&gt;&gt; mat.get_pivot_pos()\n[(0, 0), (1, 2)]\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def get_pivot_pos(self) -&gt; list[tuple[int, int]]:\n    \"\"\"Finds the positions of the pivot elements in the matrix.\n\n    This method checks the matrix to determine the positions of the pivots\n    (the first non-zero entry in each row) by examining each column one-by-one.\n    It assumes that the matrix is in Row Echelon Form (REF), as checked by the\n    [`is_echelon`][sympy.matrices.matrixbase.MatrixBase.is_echelon] property.\n\n    It uses [`get_pivot_row`][..] to find the pivot row for each column.\n    For each pivot found, a tuple (row, column) is added to the result list.\n\n    Returns:\n        (list[tuple[int, int]]): A list of lists, where each sublist contains a\n            tuple representing the position (row, column) of a pivot.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[1, 2, 3], [0, 0, 5], [0, 0, 0]])\n        &gt;&gt;&gt; mat.get_pivot_pos()\n        [(0, 0), (1, 2)]\n    \"\"\"\n\n    assert self.is_echelon  # check for REF\n\n    pivot_pos: list[tuple[int, int]] = []\n    cur_row_pos = 0\n    for cur_col_pos in range(self.cols):\n        pivot_row = self.get_pivot_row(cur_col_pos, cur_row_pos, follow_GE=False)\n\n        if pivot_row is not None:\n            pivot_pos.append((pivot_row, cur_col_pos))\n            cur_row_pos += 1\n\n    return pivot_pos\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.get_pivot_elements","title":"<code>get_pivot_elements() -&gt; list[Expr]</code>","text":"<p>Retrieves the pivot elements from the matrix.</p> <p>This method identifies the pivot positions (row, column) using the <code>get_pivot_pos</code> method and then extracts the elements at those positions in the matrix.</p> <p>Returns:</p> <ul> <li> <code>list[Expr]</code>           \u2013            <p>A list of pivot elements corresponding to the positions identified by <code>get_pivot_pos</code>.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 2, 3], [0, 0, 5], [0, 0, 0]])\n&gt;&gt;&gt; mat.get_pivot_elements()\n[1, 5]\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def get_pivot_elements(self) -&gt; list[Expr]:\n    \"\"\"Retrieves the pivot elements from the matrix.\n\n    This method identifies the pivot positions (row, column) using the\n    [`get_pivot_pos`][..] method and\n    then extracts the elements at those positions in the matrix.\n\n    Returns:\n        (list[Expr]): A list of pivot elements corresponding\n            to the positions identified by [`get_pivot_pos`][..].\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[1, 2, 3], [0, 0, 5], [0, 0, 0]])\n        &gt;&gt;&gt; mat.get_pivot_elements()\n        [1, 5]\n    \"\"\"\n\n    pivot_elements: list[Expr] = []\n\n    for i, j in self.get_pivot_pos():\n        pivot_elements.append(self[i, j])  # type: ignore\n\n    return pivot_elements\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.ref","title":"<code>ref(verbosity: int = 2, max_tries: int = 2, follow_GE: bool = False) -&gt; PLU</code>","text":"<p>Find the Row Echelon Form (REF) of the matrix.</p> <p>This method applies Gaussian elimination (or a similar approach) to bring the matrix to row echelon form.</p> Note <ul> <li>PLU decomposition is the generalisation of the LU decomposition. Unlike     LU decomposition, PLU works for any matrix.</li> <li>The REF is obtained from <code>PLU.U</code> and the matrix is LU factorisable if <code>PLU.P</code>     is the identity matrix. -</li> </ul> <p>Parameters:</p> <ul> <li> <code>verbosity</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>Level of verbosity for the output.</p> <ul> <li>0: No output.</li> <li>1: Output basic information (e.g., row operations).</li> <li>2: Output detailed information (e.g., matrix states after each operation).</li> </ul> </li> <li> <code>max_tries</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>Maximum number of tries to reduce a row in case of symbolic denominators.</p> </li> <li> <code>follow_GE</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to strictly follow Gaussian elimination rules.</p> <ul> <li><code>True</code>: Always return the first non-zero element, even if it is symbolic.</li> <li><code>False</code>: First look for non-zero constants that are not symbolic expressions.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>PLU</code>           \u2013            <p>A dataclass containing the following matrices:</p> <ul> <li><code>P</code> (<code>Matrix</code>): The permutation matrix used during the transformation.</li> <li><code>L</code> (<code>Matrix</code>): The lower triangular matrix representing the multipliers used in the elimination process.</li> <li><code>U</code> (<code>Matrix</code>): The upper triangular matrix in row echelon form.</li> </ul> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n&gt;&gt;&gt; mat.ref(verbosity=0)\nPLU(P=Matrix([\n[1, 0, 0]\n[0, 1, 0]\n[0, 0, 1]\n]), L=Matrix([\n[1, 0, 0]\n[4, 1, 0]\n[7, 2, 1]\n]), U=Matrix([\n[1,  2,  3]\n[0, -3, -6]\n[0,  0,  0]\n]))\n</code></pre> See Also <ul> <li><code>Matrix.LUdecomposition</code></li> </ul> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def ref(\n    self,\n    verbosity: int = 2,\n    max_tries: int = 2,\n    follow_GE: bool = False,\n) -&gt; PLU:\n    \"\"\"Find the Row Echelon Form (REF) of the matrix.\n\n    This method applies Gaussian elimination (or a similar approach) to bring\n    the matrix to row echelon form.\n\n    Note:\n        - PLU decomposition is the generalisation of the LU decomposition. Unlike\n            LU decomposition, PLU works for any matrix.\n        - The REF is obtained from `PLU.U` and the matrix is LU factorisable if `PLU.P`\n            is the identity matrix.\n        -\n\n    Args:\n        verbosity (int, optional): Level of verbosity for the output.\n\n            - 0: No output.\n            - 1: Output basic information (e.g., row operations).\n            - 2: Output detailed information (e.g., matrix states after each operation).\n        max_tries (int, optional): Maximum number of tries to reduce a row in case of symbolic denominators.\n        follow_GE (bool, optional): Whether to strictly follow Gaussian elimination rules.\n\n            - `True`: Always return the first non-zero element, even if it is symbolic.\n            - `False`: First look for non-zero constants that are not symbolic expressions.\n\n    Returns:\n        (PLU): A dataclass containing the following matrices:\n\n            - `P` ([`Matrix`][...]): The permutation matrix used during the transformation.\n            - `L` ([`Matrix`][...]): The lower triangular matrix representing the multipliers used in the elimination process.\n            - `U` ([`Matrix`][...]): The upper triangular matrix in row echelon form.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        &gt;&gt;&gt; mat.ref(verbosity=0)\n        PLU(P=Matrix([\n        [1, 0, 0]\n        [0, 1, 0]\n        [0, 0, 1]\n        ]), L=Matrix([\n        [1, 0, 0]\n        [4, 1, 0]\n        [7, 2, 1]\n        ]), U=Matrix([\n        [1,  2,  3]\n        [0, -3, -6]\n        [0,  0,  0]\n        ]))\n\n    See Also:\n        - [`Matrix.LUdecomposition`][sympy.matrices.matrixbase.MatrixBase.LUdecomposition]\n    \"\"\"\n\n    U = self.copy()\n\n    I = self.elem()\n    L = self.elem()\n    P = self.elem()\n\n    # Loop over each column\n    cur_row_pos = 0\n\n    for cur_col_pos in range(self.cols):\n        # Find the first non-zero row in the current column\n        pivot_row = U.get_pivot_row(cur_col_pos, cur_row_pos, follow_GE)\n\n        if pivot_row is None:\n            # If no non-zero pivot is found, continue to the next column\n            continue\n\n        # Swap the current row with the pivot row if necessary\n        if pivot_row != cur_row_pos:\n            U.swap_row(cur_row_pos, pivot_row, verbosity=verbosity)\n            P_elem = I.copy().swap_row(cur_row_pos, pivot_row, verbosity=0)\n            P = P @ P_elem\n            L = P_elem @ L @ P_elem\n\n        # Eliminate the current column in rest of the rows below\n        for row_idx in range(cur_row_pos + 1, self.rows):\n            # reduce the row_idx iteratively via partial fractions to\n            # prevent division by a possible 0 term\n            tries = 0\n            while U[row_idx, cur_col_pos] != 0:\n                tries += 1\n                if tries &gt; max_tries:\n                    warn(\n                        f\"ERROR: Max tries exceeded to reduce row {row_idx + 1} with row {cur_row_pos + 1}\",\n                        RuntimeWarning,\n                        stacklevel=2,\n                    )\n                    break\n                try:\n                    scalar = U[row_idx, cur_col_pos] / U[cur_row_pos, cur_col_pos]  # type: ignore\n                    scalar = scalar.expand().simplify()\n\n                    try:\n                        decomp = sym.apart(scalar)  # partial fractions\n                    except Exception as e:\n                        decomp = scalar\n                    if isinstance(decomp, sym.Add):\n                        terms = decomp.args\n                    else:\n                        # there is only 1 term (could be integer or proper fraction)\n                        terms = [decomp]\n\n                    for term in terms:\n                        _, d = sym.fraction(term)\n\n                        # ensure denominator is non-zero so that reduction is valid\n                        if not _is_zero(d):\n                            U.reduce_row(\n                                row_idx,\n                                term,\n                                cur_row_pos,\n                                verbosity=verbosity,  # type: ignore\n                            )\n                            elem = I.copy().reduce_row(\n                                row_idx, -term, cur_row_pos, verbosity=0\n                            )  # type: ignore\n                            L = L @ elem\n\n                    # Cases where pivot row contains symbols such that scalar is a\n                    # fraction with symbolic denominator.\n                    # To reduce further, can only scale row_idx accordingly\n                    if U[row_idx, cur_col_pos] != 0:\n                        scalar = (\n                            U[cur_row_pos, cur_col_pos] / U[row_idx, cur_col_pos]\n                        )  # type: ignore\n                        tmp = scalar.simplify()\n                        if tmp is not None:\n                            scalar = tmp\n                        n, d = sym.fraction(scalar)\n                        # to scale by n, n cannot be 0 both numerically or symbolically\n                        # to scale by 1/d, d cannot be 0, same argument as n\n                        # if (n != 0) and (not _is_zero(d)):\n                        if (not _is_zero(n)) and (not _is_zero(d)):\n                            U.scale_row(row_idx, scalar, verbosity=verbosity)\n                            elem = I.copy().scale_row(\n                                row_idx, 1 / scalar, verbosity=0\n                            )\n                            L = L @ elem\n\n                except Exception as error:\n                    print(f\"Exception encountered: {error}\")\n                    return PLU(P, L, U)\n        cur_row_pos += 1\n\n    # Return the appropriate number of matrices based on the `matrices` parameter\n    return PLU(P, L, U)\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.evaluate_cases","title":"<code>evaluate_cases(rhs: Matrix | None = None, use_ref: bool = True) -&gt; None</code>","text":"<p>Evaluates and displays all possible cases for solutions to a linear system involving the matrix.</p> <p>This method analyzes the determinant of the matrix (or its Gram matrix if not square) to identify all possible cases for the values of free variables that affect the existence or uniqueness of solutions. For each case, it substitutes the corresponding values into the system and displays the resulting solution(s).</p> <p>Parameters:</p> <ul> <li> <code>rhs</code>               (<code>Matrix</code>, default:                   <code>None</code> )           \u2013            <p>The right-hand side matrix of the system. If not provided, it treats the system as homogeneous (i.e., <code>Ax = 0</code>).</p> </li> <li> <code>use_ref</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to use the row echelon form (REF) for case analysis. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; A = Matrix([[x, 1], [0, 1]])\n&gt;&gt;&gt; b = Matrix([[2], [3]])\n&gt;&gt;&gt; A.evaluate_cases(b)\nCase 1: {}, not including [{x: 0}]\nUnique solution\nRREF(rref=Matrix([\n    [x, 1 | 2]\n    [0, 1 | 3]\n]), pivots=(0, 1))\n</code></pre> <p>Case 2: {x: 0}, not including [] No solution RREF(rref=Matrix([     [0, 1 | 2]     [0, 0 | 1] ]), pivots=(1, 2))</p> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def evaluate_cases(self, rhs: Matrix | None = None, use_ref: bool = True) -&gt; None:\n    \"\"\"\n    Evaluates and displays all possible cases for solutions to a linear system involving the matrix.\n\n    This method analyzes the determinant of the matrix (or its Gram matrix if not square) to identify\n    all possible cases for the values of free variables that affect the existence or uniqueness of solutions.\n    For each case, it substitutes the corresponding values into the system and displays the resulting solution(s).\n\n    Args:\n        rhs (Matrix, optional): The right-hand side matrix of the system. If not provided, it treats the system\n            as homogeneous (i.e., `Ax = 0`).\n        use_ref (bool, optional): Whether to use the row echelon form (REF) for case analysis. Defaults to True.\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; A = Matrix([[x, 1], [0, 1]])\n        &gt;&gt;&gt; b = Matrix([[2], [3]])\n        &gt;&gt;&gt; A.evaluate_cases(b)\n        Case 1: {}, not including [{x: 0}]\n        Unique solution\n        RREF(rref=Matrix([\n            [x, 1 | 2]\n            [0, 1 | 3]\n        ]), pivots=(0, 1))\n\n\n        Case 2: {x: 0}, not including []\n        No solution\n        RREF(rref=Matrix([\n            [0, 1 | 2]\n            [0, 0 | 1]\n        ]), pivots=(1, 2))\n\n\n    \"\"\"\n    if rhs is None:\n        rhs = Matrix.zeros(self.rows, 1)\n    cases = self.find_all_cases()\n    all_possible_values = set(\n        possible_val for case in cases for possible_val in case.items()\n    )\n\n    for i, case in enumerate(cases, 1):\n        print(\n            f\"Case {i}: {case}, not including {[dict([val]) for val in all_possible_values.symmetric_difference(set(case.items()))]}\"\n        )\n        U = self.row_join(rhs, aug_line=True).subs(case)\n        if use_ref:\n            U = U.ref(verbosity=0, follow_GE=False).U\n            pivots = [pos[1] for pos in U.get_pivot_pos()]\n        else:\n            U, pivots = U.rref(pivots=True)\n        if self.cols in pivots:  # type: ignore\n            print(\"No solution\")\n        else:\n            free_params = self.cols - len(pivots)  # type: ignore\n            if free_params == 0:\n                print(\"Unique solution\")\n            else:\n                print(f\"Solution with {free_params} free parameters\")\n\n        display(RREF(U, tuple(pivots)))  # type: ignore\n        print(\"\\n\")\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.rref","title":"<code>rref(*args, pivots: bool = True, **kwargs) -&gt; RREF | Matrix</code>","text":"<p>Computes the Reduced Row Echelon Form (RREF) of the matrix.</p> <p>This method is a wrapper for <code>rref</code> method and returns the matrix in Reduced Row Echelon Form (RREF) along with the pivot positions.</p> <p>Parameters:</p> <ul> <li> <code>pivots</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>True</code>, returns a tuple containing the RREF matrix and a list of pivot columns</p> </li> <li> <code>*args</code>           \u2013            <p>Positional arguments passed to SymPy's <code>rref</code> method.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Keyword arguments passed to SymPy's <code>rref</code> method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RREF</code>           \u2013            <p>A dataclass containing the following:</p> <ul> <li><code>rref</code> (<code>Matrix</code>): The matrix in Reduced Row Echelon Form.</li> <li><code>pivots</code> (<code>list</code>[<code>int</code>]): A list of integers representing the indices of the pivot columns.</li> </ul> </li> <li> <code>Matrix</code>           \u2013            <p>If <code>pivots</code> is <code>False</code>, only the <code>rref</code> will be returned.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n&gt;&gt;&gt; mat.rref()\nRREF(rref=Matrix([\n[1, 0, -1]\n[0, 1,  2]\n[0, 0,  0]\n]), pivots=(0, 1))\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def rref(self, *args, pivots: bool = True, **kwargs) -&gt; RREF | Matrix:\n    \"\"\"Computes the Reduced Row Echelon Form (RREF) of the matrix.\n\n    This method is a wrapper for [`rref`][sympy.matrices.matrixbase.MatrixBase.rref] method\n    and returns the matrix in Reduced Row Echelon Form (RREF) along with the pivot positions.\n\n    Args:\n        pivots (bool, optional):\n            If `True`, returns a tuple containing the RREF matrix and a list of pivot columns\n        *args: Positional arguments passed to SymPy's [`rref`][sympy.matrices.matrixbase.MatrixBase.rref] method.\n        **kwargs: Keyword arguments passed to SymPy's [`rref`][sympy.matrices.matrixbase.MatrixBase.rref] method.\n\n    Returns:\n        (RREF): A dataclass containing the following:\n\n            - `rref` ([`Matrix`][...]): The matrix in Reduced Row Echelon Form.\n            - `pivots` ([`list`][list][[`int`][int]]): A list of integers representing the indices of the pivot columns.\n        (Matrix): If `pivots` is `False`, only the `rref` will be returned.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        &gt;&gt;&gt; mat.rref()\n        RREF(rref=Matrix([\n        [1, 0, -1]\n        [0, 1,  2]\n        [0, 0,  0]\n        ]), pivots=(0, 1))\n    \"\"\"\n    if pivots:\n        rref_mat, pivot_pos = super().rref(*args, **kwargs)\n    else:\n        rref_mat = super().rref(*args, pivots=False, **kwargs)\n\n    aug = self._aug_pos.copy() if hasattr(self, \"_aug_pos\") else set()\n    rref_mat = Matrix(rref_mat, aug_pos=aug)\n\n    if pivots:\n        return RREF(rref_mat, pivot_pos)\n    else:\n        return rref_mat\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.solve","title":"<code>solve(rhs: Matrix) -&gt; list[Matrix]</code>","text":"<p>Solves the linear system <code>Ax = rhs</code> for <code>x</code>.</p> <p>This method uses SymPy's <code>solve</code> method to find a solution vector <code>x</code> such that <code>self @ x = rhs</code>. A list of solution matrices is returned. If no solution exists (e.g., the system is inconsistent), a ValueError is raised.</p> <p>Parameters:</p> <ul> <li> <code>rhs</code>               (<code>Matrix</code>)           \u2013            <p>The right-hand side matrix or vector in the equation <code>Ax = rhs</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Matrix]</code>           \u2013            <p>A list of the solution vectors or matrices <code>x</code> that satisfies <code>Ax = rhs</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If no solution is found for the linear system, an exception is raised.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; A = Matrix([[1, 2], [3, 4]])\n&gt;&gt;&gt; b = Matrix([[5], [11]])\n&gt;&gt;&gt; A.solve(b)\n[Matrix([\n[1]\n[2]\n])]\n</code></pre> See Also <ul> <li><code>sympy.solve</code>: For solving equations in general.</li> <li><code>rref</code>: For finding the reduced row echelon form of the matrix.</li> <li><code>solve_least_squares</code>: For solving least squares problems.</li> </ul> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def solve(self, rhs: Matrix) -&gt; list[Matrix]:\n    \"\"\"Solves the linear system `Ax = rhs` for `x`.\n\n    This method uses SymPy's [`solve`][sympy.solvers.solvers.solve] method to find a solution vector `x` such that `self @ x = rhs`.\n    A list of solution matrices is returned.\n    If no solution exists (e.g., the system is inconsistent), a [ValueError][] is raised.\n\n    Args:\n        rhs (Matrix): The right-hand side matrix or vector in the equation `Ax = rhs`.\n\n    Returns:\n        (list[Matrix]): A list of the solution vectors or matrices `x` that satisfies `Ax = rhs`.\n\n    Raises:\n        ValueError: If no solution is found for the linear system, an exception is raised.\n\n    Examples:\n        &gt;&gt;&gt; A = Matrix([[1, 2], [3, 4]])\n        &gt;&gt;&gt; b = Matrix([[5], [11]])\n        &gt;&gt;&gt; A.solve(b)\n        [Matrix([\n        [1]\n        [2]\n        ])]\n\n    See Also:\n        - [`sympy.solve`][sympy.solvers.solvers.solve]: For solving equations in general.\n        - [`rref`][..]: For finding the reduced row echelon form of the matrix.\n        - [`solve_least_squares`][..]: For solving least squares problems.\n    \"\"\"\n    # Use sympy's solve function directly\n    x = Matrix.create_unk_matrix(r=self.cols, c=1)\n    solution = sym.solve(self @ x - rhs, x.free_symbols, dict=True)\n\n    if len(solution) == 0:\n        # If no solution is found (e.g., inconsistent system or empty list), raise an error\n        display(self.row_join(rhs, aug_line=True).rref())\n        raise ValueError(\n            \"No solution found for the linear system. The system may be inconsistent.\"\n        )\n    else:\n        return [x.subs(sol) for sol in solution]\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.inverse","title":"<code>inverse(option: Literal['left', 'right', 'both'] | None = None, matrices: int = 1, verbosity: int = 0) -&gt; Matrix | PartGen | None</code>","text":"<p>Computes the left or right inverse of a matrix, depending on its rank and the specified option.</p> The method checks whether the matrix has full row rank or full column rank and computes either <ul> <li>The left inverse (if the matrix has full column rank).</li> <li>The right inverse (if the matrix has full row rank).</li> </ul> <p>If neither option is provided, the method automatically determines which inverse to compute based on the matrix's rank.</p> <p>Parameters:</p> <ul> <li> <code>option</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Specifies which inverse to compute:</p> <ul> <li><code>'left'</code> for the left inverse (requires the matrix to have full column rank).</li> <li><code>'right'</code> for the right inverse (requires the matrix to have full row rank).</li> <li><code>'both'</code> for the inverse of a square matrix (works on both sides).</li> </ul> </li> <li> <code>matrices</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Specifies the number of matrices to return:</p> <ul> <li>1: Returns only the inverse matrix.</li> <li>2: Returns the particular and general solutions of the inverse.</li> </ul> </li> <li> <code>verbosity</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Level of verbosity for displaying intermediate steps:</p> <ul> <li>0: No output.</li> <li>1: Display matrices before and after RREF.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>If <code>matrices = 1</code>, returns the inverse matrix.</p> </li> <li> <code>PartGen</code>           \u2013            <p>If <code>matrices = 2</code>, returns a dataclass containing the particular and general solutions of the inverse.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If no valid inverse (left or right or both) is found, an exception is raised.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 2], [3, 4]])\n&gt;&gt;&gt; mat.inverse()\nMatrix([\n[ -2,    1]\n[3/2, -1/2]\n])\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def inverse(\n    self,\n    option: Literal[\"left\", \"right\", \"both\"] | None = None,\n    matrices: int = 1,\n    verbosity: int = 0,\n) -&gt; Matrix | PartGen | None:\n    \"\"\"Computes the left or right inverse of a matrix, depending on its rank and the specified option.\n\n    The method checks whether the matrix has full row rank or full column rank and computes either:\n        - The **left inverse** (if the matrix has full column rank).\n        - The **right inverse** (if the matrix has full row rank).\n\n    If neither option is provided, the method automatically determines which inverse to compute based on the matrix's rank.\n\n    Args:\n        option (str, optional): Specifies which inverse to compute:\n\n            - `'left'` for the left inverse (requires the matrix to have full column rank).\n            - `'right'` for the right inverse (requires the matrix to have full row rank).\n            - `'both'` for the inverse of a square matrix (works on both sides).\n\n        matrices (int, optional): Specifies the number of matrices to return:\n\n            - 1: Returns only the inverse matrix.\n            - 2: Returns the particular and general solutions of the inverse.\n\n        verbosity (int, optional): Level of verbosity for displaying intermediate steps:\n\n            - 0: No output.\n            - 1: Display matrices before and after RREF.\n\n    Returns:\n        (Matrix): If `matrices = 1`, returns the inverse matrix.\n        (PartGen): If `matrices = 2`, returns a dataclass containing the particular and general solutions of the inverse.\n\n    Raises:\n        ValueError: If no valid inverse (left or right or both) is found, an exception is raised.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[1, 2], [3, 4]])\n        &gt;&gt;&gt; mat.inverse()\n        Matrix([\n        [ -2,    1]\n        [3/2, -1/2]\n        ])\n    \"\"\"\n\n    if option is None:\n        rank = self.rank()\n        if rank == self.cols:\n            if verbosity:\n                print(\"Left inverse found!\")\n            option = \"left\"\n        if rank == self.rows:\n            if verbosity:\n                print(\"Right inverse found!\")\n            option = \"right\"\n            if self.rows == self.cols:\n                # square matrix inverse works on both sides\n                option = \"both\"\n        else:\n            raise ValueError(\n                f\"No inverse found! Rank: {rank}, Rows: {self.rows}, Columns: {self.cols}. Try pseudo-inverse: .pinv()\"\n            )\n\n    if option == \"both\" and self.rows != self.cols:\n        raise ValueError(\n            \"Cannot compute both left and right inverse for non-square matrices!\"\n        )\n\n    if (option is not None) and (verbosity &gt;= 1):\n        if option == \"left\":\n            aug = self.T.copy().row_join(\n                Matrix.eye(self.cols, aug_pos=range(self.cols))\n            )\n            print(\"Before RREF: [self^T | eye]\")\n            display(aug)\n            print(\"\\nAfter RREF:\")\n            display(aug.rref())\n        else:\n            aug = self.copy().row_join(\n                Matrix.eye(self.rows, aug_pos=range(self.rows))\n            )\n            print(\"Before RREF: [self | eye]\")\n            display(aug)\n            print(\"\\nAfter RREF:\")\n            display(aug.rref())\n\n    if option is not None:\n        X = Matrix.create_unk_matrix(r=self.cols, c=self.rows, symbol=\"x\")\n        if option == \"left\":\n            eqn = X @ self - sym.eye(self.cols)\n        else:\n            eqn = self @ X - sym.eye(self.rows)\n\n        sol = sym.solve(eqn, X.free_symbols)\n        if isinstance(sol, list) and len(sol) &gt; 0:\n            # Multiple sets of solutions found, picks the first 1\n            X = X.subs(sol[0])\n        elif isinstance(sol, dict):\n            X = X.subs(sol)\n        else:\n            raise ValueError(\n                f\"No {option} inverse found! Try pseudo-inverse: .pinv()\"\n            )\n\n        if matrices == 1:\n            return X\n        elif matrices == 2:\n            return X.sep_part_gen()\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.elem","title":"<code>elem() -&gt; Matrix</code>","text":"<p>Returns the identity matrix with the same number of rows as the current matrix.</p> <p>This method creates an identity matrix to be used for elementary row operations, i.e., <code>A = I A</code> where <code>I</code> is the identity matrix.</p> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>An identity matrix with the same number of rows as the current matrix.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 2], [3, 4], [5, 6]])\n&gt;&gt;&gt; mat.elem()\nMatrix([\n[1, 0, 0]\n[0, 1, 0]\n[0, 0, 1]\n])\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def elem(self) -&gt; Matrix:\n    \"\"\"Returns the identity matrix with the same number of rows as the current matrix.\n\n    This method creates an identity matrix to be used for elementary row operations,\n    i.e., `A = I A` where `I` is the identity matrix.\n\n    Returns:\n        (Matrix): An identity matrix with the same number of rows as the current matrix.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[1, 2], [3, 4], [5, 6]])\n        &gt;&gt;&gt; mat.elem()\n        Matrix([\n        [1, 0, 0]\n        [0, 1, 0]\n        [0, 0, 1]\n        ])\n    \"\"\"\n    return Matrix.eye(self.rows)\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.adjoint","title":"<code>adjoint() -&gt; Matrix</code>","text":"<p>Computes the adjugate (classical adjoint) of the matrix.</p> <p>This method calculates the classical adjoint (also known as the adjugate in literature) of the matrix. The adjoint of a matrix (as defined in MA1522 syllabus) is the transpose of its cofactor matrix.</p> Note <p>If you wish to compute the conjugate transpose of the matrix (SymPy's definition for adjoint), use <code>self.H</code> directly or <code>super(symbolic.Matrix, self).adjoint()</code> to call the parent method.</p> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>The classical adjoint (or adjugate) matrix of the current matrix.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 2], [3, 4]])\n&gt;&gt;&gt; mat.adjoint()\nMatrix([\n[ 4, -2],\n[-3,  1]])\n</code></pre> See Also <ul> <li>SymPy's <code>Matrix.adjugate</code></li> <li>SymPy's <code>Matrix.adjoint</code> for conjugate transpose.</li> </ul> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def adjoint(self) -&gt; Matrix:\n    \"\"\"Computes the adjugate (classical adjoint) of the matrix.\n\n    This method calculates the classical adjoint (also known as the [adjugate](https://en.wikipedia.org/wiki/Adjugate_matrix)\n    in literature) of the matrix. The adjoint of a matrix (as defined in MA1522 syllabus) is the transpose of its cofactor matrix.\n\n    Note:\n        If you wish to compute the conjugate transpose of the matrix (SymPy's definition for adjoint),\n        use `self.H` directly or `super(symbolic.Matrix, self).adjoint()` to call the parent method.\n\n    Returns:\n        (Matrix): The classical adjoint (or adjugate) matrix of the current matrix.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[1, 2], [3, 4]])\n        &gt;&gt;&gt; mat.adjoint()\n        Matrix([\n        [ 4, -2],\n        [-3,  1]])\n\n    See Also:\n        - SymPy's [`Matrix.adjugate`][sympy.matrices.matrixbase.MatrixBase.adjugate]\n        - SymPy's [`Matrix.adjoint`][sympy.matrices.matrixbase.MatrixBase.adjoint] for conjugate transpose.\n    \"\"\"\n    warn(\n        \"\"\"The classical adjoint of the matrix is computed rather than the conjugate transpose.\n        Please use self.adj() instead to remove ambiguity.\"\"\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    return self.adjugate()\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.adj","title":"<code>adj(method: Literal['bareiss', 'berkowitz', 'bird', 'laplace', 'lu'] = 'berkowitz') -&gt; Matrix</code>","text":"<p>Alias for the <code>adjoint</code> method.</p> <p>It returns the classical adjoint (or adjugate) of the matrix.</p> <p>Parameters:</p> <ul> <li> <code>method</code>               (<code>str</code>, default:                   <code>'berkowitz'</code> )           \u2013            <p>Method to use to find the cofactors, can be \"bareiss\", \"berkowitz\", \"bird\", \"laplace\" or \"lu\".</p> </li> </ul> <p>Returns:     (Matrix): The classical adjoint of the current matrix.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 2], [3, 4]])\n&gt;&gt;&gt; mat.adj()\nMatrix([\n[ 4, -2],\n[-3,  1]])\n</code></pre> See Also <ul> <li>SymPy's <code>adjugate</code></li> </ul> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def adj(\n    self,\n    method: Literal[\"bareiss\", \"berkowitz\", \"bird\", \"laplace\", \"lu\"] = \"berkowitz\",\n) -&gt; Matrix:\n    \"\"\"Alias for the [`adjoint`][..] method.\n\n    It returns the classical adjoint (or [adjugate](https://en.wikipedia.org/wiki/Adjugate_matrix)) of the matrix.\n\n    Args:\n        method (str, optional): Method to use to find the cofactors, can be \"bareiss\", \"berkowitz\",\n            \"bird\", \"laplace\" or \"lu\".\n    Returns:\n        (Matrix): The classical adjoint of the current matrix.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[1, 2], [3, 4]])\n        &gt;&gt;&gt; mat.adj()\n        Matrix([\n        [ 4, -2],\n        [-3,  1]])\n\n    See Also:\n        - SymPy's [`adjugate`][sympy.matrices.matrixbase.MatrixBase.adjugate]\n    \"\"\"\n    return self.adjugate(method=method)\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.cramer_solve","title":"<code>cramer_solve(rhs: Matrix, det_method: str = 'laplace', verbosity: int = 2) -&gt; Matrix</code>","text":"<p>Solves the linear system using Cramer's Rule.</p> <p>This method applies Cramer's Rule to solve the linear system represented by the matrix and the right-hand side vector. It computes the determinant of the matrix and uses it to find the solution vector.</p> <p>Parameters:</p> <ul> <li> <code>rhs</code>               (<code>Matrix</code>)           \u2013            <p>The right-hand side vector in the equation <code>Ax = rhs</code>.</p> </li> <li> <code>det_method</code>               (<code>str</code>, default:                   <code>'laplace'</code> )           \u2013            <p>The method to use for computing the determinant. Options include:</p> <ul> <li><code>'laplace'</code>: Uses the Laplace expansion method.</li> <li><code>'berkowitz'</code>: Uses the Berkowitz algorithm.</li> <li><code>'bird'</code>: Uses the Bird's algorithm.</li> <li><code>'bareiss'</code>: Uses the Bareiss algorithm.</li> <li><code>'lu'</code>: Uses LU decomposition.</li> </ul> </li> <li> <code>verbosity</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>Level of verbosity for displaying intermediate steps:</p> <ul> <li>0: No output.</li> <li>1: Display basic information.</li> <li>2: Display detailed information.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>The solution vector <code>x</code> that satisfies <code>self @ x = rhs</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NonSquareMatrixError</code>             \u2013            <p>If the matrix is not square.</p> </li> <li> <code>ShapeError</code>             \u2013            <p>If the matrix and the right-hand side vector have incompatible dimensions.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the determinant is zero, indicating that the system has no unique solution.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; A = Matrix([[1, 2], [3, 4]])\n&gt;&gt;&gt; b = Matrix([[5], [11]])\n&gt;&gt;&gt; A.cramer_solve(b, verbosity=0)\nMatrix([\n[1]\n[2]\n])\n</code></pre> See Also <ul> <li><code>solve</code>: For solving linear systems using other methods.</li> <li>SymPy's <code>Matrix.det</code> for computing the determinant.</li> <li>SymPy's <code>Matrix.cramer_solve</code></li> </ul> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def cramer_solve(\n    self, rhs: Matrix, det_method: str = \"laplace\", verbosity: int = 2\n) -&gt; Matrix:\n    \"\"\"Solves the linear system using Cramer's Rule.\n\n    This method applies Cramer's Rule to solve the linear system represented by the matrix and the right-hand side vector.\n    It computes the determinant of the matrix and uses it to find the solution vector.\n\n    Args:\n        rhs (Matrix): The right-hand side vector in the equation `Ax = rhs`.\n        det_method (str, optional): The method to use for computing the determinant. Options include:\n\n            - `'laplace'`: Uses the Laplace expansion method.\n            - `'berkowitz'`: Uses the Berkowitz algorithm.\n            - `'bird'`: Uses the Bird's algorithm.\n            - `'bareiss'`: Uses the Bareiss algorithm.\n            - `'lu'`: Uses LU decomposition.\n\n        verbosity (int, optional): Level of verbosity for displaying intermediate steps:\n\n            - 0: No output.\n            - 1: Display basic information.\n            - 2: Display detailed information.\n\n    Returns:\n        (Matrix): The solution vector `x` that satisfies `self @ x = rhs`.\n\n    Raises:\n        sympy.matrices.exceptions.NonSquareMatrixError: If the matrix is not square.\n        sympy.matrices.exceptions.ShapeError: If the matrix and the right-hand side vector have incompatible dimensions.\n        ValueError: If the determinant is zero, indicating that the system has no unique solution.\n\n    Examples:\n        &gt;&gt;&gt; A = Matrix([[1, 2], [3, 4]])\n        &gt;&gt;&gt; b = Matrix([[5], [11]])\n        &gt;&gt;&gt; A.cramer_solve(b, verbosity=0)\n        Matrix([\n        [1]\n        [2]\n        ])\n\n    See Also:\n        - [`solve`][..]: For solving linear systems using other methods.\n        - SymPy's [`Matrix.det`][sympy.matrices.matrixbase.MatrixBase.det] for computing the determinant.\n        - SymPy's [`Matrix.cramer_solve`][sympy.matrices.matrixbase.MatrixBase.cramer_solve]\n    \"\"\"\n    if self.rows != rhs.rows:\n        raise sym.ShapeError(\n            \"The right-hand side vector must have the same number of rows as the matrix.\"\n        )\n    if rhs.cols != 1:\n        raise sym.ShapeError(\n            \"The right-hand side vector must be a column vector (1 column).\"\n        )\n    if self.rows != self.cols:\n        raise sym.NonSquareMatrixError(\n            \"Cramer's Rule can only be applied to square matrices.\"\n        )\n    det = self.det(method=det_method)\n    if det == 0:\n        raise ValueError(\"Determinant is zero, no unique solution exists.\")\n\n    entries = []\n    for i in range(self.cols):\n        # Create a copy of the matrix and replace the i-th column with the rhs vector\n        modified_matrix = self.copy()\n        modified_matrix[:, i] = rhs[:, 0]\n        if verbosity &gt;= 2:\n            print(f\"Modified matrix for column {i + 1}:\")\n            display(modified_matrix)\n        det_i = modified_matrix.det(method=det_method) / det\n        if verbosity &gt;= 1:\n            display(\n                _textify(\"Determinant for column \")\n                + str(i + 1)\n                + \": \"\n                + sym.latex(det_i),\n                opt=\"math\",\n            )\n        entries.append(det_i)\n    return Matrix(entries)\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.column_constraints","title":"<code>column_constraints(use_ref: bool = False, verbosity: int = 1) -&gt; Matrix</code>","text":"<p>Computes the column constraints for the matrix by appending a symbolic vector.</p> <p>This method creates a matrix where a random column vector \\(\\begin{pmatrix} x_1 \\\\ \\vdots \\\\ x_m \\end{pmatrix}\\) is added to the matrix as an additional column. It then constructs a larger augmented matrix and optionally computes its Row Echelon Form (REF) or Reduced Row Echelon Form (RREF).</p> <p>The method modifies the matrix to ensure that the unknown vector is not reduced in RREF, and the constraints for the matrix columns are calculated accordingly.</p> <p>Parameters:</p> <ul> <li> <code>use_ref</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use Row Echelon Form (REF) instead of Reduced Row Echelon Form (RREF). If <code>False</code>, RREF will be used.</p> </li> <li> <code>verbosity</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Verbosity level for displaying information.</p> <ul> <li>0: No output</li> <li>1: Display all information</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>A new matrix containing the result after applying REF or RREF to the augmented matrix.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 2], [2, 4]]) # linearly dependent columns\n&gt;&gt;&gt; mat.column_constraints(verbosity=0)\nMatrix([\n[1, 2 |       x_2/2]\n[0, 0 | x_1 - x_2/2]\n])\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 2], [3, 4]]) # linearly independent columns\n&gt;&gt;&gt; mat.column_constraints(verbosity=0)\nMatrix([\n[1, 0 |    -2*x_1 + x_2]\n[0, 1 | 3*x_1/2 - x_2/2]\n])\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def column_constraints(self, use_ref: bool = False, verbosity: int = 1) -&gt; Matrix:\n    r\"\"\"Computes the column constraints for the matrix by appending a symbolic vector.\n\n    This method creates a matrix where a random column vector $\\begin{pmatrix} x_1 \\\\ \\vdots \\\\ x_m \\end{pmatrix}$\n    is added to the matrix as an additional column. It then constructs a larger augmented matrix\n    and optionally computes its Row Echelon Form (REF) or Reduced Row Echelon Form (RREF).\n\n    The method modifies the matrix to ensure that the unknown vector is not reduced in RREF,\n    and the constraints for the matrix columns are calculated accordingly.\n\n    Args:\n        use_ref (bool, optional): Whether to use Row Echelon Form (REF) instead of Reduced Row Echelon Form (RREF).\n            If `False`, RREF will be used.\n        verbosity (int, optional): Verbosity level for displaying information.\n\n            - 0: No output\n            - 1: Display all information\n\n    Returns:\n        (Matrix): A new matrix containing the result after applying REF or RREF to the augmented matrix.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[1, 2], [2, 4]]) # linearly dependent columns\n        &gt;&gt;&gt; mat.column_constraints(verbosity=0)\n        Matrix([\n        [1, 2 |       x_2/2]\n        [0, 0 | x_1 - x_2/2]\n        ])\n\n        &gt;&gt;&gt; mat = Matrix([[1, 2], [3, 4]]) # linearly independent columns\n        &gt;&gt;&gt; mat.column_constraints(verbosity=0)\n        Matrix([\n        [1, 0 |    -2*x_1 + x_2]\n        [0, 1 | 3*x_1/2 - x_2/2]\n        ])\n    \"\"\"\n\n    # write a random vector as x_1, ..., x_m, given m rows\n    vector = Matrix.create_unk_matrix(self.rows, 1, \"x\")\n\n    # insert hidden column vectors so that the unknown vector is not reduced in rref\n    hidden = self.elem()\n\n    M = self.copy().row_join(hidden).row_join(vector)\n    if use_ref:\n        res = M.ref().U\n    else:\n        res = M.rref(pivots=False)\n\n    visible_cols = (*range(self.cols), -1)\n    res_matrix = res.select_cols(*visible_cols).aug_line(-2)  # type: ignore\n\n    if verbosity:\n        print(\"Before RREF: [self | vec]\")\n        display(M.select_cols(*visible_cols).aug_line(-2))\n        print(\"After RREF\")\n        display(res_matrix)\n        print(\n            \"For the system to be consistent, the following constraints must be satisfied.\"\n        )\n        for i in range(res_matrix.rows):\n            # check for zero row\n            if res_matrix[i, : self.cols].norm() == 0:  # type: ignore\n                display(sym.Eq(res_matrix[i, -1], 0))\n    return res_matrix\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.normalized","title":"<code>normalized(iszerofunc: Callable[[Expr], int] | None = None, factor: bool = False) -&gt; Matrix | ScalarFactor</code>","text":"<p>Normalizes the column vectors of the matrix (scaling each vector to have a unit norm).</p> <p>Parameters:</p> <ul> <li> <code>iszerofunc</code>               (<code>Callable[[Expr], int]</code>, default:                   <code>None</code> )           \u2013            <p>Function to determine if a value should be treated as zero</p> </li> <li> <code>factor</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, returns the <code>ScalarFactor</code> dataclass. If <code>False</code>, only the normalized matrix is returned.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ScalarFactor</code>           \u2013            <p>A dataclass containing the normalized matrix and the diagonal matrix of norms if <code>factor=True</code>.</p> </li> <li> <code>Matrix</code>           \u2013            <p>The normalized matrix if <code>factor=False</code>.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[0, 3], [0, 4]])\n&gt;&gt;&gt; mat.normalized()\nMatrix([\n[0, 3/5]\n[0, 4/5]\n])\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[3], [4]])\n&gt;&gt;&gt; mat.normalized(factor=True)\nScalarFactor(diag=Matrix([[1/5]\n]), full=Matrix([\n[3]\n[4]\n]), order='FD')\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def normalized(\n    self,\n    iszerofunc: Callable[[Expr], int] | None = None,\n    factor: bool = False,\n) -&gt; Matrix | ScalarFactor:\n    \"\"\"Normalizes the column vectors of the matrix (scaling each vector to have a unit norm).\n\n    Args:\n        iszerofunc (Callable[[Expr], int], optional): Function to determine if a value should be treated as zero\n        factor (bool, optional): If `True`, returns the [`ScalarFactor`][(p).] dataclass.\n            If `False`, only the normalized matrix is returned.\n\n    Returns:\n        (ScalarFactor): A dataclass containing the normalized matrix and the diagonal matrix of norms if `factor=True`.\n        (Matrix): The normalized matrix if `factor=False`.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[0, 3], [0, 4]])\n        &gt;&gt;&gt; mat.normalized()\n        Matrix([\n        [0, 3/5]\n        [0, 4/5]\n        ])\n\n        &gt;&gt;&gt; mat = Matrix([[3], [4]])\n        &gt;&gt;&gt; mat.normalized(factor=True)\n        ScalarFactor(diag=Matrix([[1/5]\n        ]), full=Matrix([\n        [3]\n        [4]\n        ]), order='FD')\n    \"\"\"\n\n    for i in range(self.cols):\n        col = self.col(i)\n        scalar = sym.sqrt(sum(x**2 for x in col))  # Manual norm calculation\n        if iszerofunc is None:\n            if scalar != 0:\n                self[:, i] /= scalar  # type: ignore\n        else:\n            if iszerofunc(scalar) != 0:\n                self[:, i] /= scalar  # type: ignore\n\n    if factor:\n        return self.scalar_factor(column=True)\n    else:\n        return self\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.is_linearly_independent","title":"<code>is_linearly_independent(colspace: bool = True, verbosity: int = 0) -&gt; bool</code>","text":"<p>Determines if the vectors in the matrix are linearly independent.</p> <p>This method checks whether the columns (or rows) of the matrix are linearly independent by computing its reduced row echelon form (RREF) and comparing the number of pivot columns to the number of columns (or rows).</p> <p>Parameters:</p> <ul> <li> <code>colspace</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>True</code>, checks linear independence of columns (column space). If <code>False</code>, checks linear independence of rows (row space).</p> </li> <li> <code>verbosity</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Level of output during the RREF and check.</p> <ul> <li>0: No output (default).</li> <li>1: Print summary of the RREF and check.</li> <li>2: Print the matrix before and after RREF, and the check details.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if the matrix's columns (or rows) are linearly independent, <code>False</code> otherwise.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 2], [3, 4]])\n&gt;&gt;&gt; mat.is_linearly_independent()\nTrue\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 2], [2, 4]])\n&gt;&gt;&gt; mat.is_linearly_independent()\nFalse\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def is_linearly_independent(\n    self,\n    colspace: bool = True,\n    verbosity: int = 0,\n) -&gt; bool:\n    \"\"\"Determines if the vectors in the matrix are linearly independent.\n\n    This method checks whether the columns (or rows) of the matrix are linearly independent\n    by computing its reduced row echelon form (RREF) and comparing the number of pivot columns\n    to the number of columns (or rows).\n\n    Args:\n        colspace (bool, optional): If `True`, checks linear independence of columns (column space).\n            If `False`, checks linear independence of rows (row space).\n\n        verbosity (int, optional): Level of output during the RREF and check.\n\n            - 0: No output (default).\n            - 1: Print summary of the RREF and check.\n            - 2: Print the matrix before and after RREF, and the check details.\n\n    Returns:\n        (bool): `True` if the matrix's columns (or rows) are linearly independent, `False` otherwise.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[1, 2], [3, 4]])\n        &gt;&gt;&gt; mat.is_linearly_independent()\n        True\n\n        &gt;&gt;&gt; mat = Matrix([[1, 2], [2, 4]])\n        &gt;&gt;&gt; mat.is_linearly_independent()\n        False\n    \"\"\"\n    rref = self.rref(pivots=True)\n    assert isinstance(rref, RREF), \"RREF should return a RREF dataclass\"\n    rref_mat, pivots = rref.rref, rref.pivots\n\n    if verbosity == 1:\n        print(\"rref(self)\")\n    elif verbosity &gt;= 2:\n        print(\"Before RREF: self\")\n        display(self)\n        print(\"\\nAfter RREF:\")\n        display(rref_mat)\n\n    if colspace:\n        if verbosity &gt;= 1:\n            print(\n                f\"Check if Number of columns ({self.cols}) == Number of pivot columns ({len(pivots)})\"  # type: ignore\n            )\n        return self.cols == len(pivots)\n    else:\n        if verbosity &gt;= 1:\n            print(\n                f\"Check if Number of rows ({self.rows}) == Number of pivot columns ({len(pivots)})\"  # type: ignore\n            )\n        return self.rows == len(pivots)\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.get_linearly_independent_vectors","title":"<code>get_linearly_independent_vectors(colspace: bool = True, verbosity: int = 1) -&gt; Matrix</code>","text":"<p>Returns a matrix containing the linearly independent vectors from the column space or row space.</p> <p>This method computes the reduced row echelon form (RREF) of the matrix and selects the non-zero rows as linearly independent vectors. The result is a matrix whose columns (or rows) are linearly independent.</p> <p>Parameters:</p> <ul> <li> <code>colspace</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>True</code>, returns linearly independent vectors from the column space. If <code>False</code>, returns from the row space.</p> </li> <li> <code>verbosity</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Level of output verbosity.</p> <ul> <li>0: No output.</li> <li>1: Print a summary of the RREF and selection.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>A matrix whose columns (if colspace=True) or rows (if colspace=False) are linearly independent vectors.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 2], [2, 4]])\n&gt;&gt;&gt; mat.get_linearly_independent_vectors(colspace=True, verbosity=0)\nMatrix([\n[1]\n[2]\n])\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def get_linearly_independent_vectors(\n    self, colspace: bool = True, verbosity: int = 1\n) -&gt; Matrix:\n    \"\"\"Returns a matrix containing the linearly independent vectors from the column space or row space.\n\n    This method computes the reduced row echelon form (RREF) of the matrix and selects the non-zero rows\n    as linearly independent vectors. The result is a matrix whose columns (or rows) are linearly independent.\n\n    Args:\n        colspace (bool, optional): If `True`, returns linearly independent vectors from the column space.\n            If `False`, returns from the row space.\n\n        verbosity (int, optional): Level of output verbosity.\n\n            - 0: No output.\n            - 1: Print a summary of the RREF and selection.\n\n    Returns:\n        (Matrix): A matrix whose columns (if colspace=True) or rows (if colspace=False) are linearly independent vectors.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[1, 2], [2, 4]])\n        &gt;&gt;&gt; mat.get_linearly_independent_vectors(colspace=True, verbosity=0)\n        Matrix([\n        [1]\n        [2]\n        ])\n    \"\"\"\n    if colspace:\n        rref = self.rref(pivots=True)\n        assert isinstance(rref, RREF), \"RREF should return a RREF dataclass\"\n        if verbosity &gt;= 1:\n            print(\"Before RREF: [self]\")\n            display(self)\n            print(\"\\nAfter RREF:\")\n            display(rref)\n            print(\"Select columns of self corresponding to pivot positions.\")\n        return self.select_cols(*rref.pivots)\n    else:\n        rref = self.T.rref(pivots=True)\n        assert isinstance(rref, RREF), \"RREF should return a RREF dataclass\"\n        if verbosity &gt;= 1:\n            print(\"Before RREF: [self^T]\")\n            display(self.T)\n            print(\"\\nAfter RREF:\")\n            display(rref)\n            print(\"Select rows of self corresponding to pivot positions.\")\n        return self.select_rows(*rref.pivots)\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.simplify_basis","title":"<code>simplify_basis(colspace: bool = True, verbosity: int = 2) -&gt; Matrix</code>","text":"<p>Returns a simplified basis for the column space or row space of the matrix.</p> <p>This method computes a basis for either the column space or the row space of the matrix by reducing the matrix (or its transpose) to reduced row echelon form (RREF) and selecting the nonzero rows as basis vectors. The result is a matrix whose columns (or rows) form a basis for the specified subspace.</p> <p>Parameters:</p> <ul> <li> <code>colspace</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>True</code>, returns a basis for the column space. If <code>False</code>, returns a basis for the row space.</p> </li> <li> <code>verbosity</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>Level of output verbosity.</p> <ul> <li>0: No output.</li> <li>1: Print a summary of the RREF and basis selection.</li> <li>2: Print the matrix before and after RREF, and show the selected basis vectors.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>A matrix whose columns (if colspace=True) or rows (if colspace=False) form a basis for the corresponding subspace.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 2], [2, 4]])\n&gt;&gt;&gt; mat.simplify_basis(colspace=True, verbosity=0)\nMatrix([\n[1]\n[2]\n])\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 2], [3, 4]])\n&gt;&gt;&gt; mat.simplify_basis(colspace=False, verbosity=0)\nMatrix([\n[1, 0]\n[0, 1]\n])\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def simplify_basis(self, colspace: bool = True, verbosity: int = 2) -&gt; Matrix:\n    \"\"\"Returns a simplified basis for the column space or row space of the matrix.\n\n    This method computes a basis for either the column space or the row space of the matrix\n    by reducing the matrix (or its transpose) to reduced row echelon form (RREF) and selecting\n    the nonzero rows as basis vectors. The result is a matrix whose columns (or rows) form a basis\n    for the specified subspace.\n\n    Args:\n        colspace (bool, optional): If `True`, returns a basis for the column space.\n            If `False`, returns a basis for the row space.\n\n        verbosity (int, optional): Level of output verbosity.\n\n            - 0: No output.\n            - 1: Print a summary of the RREF and basis selection.\n            - 2: Print the matrix before and after RREF, and show the selected basis vectors.\n\n    Returns:\n        (Matrix): A matrix whose columns (if colspace=True) or rows (if colspace=False) form a basis\n            for the corresponding subspace.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[1, 2], [2, 4]])\n        &gt;&gt;&gt; mat.simplify_basis(colspace=True, verbosity=0)\n        Matrix([\n        [1]\n        [2]\n        ])\n\n        &gt;&gt;&gt; mat = Matrix([[1, 2], [3, 4]])\n        &gt;&gt;&gt; mat.simplify_basis(colspace=False, verbosity=0)\n        Matrix([\n        [1, 0]\n        [0, 1]\n        ])\n    \"\"\"\n    if colspace:\n        rref_mat = self.T.rref(pivots=False)\n        assert isinstance(rref_mat, Matrix), \"RREF should return a Matrix\"\n        if verbosity == 1:\n            print(\"Select non-zero rows of rref(self.T) as basis vectors.\")\n        if verbosity &gt;= 2:\n            print(\"Before RREF: self^T\")\n            display(self.T)\n            print(\"\\nAfter RREF:\")\n            display(rref_mat)\n    else:\n        rref_mat = self.rref(pivots=False)\n        assert isinstance(rref_mat, Matrix), \"RREF should return a Matrix\"\n        if verbosity == 1:\n            print(\"Select non-zero rows of rref(self) as basis vectors.\")\n        if verbosity &gt;= 2:\n            print(\"Before RREF: self\")\n            display(self)\n            print(\"\\nAfter RREF:\")\n            display(rref_mat)\n\n    idxs = []\n    for i in range(rref_mat.rows):\n        if any(not _is_zero(x) for x in rref_mat[i, :]):  # type: ignore\n            idxs.append(i)\n\n    mat = rref_mat.select_rows(*idxs)\n    if colspace:\n        return mat.T\n    else:\n        return mat\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.extend_basis","title":"<code>extend_basis(span_subspace: Matrix | None = None, verbosity: int = 2) -&gt; Matrix</code>","text":"<p>Extends the matrix to form a basis for the span of the given subspace.</p> <p>This method extends the column space of the current matrix to include the columns of the provided <code>span_subspace</code>, computes the Reduced Row Echelon Form (RREF) of the augmented matrix, and then selects the pivot columns to return the extended basis.</p> <p>If no <code>span_subspace</code> is provided, the identity matrix (i.e. \\(\\mathrm{span} \\left(\\mathbb{R}^n \\right)\\)) is used as the default. The result is a matrix with the extended basis that spans the combined space of the <code>self</code> matrix and the <code>span_subspace</code>.</p> <p>Parameters:</p> <ul> <li> <code>span_subspace</code>               (<code>Matrix</code>, default:                   <code>None</code> )           \u2013            <p>A matrix whose columns represent the subspace to be added to the current matrix. If <code>None</code>, the identity matrix is used.</p> </li> <li> <code>verbosity</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>Verbosity level for displaying information.</p> <ul> <li>0: No output.</li> <li>1: Display steps.</li> <li>2: Display the matrix before and after RREF.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>A matrix whose column space represents the extended basis, consisting of the pivot columns     from the RREF of the augmented matrix.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 2], [2, 4]])\n&gt;&gt;&gt; mat.extend_basis(verbosity=0)\nMatrix([\n[1, 1]\n[2, 0]\n])\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def extend_basis(\n    self, span_subspace: Matrix | None = None, verbosity: int = 2\n) -&gt; Matrix:\n    r\"\"\"Extends the matrix to form a basis for the span of the given subspace.\n\n    This method extends the column space of the current matrix to include the columns of the provided\n    `span_subspace`, computes the Reduced Row Echelon Form (RREF) of the augmented matrix,\n    and then selects the pivot columns to return the extended basis.\n\n    If no `span_subspace` is provided, the identity matrix (i.e. $\\mathrm{span} \\left(\\mathbb{R}^n \\right)$) is used as the default.\n    The result is a matrix with the extended basis that spans the combined space of the `self`\n    matrix and the `span_subspace`.\n\n    Args:\n        span_subspace (Matrix, optional): A matrix whose columns represent the subspace to\n            be added to the current matrix. If `None`, the identity matrix is used.\n\n        verbosity (int, optional): Verbosity level for displaying information.\n\n            - 0: No output.\n            - 1: Display steps.\n            - 2: Display the matrix before and after RREF.\n\n    Returns:\n        (Matrix): A matrix whose column space represents the extended basis, consisting of the pivot columns\n                from the RREF of the augmented matrix.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[1, 2], [2, 4]])\n        &gt;&gt;&gt; mat.extend_basis(verbosity=0)\n        Matrix([\n        [1, 1]\n        [2, 0]\n        ])\n    \"\"\"\n\n    if span_subspace is None:\n        span_subspace = self.elem()\n    aug = self.copy().row_join(span_subspace)\n    rref = aug.rref(pivots=True)\n    assert isinstance(rref, RREF), \"RREF should return a RREF dataclass\"\n\n    if verbosity == 1:\n        print(\"rref([self | span_subspace])\")\n    elif verbosity &gt;= 2:\n        print(\"Before RREF: [self | span_subspace]\")\n        display(aug)\n        print(\"\\nAfter RREF:\")\n        display(rref)\n        print(\n            \"Select columns of rref([self | span_subspace]) corresponding to pivot positions.\"\n        )\n\n    return aug.select_cols(*rref.pivots)\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.intersect_subspace","title":"<code>intersect_subspace(other: Matrix, verbosity: int = 2) -&gt; Matrix</code>","text":"<p>Computes the intersection of two subspaces by finding the nullspace of their orthogonal complements.</p> <p>This method computes the intersection of the subspaces spanned by the columns of the current matrix (<code>self</code>) and the provided matrix (<code>other</code>). The intersection is computed by finding the union of the nullspace of the row space of the two matrices, and then finding its orthogonal complement.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>Matrix</code>)           \u2013            <p>The second matrix representing the other subspace to intersect with the current matrix.</p> </li> <li> <code>verbosity</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>Level of verbosity for displaying intermediate steps:</p> <ul> <li>0: No output.</li> <li>1: Display steps.</li> <li>2: Display the relevant matrices. Defaults to 2.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>A matrix whose columns form a basis for the intersection of the two subspaces.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat1 = Matrix([[1, 0], [0, 1]])\n&gt;&gt;&gt; mat2 = Matrix([[1, 1], [0, 0]])\n&gt;&gt;&gt; mat1.intersect_subspace(mat2, verbosity=0)\nMatrix([\n[1]\n[0]\n])\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def intersect_subspace(self, other: Matrix, verbosity: int = 2) -&gt; Matrix:\n    \"\"\"Computes the intersection of two subspaces by finding the nullspace of their orthogonal complements.\n\n    This method computes the intersection of the subspaces spanned by the columns of the current matrix\n    (`self`) and the provided matrix (`other`). The intersection is computed by finding the union of the nullspace of\n    the row space of the two matrices, and then finding its orthogonal complement.\n\n    Args:\n        other (Matrix): The second matrix representing the other subspace to intersect with the current matrix.\n        verbosity (int, optional): Level of verbosity for displaying intermediate steps:\n\n            - 0: No output.\n            - 1: Display steps.\n            - 2: Display the relevant matrices.\n            Defaults to 2.\n\n    Returns:\n        (Matrix): A matrix whose columns form a basis for the intersection of the two subspaces.\n\n    Examples:\n        &gt;&gt;&gt; mat1 = Matrix([[1, 0], [0, 1]])\n        &gt;&gt;&gt; mat2 = Matrix([[1, 1], [0, 0]])\n        &gt;&gt;&gt; mat1.intersect_subspace(mat2, verbosity=0)\n        Matrix([\n        [1]\n        [0]\n        ])\n    \"\"\"\n\n    # Construct 2 matrices A and B, whose solution space (ie nullspace) is\n    # the subspace self and other respectively. Observe that the solution\n    # space is orthogonal to the row space, so it is the orthogonal complement.\n\n    A = self.orthogonal_complement().T\n    B = other.orthogonal_complement().T\n\n    # Now we obtain A and B which represent the linear system of 2 different\n    # subspaces. When we solve these simultaneously, we will find the solution\n    # space which contains vectors which are solutions to both linear systems.\n    aug = A.col_join(B)\n    if verbosity == 1:\n        print(\"A = Null(self^T)^T\")\n        print(\"B = Null(other^T)^T\")\n        print(\"Null([A ; B])\")\n\n    if verbosity &gt;= 2:\n        print(\n            \"A linear system whose solution space is the subspace of self. Null(self^T)^T\"\n        )\n        display(A)\n        print(\n            \"\\nA linear system whose solution space is the subspace of other. Null(other^T)^T\"\n        )\n        display(B)\n        print(\"\\nBefore RREF: [self ; other]\")\n        display(aug)\n        print(\"\\nAfter RREF:\")\n        display(aug.rref())\n\n    return Matrix.from_list(aug.nullspace())\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.is_subspace_of","title":"<code>is_subspace_of(other: Matrix, verbosity: int = 2) -&gt; bool</code>","text":"<p>Checks if the current matrix is a subspace of another matrix.</p> <p>This method determines whether the subspace spanned by the columns of the current matrix (<code>self</code>) is a subspace of the provided matrix (<code>other</code>). It does so by checking if the row-reduced echelon form (RREF) of the augmented matrix <code>[other | self]</code>.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>Matrix</code>)           \u2013            <p>The second matrix representing the other subspace to compare with the current matrix. If <code>None</code>, the identity matrix is used to check if it spans \\(\\mathbb{R}^\\text{self.rows}}\\)</p> </li> <li> <code>verbosity</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>Level of verbosity for displaying intermediate steps:</p> <ul> <li>0: No output.</li> <li>1: Display the steps.</li> <li>2: Display the relevant matrices.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if the subspace spanned by <code>self</code> is a subspace of <code>other</code>, <code>False</code> otherwise.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ShapeError</code>             \u2013            <p>If the number of rows in the current matrix and the target matrix are different.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat1 = Matrix([[1, 0], [0, 1]])\n&gt;&gt;&gt; mat2 = Matrix([[1], [0]])\n&gt;&gt;&gt; mat2.is_subspace_of(mat1, verbosity=0)\nTrue\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def is_subspace_of(self, other: Matrix, verbosity: int = 2) -&gt; bool:\n    r\"\"\"Checks if the current matrix is a subspace of another matrix.\n\n    This method determines whether the subspace spanned by the columns of the current matrix (`self`)\n    is a subspace of the provided matrix (`other`). It does so by checking if the row-reduced echelon form\n    (RREF) of the augmented matrix `[other | self]`.\n\n    Args:\n        other (Matrix, optional): The second matrix representing the other subspace to compare with the current matrix.\n            If `None`, the identity matrix is used to check if it spans $\\mathbb{R}^\\text{self.rows}}$\n        verbosity (int, optional): Level of verbosity for displaying intermediate steps:\n\n            - 0: No output.\n            - 1: Display the steps.\n            - 2: Display the relevant matrices.\n\n    Returns:\n        (bool): `True` if the subspace spanned by `self` is a subspace of `other`, `False` otherwise.\n\n    Raises:\n        sympy.matrices.exceptions.ShapeError: If the number of rows in the current matrix and the target matrix are different.\n\n    Examples:\n        &gt;&gt;&gt; mat1 = Matrix([[1, 0], [0, 1]])\n        &gt;&gt;&gt; mat2 = Matrix([[1], [0]])\n        &gt;&gt;&gt; mat2.is_subspace_of(mat1, verbosity=0)\n        True\n    \"\"\"\n    if self.rows != other.rows:\n        raise sym.ShapeError(\n            f\"The matrices have incompatible number of rows ({self.rows}, {other.rows})\"\n        )\n\n    aug = other.copy().row_join(self)\n    sub = aug.rref(pivots=True)\n    assert isinstance(sub, RREF), \"RREF should return a RREF dataclass\"\n    if verbosity == 1:\n        print(\"Check rref([other | self])\")\n    if verbosity &gt;= 2:\n        print(\"Check if span(self) is subspace of span(other)\")\n        print(\"\\nBefore RREF: [other | self]\")\n        display(aug)\n        print(\"\\nAfter RREF:\")\n        display(sub)\n        if max(sub.pivots) &gt;= other.cols:\n            print(\"Span(self) is not a subspace of span(other).\\n\")\n        else:\n            print(\"Span(self) is a subspace of span(other).\\n\")\n\n    return max(sub.pivots) &lt; other.cols\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.is_same_subspace","title":"<code>is_same_subspace(other: Matrix | None = None, verbosity: int = 2) -&gt; bool</code>","text":"<p>Checks if two subspaces are the same by verifying if each subspace is a subspace of the other.</p> <p>This method determines whether the subspaces spanned by the columns of the current matrix (<code>self</code>) and the provided matrix (<code>other</code>) are the same. It does so by calling the <code>is_subspace_of</code> method twice: first to check if <code>self</code> is a subspace of <code>other</code>, and then to check if <code>other</code> is a subspace of <code>self</code>. If both checks return <code>True</code>, then the subspaces are considered the same.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>Matrix</code>, default:                   <code>None</code> )           \u2013            <p>The second matrix representing the other subspace to compare with the current matrix. If <code>None</code>, the identity matrix is used to check if it spans \\(\\mathbb{R}^\\text{self.rows}}\\)</p> </li> <li> <code>verbosity</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>Level of verbosity for displaying intermediate steps:</p> <ul> <li>0: No output.</li> <li>1: Display the steps.</li> <li>2: Display the relevant matrices. Defaults to 2.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if the subspaces spanned by <code>self</code> and <code>other</code> are the same, <code>False</code> otherwise.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ShapeError</code>             \u2013            <p>If the number of rows in the current matrix and the target matrix are different.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat1 = Matrix([[1, 0], [0, 1]])\n&gt;&gt;&gt; mat2 = Matrix([[1, 2], [3, 4]])\n&gt;&gt;&gt; mat1.is_same_subspace(mat2, verbosity=0)\nTrue\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def is_same_subspace(self, other: Matrix | None = None, verbosity: int = 2) -&gt; bool:\n    r\"\"\"Checks if two subspaces are the same by verifying if each subspace is a subspace of the other.\n\n    This method determines whether the subspaces spanned by the columns of the current matrix (`self`)\n    and the provided matrix (`other`) are the same. It does so by calling the `is_subspace_of` method\n    twice: first to check if `self` is a subspace of `other`, and then to check if `other` is a subspace of `self`.\n    If both checks return `True`, then the subspaces are considered the same.\n\n    Args:\n        other (Matrix, optional): The second matrix representing the other subspace to compare with the current matrix.\n            If `None`, the identity matrix is used to check if it spans $\\mathbb{R}^\\text{self.rows}}$\n        verbosity (int, optional): Level of verbosity for displaying intermediate steps:\n\n            - 0: No output.\n            - 1: Display the steps.\n            - 2: Display the relevant matrices.\n            Defaults to 2.\n\n    Returns:\n        (bool): `True` if the subspaces spanned by `self` and `other` are the same, `False` otherwise.\n\n    Raises:\n        sympy.matrices.exceptions.ShapeError: If the number of rows in the current matrix and the target matrix are different.\n\n    Examples:\n        &gt;&gt;&gt; mat1 = Matrix([[1, 0], [0, 1]])\n        &gt;&gt;&gt; mat2 = Matrix([[1, 2], [3, 4]])\n        &gt;&gt;&gt; mat1.is_same_subspace(mat2, verbosity=0)\n        True\n    \"\"\"\n    if other is None:\n        rref = self.rref(pivots=True)\n        assert isinstance(rref, RREF), \"RREF should return a RREF dataclass\"\n        if verbosity &gt;= 1:\n            print(\"Check rref(self) does not have zero rows\")\n        if verbosity &gt;= 2:\n            print(\"Before RREF: self\")\n            display(self)\n            print(\"\\nAfter RREF:\")\n            display(rref.rref)\n        return len(rref.pivots) == self.rows  # no zero rows\n\n    if self.rows != other.rows:\n        raise sym.ShapeError(\n            f\"The matrices have incompatible number of rows ({self.rows}, {other.rows})\"\n        )\n\n    if verbosity &gt;= 1:\n        print(\"Check if span(self) is subspace of span(other), and vice versa.\")\n    return self.is_subspace_of(\n        other=other, verbosity=verbosity\n    ) and other.is_subspace_of(other=self, verbosity=verbosity)\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.coords_relative","title":"<code>coords_relative(basis: Matrix, verbosity: int = 2) -&gt; Matrix</code>","text":"<p>Computes the coordinates of the current vector relative to a given basis.</p> <p>This method finds the coordinate vector <code>c</code> such that <code>self = basis @ c</code>, where <code>basis</code> is a matrix whose columns form a basis, and <code>self</code> is a column vector. The method achieves this by augmenting the target matrix with the current matrix, performing Reduced Row Echelon Form (RREF), and extracting the appropriate part of the resulting matrix.</p> <p>Parameters:</p> <ul> <li> <code>basis</code>               (<code>Matrix</code>)           \u2013            <p>The matrix whose columns form the target basis.</p> </li> <li> <code>verbosity</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>Level of output verbosity.</p> <ul> <li>0: No output.</li> <li>1: Print summary of the RREF and solution.</li> <li>2: Print the matrix before and after RREF, and show the solution details.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>The coordinate vector of <code>self</code> relative to the basis <code>to</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ShapeError</code>             \u2013            <p>If <code>self</code> is not a column vector or if the number of rows in <code>self</code> and <code>basis</code> do not match.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the system is inconsistent and no solution exists.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; v = Matrix([[3], [7]])\n&gt;&gt;&gt; B = Matrix([[1, 2], [1, 3]])\n&gt;&gt;&gt; v.coords_relative(B, verbosity=0)\nMatrix([\n[-5]\n[ 4]\n])\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def coords_relative(self, basis: Matrix, verbosity: int = 2) -&gt; Matrix:\n    \"\"\"Computes the coordinates of the current vector relative to a given basis.\n\n    This method finds the coordinate vector `c` such that `self = basis @ c`,\n    where `basis` is a matrix whose columns form a basis, and `self` is a column vector. The method\n    achieves this by augmenting the target matrix with the current matrix, performing\n    Reduced Row Echelon Form (RREF), and extracting the appropriate part of the resulting matrix.\n\n    Args:\n        basis (Matrix): The matrix whose columns form the target basis.\n\n        verbosity (int, optional): Level of output verbosity.\n\n            - 0: No output.\n            - 1: Print summary of the RREF and solution.\n            - 2: Print the matrix before and after RREF, and show the solution details.\n\n    Returns:\n        (Matrix): The coordinate vector of `self` relative to the basis `to`.\n\n    Raises:\n        sympy.matrices.exceptions.ShapeError: If `self` is not a column vector\n            or if the number of rows in `self` and `basis` do not match.\n        ValueError: If the system is inconsistent and no solution exists.\n\n    Examples:\n        &gt;&gt;&gt; v = Matrix([[3], [7]])\n        &gt;&gt;&gt; B = Matrix([[1, 2], [1, 3]])\n        &gt;&gt;&gt; v.coords_relative(B, verbosity=0)\n        Matrix([\n        [-5]\n        [ 4]\n        ])\n    \"\"\"\n    if self.cols != 1:\n        raise sym.ShapeError(\n            f\"self should be a vector with 1 column. ({self.cols})\"\n        )\n    if self.rows != basis.rows:\n        raise sym.ShapeError(\n            f\"The matrices have incompatible number of rows ({self.rows}, {basis.rows})\"\n        )\n\n    M = basis.copy().row_join(self)\n    rref = M.rref(pivots=True)\n    assert isinstance(rref, RREF), \"RREF should return a RREF dataclass\"\n    rref_mat, pivots = rref.rref, rref.pivots\n\n    if verbosity == 1:\n        print(\"Solve system via rref([to | self])\")\n    elif verbosity &gt;= 2:\n        print(\"Before RREF: [to | self]\")\n        display(M)\n        print(\"\\nAfter RREF:\")\n        display(rref_mat)\n\n    if basis.cols in pivots:\n        raise ValueError(\"No solution found due to inconsistent system.\")\n\n    sol = basis.solve(self)[0]  # solution should be unique\n    assert isinstance(sol, Matrix), \"Solution should be a Matrix (vector) object\"\n    return sol\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.transition_matrix","title":"<code>transition_matrix(to: Matrix, verbosity: int = 2) -&gt; Matrix</code>","text":"<p>Computes the transition matrix that transforms this matrix to another matrix.</p> <p>This method computes the transition matrix <code>P</code> such that <code>self = P @ to</code>, where <code>to</code> is the target basis, and <code>self</code> is the current basis. The method achieves this by augmenting the target matrix with the current matrix, performing Reduced Row Echelon Form (RREF), and extracting the appropriate part of the resulting matrix.</p> <p>Parameters:</p> <ul> <li> <code>to</code>               (<code>Matrix</code>)           \u2013            <p>The matrix to which the current matrix should be transformed.</p> </li> <li> <code>verbosity</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>Verbosity level for displaying information.</p> <ul> <li>0: No output.</li> <li>1: Display the steps.</li> <li>2: Display the relevant matrices.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>The transition matrix <code>P</code> that satisfies <code>self = P @ to</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AssertionError</code>             \u2013            <p>If the columns of the <code>self</code> matrix and <code>to</code> matrix do not span the same subspace.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat1 = Matrix([[1, 0], [0, 1]])\n&gt;&gt;&gt; mat2 = Matrix([[2, 0], [0, 2]])\n&gt;&gt;&gt; mat1.transition_matrix(to=mat2, verbosity=0)\nMatrix([\n[1/2,   0],\n[  0, 1/2]])\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def transition_matrix(self, to: Matrix, verbosity: int = 2) -&gt; Matrix:\n    \"\"\"Computes the transition matrix that transforms this matrix to another matrix.\n\n    This method computes the transition matrix `P` such that `self = P @ to`,\n    where `to` is the target basis, and `self` is the current basis. The method\n    achieves this by augmenting the target matrix with the current matrix, performing\n    Reduced Row Echelon Form (RREF), and extracting the appropriate part of the resulting matrix.\n\n    Args:\n        to (Matrix): The matrix to which the current matrix should be transformed.\n\n        verbosity (int, optional): Verbosity level for displaying information.\n\n            - 0: No output.\n            - 1: Display the steps.\n            - 2: Display the relevant matrices.\n\n    Returns:\n        (Matrix): The transition matrix `P` that satisfies `self = P @ to`.\n\n    Raises:\n        AssertionError: If the columns of the `self` matrix and `to` matrix do not span the same subspace.\n\n    Examples:\n        &gt;&gt;&gt; mat1 = Matrix([[1, 0], [0, 1]])\n        &gt;&gt;&gt; mat2 = Matrix([[2, 0], [0, 2]])\n        &gt;&gt;&gt; mat1.transition_matrix(to=mat2, verbosity=0)\n        Matrix([\n        [1/2,   0],\n        [  0, 1/2]])\n    \"\"\"\n    assert self.is_same_subspace(to, verbosity=0), (\n        \"Column vectors of both matrices must span the same subspace.\"\n    )\n\n    M = to.copy().row_join(self)\n    res = M.rref(pivots=False)\n    assert isinstance(res, Matrix), \"RREF should return a Matrix object\"\n    if verbosity == 1:\n        print(\"rref([to | self])\")\n    elif verbosity &gt;= 2:\n        print(\"Before RREF: [to | self]\")\n        display(M)\n        print(\"\\nAfter RREF:\")\n        display(res)\n    P = res[: self.cols, self.cols :]\n    return P  # type: ignore\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.nullspace","title":"<code>nullspace(verbosity: int = 0, *args, **kwargs) -&gt; list[Matrix]</code>","text":"<p>Computes the null space (kernel) of the matrix, i.e., the set of vectors that satisfy <code>self @ x = 0</code>.</p> <p>This method utilizes the rank-nullity theorem to determine if the null space exists. Fixes the issue with SymPy implementation of nullspace where it raises an exception if the nullspace is trivial (only contain the zero vector). If the matrix has full column rank (i.e., rank = number of columns), it has no non-trivial null space, and an empty list is returned.</p> <p>Parameters:</p> <ul> <li> <code>verbosity</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Level of verbosity for displaying intermediate steps.</p> <ul> <li>0: No output.</li> <li>1: Display the matrix before and after row-reduction (RREF).</li> </ul> </li> <li> <code>*args</code>           \u2013            <p>Additional positional arguments passed to SymPy's <code>nullspace</code> method.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments passed to SymPy's <code>nullspace</code> method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Matrix]</code>           \u2013            <p>list[Matrix]: A list of <code>Matrix</code> objects representing the null space vectors. Returns an empty list if the null space is trivial.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 2], [3, 6]])\n&gt;&gt;&gt; mat.nullspace()\n[Matrix([\n[-2],\n[ 1]])]\n</code></pre> See Also <ul> <li>SymPy's <code>Matrix.nullspace</code></li> <li><code>orthogonal_complement</code> for computing the orthogonal complement of the matrix.</li> </ul> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def nullspace(self, verbosity: int = 0, *args, **kwargs) -&gt; list[Matrix]:\n    \"\"\"\n    Computes the null space (kernel) of the matrix, i.e., the set of vectors that satisfy `self @ x = 0`.\n\n    This method utilizes the rank-nullity theorem to determine if the null space exists. Fixes the\n    issue with SymPy [implementation][sympy.matrices.matrixbase.MatrixBase.nullspace] of nullspace where\n    it raises an exception if the nullspace is trivial (only contain the zero vector).\n    If the matrix has full column rank (i.e., rank = number of columns), it has no non-trivial null space,\n    and an empty list is returned.\n\n    Args:\n        verbosity (int, optional): Level of verbosity for displaying intermediate steps.\n\n            - 0: No output.\n            - 1: Display the matrix before and after row-reduction (RREF).\n        *args: Additional positional arguments passed to SymPy's [`nullspace`][sympy.matrices.matrixbase.MatrixBase.nullspace] method.\n        **kwargs: Additional keyword arguments passed to SymPy's [`nullspace`][sympy.matrices.matrixbase.MatrixBase.nullspace] method.\n\n    Returns:\n        list[Matrix]: A list of [`Matrix`][...] objects representing the null space vectors. Returns an empty list if the null space is trivial.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[1, 2], [3, 6]])\n        &gt;&gt;&gt; mat.nullspace()\n        [Matrix([\n        [-2],\n        [ 1]])]\n\n    See Also:\n        - SymPy's [`Matrix.nullspace`][sympy.matrices.matrixbase.MatrixBase.nullspace]\n        - [`orthogonal_complement`][..] for computing the orthogonal complement of the matrix.\n    \"\"\"\n\n    # Issue with SymPy implementation of nullspace when there is None\n    # Using rank nullity theorem to verify there are vectors spanning nullspace\n    if verbosity &gt;= 1:\n        print(\"Before RREF: [self]\")\n        display(self)\n        print(\"\\nAfter RREF:\")\n        display(self.rref())\n\n    if self.rank() == self.cols:\n        if verbosity &gt;= 1:\n            warn(\n                \"Only trivial nullspace (0-vector) detected!\",\n                UserWarning,\n                stacklevel=2,\n            )\n        return []\n    else:\n        return super().nullspace(*args, **kwargs)\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.nullity","title":"<code>nullity() -&gt; int</code>","text":"<p>Computes the nullity of the matrix, which is the dimension of its null space.</p> <p>The nullity is defined as the number of free variables in the solution to the homogeneous equation <code>self @ x = 0</code>. It can be computed as <code>nullity = cols - rank</code>, where <code>cols</code> is the number of columns in the matrix and <code>rank</code> is its rank.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The nullity of the matrix.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 2], [3, 6]])\n&gt;&gt;&gt; mat.nullity()\n1\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def nullity(self) -&gt; int:\n    \"\"\"Computes the nullity of the matrix, which is the dimension of its null space.\n\n    The nullity is defined as the number of free variables in the solution to the homogeneous equation `self @ x = 0`.\n    It can be computed as `nullity = cols - rank`, where `cols` is the number of columns in the matrix and `rank` is its rank.\n\n    Returns:\n        (int): The nullity of the matrix.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[1, 2], [3, 6]])\n        &gt;&gt;&gt; mat.nullity()\n        1\n    \"\"\"\n    return self.cols - self.rank()\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.orthogonal_complement","title":"<code>orthogonal_complement(verbosity: int = 0) -&gt; Matrix</code>","text":"<p>Computes the orthogonal complement of the matrix (the null space of its transpose).</p> <p>The orthogonal complement consists of all vectors that are orthogonal to the column space of the matrix. This method computes the null space of the transpose of the matrix, which gives a basis for the orthogonal complement.</p> Note <p>The orthogonal complement is the set of all vectors <code>v</code> such that <code>self^T @ v = 0</code>.</p> <p>Parameters:</p> <ul> <li> <code>verbosity</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Level of verbosity for debugging.</p> <ul> <li>0: No output.</li> <li>1: Display the matrix before and after row-reduction (RREF).</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>A matrix whose columns form a basis for the orthogonal complement.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 0], [0, 0]])\n&gt;&gt;&gt; mat.orthogonal_complement()\nMatrix([\n[0]\n[1]\n])\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def orthogonal_complement(self, verbosity: int = 0) -&gt; Matrix:\n    \"\"\"Computes the orthogonal complement of the matrix (the null space of its transpose).\n\n    The orthogonal complement consists of all vectors that are orthogonal to the column space of the matrix.\n    This method computes the null space of the transpose of the matrix, which gives a basis for the orthogonal complement.\n\n    Note:\n        The orthogonal complement is the set of all vectors `v` such that `self^T @ v = 0`.\n\n    Args:\n        verbosity (int, optional): Level of verbosity for debugging.\n\n            - 0: No output.\n            - 1: Display the matrix before and after row-reduction (RREF).\n\n\n    Returns:\n        (Matrix): A matrix whose columns form a basis for the orthogonal complement.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[1, 0], [0, 0]])\n        &gt;&gt;&gt; mat.orthogonal_complement()\n        Matrix([\n        [0]\n        [1]\n        ])\n    \"\"\"\n\n    return Matrix.from_list(self.transpose().nullspace(verbosity))\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.is_vec_orthogonal","title":"<code>is_vec_orthogonal(verbosity: int = 1) -&gt; bool</code>","text":"<p>Checks if the column vectors of the matrix are orthogonal to each other.</p> <p>This method computes <code>self^T @ self</code> and checks if the result is diagonal. If the result is diagonal, the vectors are orthogonal (i.e., \\(u_i \\dot u_j = 0 \\forall i != j\\)).</p> Note <p>This method checks for orthogonality, not orthonormality. For orthonormality, use <code>is_mat_orthogonal</code>.</p> <p>Parameters:</p> <ul> <li> <code>verbosity</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Level of verbosity for displaying intermediate results.</p> <ul> <li>0: No output.</li> <li>1: Display the matrix product <code>self.T @ self</code>.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if the column vectors are orthogonal, <code>False</code> otherwise.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 0], [0, 2]])\n&gt;&gt;&gt; mat.is_vec_orthogonal(verbosity=0)\nTrue\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def is_vec_orthogonal(self, verbosity: int = 1) -&gt; bool:\n    r\"\"\"Checks if the column vectors of the matrix are orthogonal to each other.\n\n    This method computes `self^T @ self` and checks if the result is diagonal.\n    If the result is diagonal, the vectors are orthogonal (i.e., $u_i \\dot u_j = 0 \\forall i != j$).\n\n    Note:\n        This method checks for orthogonality, not orthonormality. For orthonormality, use [`is_mat_orthogonal`][..].\n\n    Args:\n        verbosity (int, optional): Level of verbosity for displaying intermediate results.\n\n            - 0: No output.\n            - 1: Display the matrix product `self.T @ self`.\n\n    Returns:\n        (bool): `True` if the column vectors are orthogonal, `False` otherwise.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[1, 0], [0, 2]])\n        &gt;&gt;&gt; mat.is_vec_orthogonal(verbosity=0)\n        True\n    \"\"\"\n\n    res = self.T @ self\n    if verbosity &gt;= 1:\n        print(\"Check if [self^T @ self] is a diagonal matrix\")\n        display(res)\n    return res.is_diagonal()\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.is_mat_orthogonal","title":"<code>is_mat_orthogonal(verbosity: int = 1) -&gt; bool</code>","text":"<p>Checks if the matrix is orthogonal (i.e., its columns are orthonormal).</p> <p>A matrix is orthogonal if its columns are orthonormal, i.e., if <code>self.T @ self</code> is the identity matrix. This method computes <code>self.T @ self</code> and checks if the result is an identity matrix.</p> <p>Parameters:</p> <ul> <li> <code>verbosity</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Level of verbosity for displaying intermediate results.</p> <ul> <li>0: No output.</li> <li>1: Display the matrix product <code>self.T @ self</code>.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the matrix is orthogonal, False otherwise.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 0], [0, 1]])\n&gt;&gt;&gt; mat.is_mat_orthogonal(verbosity=0)\nTrue\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 0], [0, 2]])\n&gt;&gt;&gt; mat.is_mat_orthogonal(verbosity=0)\nFalse\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def is_mat_orthogonal(self, verbosity: int = 1) -&gt; bool:\n    \"\"\"\n    Checks if the matrix is orthogonal (i.e., its columns are orthonormal).\n\n    A matrix is orthogonal if its columns are orthonormal, i.e., if `self.T @ self` is the identity matrix.\n    This method computes `self.T @ self` and checks if the result is an identity matrix.\n\n    Args:\n        verbosity (int, optional): Level of verbosity for displaying intermediate results.\n\n            - 0: No output.\n            - 1: Display the matrix product `self.T @ self`.\n\n    Returns:\n        (bool): True if the matrix is orthogonal, False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[1, 0], [0, 1]])\n        &gt;&gt;&gt; mat.is_mat_orthogonal(verbosity=0)\n        True\n\n        &gt;&gt;&gt; mat = Matrix([[1, 0], [0, 2]])\n        &gt;&gt;&gt; mat.is_mat_orthogonal(verbosity=0)\n        False\n    \"\"\"\n\n    res = self.T @ self\n    if verbosity &gt;= 1:\n        print(\"self^T @ self\")\n        display(res)\n    return res.is_diagonal and all(entry == 1 for entry in res.diagonal())\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.orthogonal_decomposition","title":"<code>orthogonal_decomposition(to: Matrix, verbosity: int = 0) -&gt; VecDecomp</code>","text":"<p>Decomposes the current vector (or matrix) into its orthogonal projection onto a subspace and its orthogonal complement.</p> <p>This method computes the orthogonal decomposition of <code>self</code> relative to the subspace spanned by the columns of <code>to</code>. It finds the projection of <code>self</code> onto the subspace (<code>proj</code>) and the component orthogonal to the subspace (<code>norm</code>), such that:     <code>self = proj + norm</code></p> <p>The projection is computed using the least squares solution.</p> <p>Parameters:</p> <ul> <li> <code>to</code>               (<code>Matrix</code>)           \u2013            <p>The matrix whose columns form the subspace onto which to project <code>self</code>.</p> </li> <li> <code>verbosity</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Level of verbosity for displaying intermediate results.</p> <ul> <li>0: No output.</li> <li>1: Display the projected and normal components.</li> <li>2: Display detailed steps.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>VecDecomp</code>           \u2013            <p>A dataclass with fields:</p> <ul> <li>proj (<code>Matrix</code>): The projection of <code>self</code> onto the subspace spanned by <code>to</code>.</li> <li>norm (<code>Matrix</code>): The component of <code>self</code> orthogonal to the subspace spanned by <code>to</code>.</li> </ul> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; v = Matrix([[3], [4]])\n&gt;&gt;&gt; B = Matrix([[1], [0]])\n&gt;&gt;&gt; v.orthogonal_decomposition(B)\nVecDecomp(proj=Matrix([\n[3],\n[0]]), norm=Matrix([\n[0]\n[4]\n]))\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def orthogonal_decomposition(self, to: Matrix, verbosity: int = 0) -&gt; VecDecomp:\n    \"\"\"Decomposes the current vector (or matrix) into its orthogonal projection onto a subspace and its orthogonal complement.\n\n    This method computes the orthogonal decomposition of `self` relative to the subspace spanned by the columns of `to`.\n    It finds the projection of `self` onto the subspace (`proj`) and the component orthogonal to the subspace (`norm`), such that:\n        `self = proj + norm`\n\n    The projection is computed using the least squares solution.\n\n    Args:\n        to (Matrix): The matrix whose columns form the subspace onto which to project `self`.\n        verbosity (int, optional): Level of verbosity for displaying intermediate results.\n\n            - 0: No output.\n            - 1: Display the projected and normal components.\n            - 2: Display detailed steps.\n\n    Returns:\n        (VecDecomp): A dataclass with fields:\n\n            - proj ([`Matrix`][...]): The projection of `self` onto the subspace spanned by `to`.\n            - norm ([`Matrix`][...]): The component of `self` orthogonal to the subspace spanned by `to`.\n\n    Examples:\n        &gt;&gt;&gt; v = Matrix([[3], [4]])\n        &gt;&gt;&gt; B = Matrix([[1], [0]])\n        &gt;&gt;&gt; v.orthogonal_decomposition(B)\n        VecDecomp(proj=Matrix([\n        [3],\n        [0]]), norm=Matrix([\n        [0]\n        [4]\n        ]))\n    \"\"\"\n\n    sol = to.solve_least_squares(self, verbosity=verbosity)\n    proj = to @ sol\n    norm = self - proj\n\n    if verbosity &gt;= 1:\n        print(\"Projected component: Au\")\n        display(proj)\n        print(\"Normal component: b - b_proj\")\n        display(norm)\n\n    assert proj + norm == self\n    return VecDecomp(proj, norm)\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.proj_comp","title":"<code>proj_comp(to: Matrix, verbosity: int = 0) -&gt; Matrix</code>","text":"<p>Computes the orthogonal projection of the current vector (or matrix) onto the subspace spanned by the columns of another matrix.</p> <p>This method returns the component of <code>self</code> that lies in the subspace defined by the columns of <code>to</code>. It is equivalent to the projection of <code>self</code> onto the subspace, as computed by the orthogonal decomposition.</p> <p>Parameters:</p> <ul> <li> <code>to</code>               (<code>Matrix</code>)           \u2013            <p>The matrix whose columns form the subspace onto which to project <code>self</code>.</p> </li> <li> <code>verbosity</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Level of verbosity for displaying intermediate results.</p> <ul> <li>0: No output.</li> <li>1: Display the projected component.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>The projection of <code>self</code> onto the subspace spanned by <code>to</code>.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; v = Matrix([[3], [4]])\n&gt;&gt;&gt; B = Matrix([[1], [0]])\n&gt;&gt;&gt; v.proj_comp(B)\nMatrix([\n[3],\n[0]])\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def proj_comp(self, to: Matrix, verbosity: int = 0) -&gt; Matrix:\n    \"\"\"Computes the orthogonal projection of the current vector (or matrix) onto the subspace spanned by the columns of another matrix.\n\n    This method returns the component of `self` that lies in the subspace defined by the columns of `to`.\n    It is equivalent to the projection of `self` onto the subspace, as computed by the orthogonal decomposition.\n\n    Args:\n        to (Matrix): The matrix whose columns form the subspace onto which to project `self`.\n        verbosity (int, optional): Level of verbosity for displaying intermediate results.\n\n            - 0: No output.\n            - 1: Display the projected component.\n\n    Returns:\n        (Matrix): The projection of `self` onto the subspace spanned by `to`.\n\n    Examples:\n        &gt;&gt;&gt; v = Matrix([[3], [4]])\n        &gt;&gt;&gt; B = Matrix([[1], [0]])\n        &gt;&gt;&gt; v.proj_comp(B)\n        Matrix([\n        [3],\n        [0]])\n    \"\"\"\n\n    return self.orthogonal_decomposition(to=to, verbosity=verbosity).proj\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.norm_comp","title":"<code>norm_comp(to: Matrix, verbosity: int = 0) -&gt; Matrix</code>","text":"<p>Computes the component of the current vector (or matrix) orthogonal to the subspace spanned by the columns of another matrix.</p> <p>This method returns the part of <code>self</code> that is perpendicular to the subspace defined by the columns of <code>to</code>. It is equivalent to the normal component from the orthogonal decomposition.</p> <p>Parameters:</p> <ul> <li> <code>to</code>               (<code>Matrix</code>)           \u2013            <p>The matrix whose columns form the subspace to which the orthogonal component is computed.</p> </li> <li> <code>verbosity</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Level of verbosity for displaying intermediate results.</p> <ul> <li>0: No output (default).</li> <li>1: Display the normal component.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>The component of <code>self</code> orthogonal to the subspace spanned by <code>to</code>.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; v = Matrix([[3], [4]])\n&gt;&gt;&gt; B = Matrix([[1], [0]])\n&gt;&gt;&gt; v.norm_comp(B)\nMatrix([\n[0]\n[4]\n])\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def norm_comp(self, to: Matrix, verbosity: int = 0) -&gt; Matrix:\n    \"\"\"Computes the component of the current vector (or matrix) orthogonal to the subspace spanned by the columns of another matrix.\n\n    This method returns the part of `self` that is perpendicular to the subspace defined by the columns of `to`.\n    It is equivalent to the normal component from the orthogonal decomposition.\n\n    Args:\n        to (Matrix): The matrix whose columns form the subspace to which the orthogonal component is computed.\n        verbosity (int, optional): Level of verbosity for displaying intermediate results.\n\n            - 0: No output (default).\n            - 1: Display the normal component.\n\n    Returns:\n        (Matrix): The component of `self` orthogonal to the subspace spanned by `to`.\n\n    Examples:\n        &gt;&gt;&gt; v = Matrix([[3], [4]])\n        &gt;&gt;&gt; B = Matrix([[1], [0]])\n        &gt;&gt;&gt; v.norm_comp(B)\n        Matrix([\n        [0]\n        [4]\n        ])\n    \"\"\"\n\n    return self.orthogonal_decomposition(to=to, verbosity=verbosity).norm\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.gram_schmidt","title":"<code>gram_schmidt(factor: bool = True, verbosity: int = 1) -&gt; Matrix | ScalarFactor</code>","text":"<p>Performs Gram-Schmidt orthogonalization to convert a set of vectors (columns of the matrix) into an orthogonal set (that includes 0 vectors if any).</p> <p>Parameters:</p> <ul> <li> <code>factor</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>True</code>, the resulting orthogonal vectors will be scaled to have integer factors.</p> </li> <li> <code>verbosity</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Level of verbosity:</p> <ul> <li>0: No output.</li> <li>1: Display intermediate results for each step of the process.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>A matrix whose columns are the orthogonalized vectors.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 2], [3, 4]])\n&gt;&gt;&gt; mat.gram_schmidt(factor=False, verbosity=0)\nMatrix([\n[  sqrt(10)/10, 3*sqrt(10)/10]\n[3*sqrt(10)/10,  -sqrt(10)/10]\n])\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def gram_schmidt(\n    self, factor: bool = True, verbosity: int = 1\n) -&gt; Matrix | ScalarFactor:\n    \"\"\"Performs Gram-Schmidt orthogonalization to convert a set of vectors (columns of the matrix) into\n    an orthogonal set (that includes 0 vectors if any).\n\n    Args:\n        factor (bool): If `True`, the resulting orthogonal vectors will be scaled to have integer factors.\n        verbosity (int): Level of verbosity:\n\n            - 0: No output.\n            - 1: Display intermediate results for each step of the process.\n\n    Returns:\n        (Matrix): A matrix whose columns are the orthogonalized vectors.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[1, 2], [3, 4]])\n        &gt;&gt;&gt; mat.gram_schmidt(factor=False, verbosity=0)\n        Matrix([\n        [  sqrt(10)/10, 3*sqrt(10)/10]\n        [3*sqrt(10)/10,  -sqrt(10)/10]\n        ])\n    \"\"\"\n\n    if self.cols == 0:\n        return Matrix()\n    if verbosity &gt;= 1:\n        display(f\"v_{1} = {sym.latex(self.select_cols(0))}\", opt=\"math\")\n\n    orthogonal_set = [self.select_cols(0)]\n    for i in range(1, self.cols):\n        u = self.select_cols(i)\n        latex_eq = f\"v_{i + 1} = {sym.latex(u)}\"\n        for _, v in enumerate(orthogonal_set, start=1):\n            if v.norm() != 0:\n                latex_eq += f\"- \\\\left(\\\\frac{{{sym.latex(v.dot(u))}}}{{{sym.latex(v.dot(v))}}}\\\\right) {sym.latex(v)}\"\n                u -= (v.dot(u) / v.dot(v)) * v\n\n        if verbosity &gt;= 1:\n            disp_u = u.copy()\n            if factor:\n                scalar = sym.gcd(tuple(u))  # type: ignore\n                disp_u = sym.MatMul(scalar, u / scalar, evaluate=False)\n            latex_eq += f\" = {sym.latex(disp_u)}\"\n            display(latex_eq, opt=\"math\")\n\n        if u.norm() == 0 and (verbosity &gt;= 1):\n            warn(\n                \"Vectors are linearly dependent. Note that there is no QR factorisation\",\n                UserWarning,\n                stacklevel=2,\n            )\n        orthogonal_set.append(u)\n\n    return Matrix.from_list(orthogonal_set).normalized(factor=factor)\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.QRdecomposition","title":"<code>QRdecomposition(full: bool = False, verbosity: int = 0) -&gt; QR</code>","text":"<p>Computes the QR decomposition of the matrix. Optionally computes the full QR decomposition.</p> <p>A full QR decomposition returns an orthogonal (square) matrix <code>Q</code> and an upper triangular matrix <code>R</code> such that <code>self = Q @ R</code>. On the other hand, a reduced QR decomposition returns <code>Q</code> and <code>R</code> such that <code>self = Q @ R</code>, where <code>Q</code> has orthonormal columns.</p> <p>Parameters:</p> <ul> <li> <code>full</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, computes the full QR decomposition.</p> </li> <li> <code>verbosity</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Level of verbosity for displaying intermediate results:</p> <ul> <li>0: No output.</li> <li>1: Display intermediate results for each step of the process.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>QR</code>           \u2013            <p>A dataclass containing:</p> <ul> <li><code>Q</code> (<code>Matrix</code>): A matrix with orthonormal columns (or orthogonal matrix if full QR decomposition).</li> <li><code>R</code> (<code>Matrix</code>): An upper triangular matrix.</li> </ul> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 2], [3, 4]])\n&gt;&gt;&gt; mat.QRdecomposition()\nQR(Q=Matrix([\n[  sqrt(10)/10, 3*sqrt(10)/10]\n[3*sqrt(10)/10,  -sqrt(10)/10]\n]), R=Matrix([\n[sqrt(10), 7*sqrt(10)/5]\n[       0,   sqrt(10)/5]\n]))\n</code></pre> See Also <ul> <li>SymPy's <code>Matrix.QRdecomposition</code></li> <li><code>gram_schmidt</code> for performing the Gram-Schmidt process to find an orthogonal basis.</li> </ul> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def QRdecomposition(self, full: bool = False, verbosity: int = 0) -&gt; QR:\n    \"\"\"Computes the QR decomposition of the matrix. Optionally computes the full QR decomposition.\n\n    A full QR decomposition returns an **orthogonal (square) matrix** `Q` and an upper triangular matrix `R`\n    such that `self = Q @ R`. On the other hand, a reduced QR decomposition returns `Q` and `R` such that\n    `self = Q @ R`, where `Q` has **orthonormal columns**.\n\n    Args:\n        full (bool): If `True`, computes the full QR decomposition.\n        verbosity (int, optional): Level of verbosity for displaying intermediate results:\n\n            - 0: No output.\n            - 1: Display intermediate results for each step of the process.\n\n    Returns:\n        (QR): A dataclass containing:\n\n            - `Q` ([`Matrix`][...]): A matrix with orthonormal columns (or orthogonal matrix if full QR decomposition).\n            - `R` ([`Matrix`][...]): An upper triangular matrix.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[1, 2], [3, 4]])\n        &gt;&gt;&gt; mat.QRdecomposition()\n        QR(Q=Matrix([\n        [  sqrt(10)/10, 3*sqrt(10)/10]\n        [3*sqrt(10)/10,  -sqrt(10)/10]\n        ]), R=Matrix([\n        [sqrt(10), 7*sqrt(10)/5]\n        [       0,   sqrt(10)/5]\n        ]))\n\n    See Also:\n        - SymPy's [`Matrix.QRdecomposition`][sympy.matrices.matrixbase.MatrixBase.QRdecomposition]\n        - [`gram_schmidt`][..] for performing the Gram-Schmidt process to find an orthogonal basis.\n    \"\"\"\n    if verbosity &gt;= 1:\n        print(\"Finding orthogonal basis via Gram-Schmidt process:\")\n        Q = self.gram_schmidt(factor=False, verbosity=verbosity)\n        assert isinstance(Q, Matrix), \"Result should be a Matrix object\"\n        print(\"Q matrix:\")\n        display(Q)\n        print(\"R matrix: Q.T @ self\")\n        display(Q.T @ self)\n\n    # Modified SymPy's implementation to compute full QR decomposition if required.\n    Q, R = super().QRdecomposition()\n    if full and Q.rows != Q.cols:\n        Q = Matrix(Q)\n        Q_aug = Q.row_join(Q.elem(), aug_line=False).QRdecomposition()[0]\n        R_aug = Matrix(R.col_join(sym.zeros(Q_aug.cols - R.rows, R.cols)))\n        assert Q_aug @ R_aug == self\n        return QR(Q_aug, R_aug)\n    return QR(Q, R)\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.solve_least_squares","title":"<code>solve_least_squares(rhs: Matrix, verbosity: int = 1, matrices: int = 1, *args, **kwargs) -&gt; Matrix | PartGen</code>","text":"<p>Solves the least squares problem \\(\\min || \\mathrm{self} \\, \\mathbf{x} - \\mathrm{rhs}||^2\\).</p> <p>Uses SymPy's built-in method for least squares when the rank condition is met, otherwise uses a custom solution approach using the normal equations: \\(\\mathrm{self}^{\\top} \\mathrm{self} \\, \\mathbf{x} = \\mathrm{self}^{\\top} \\mathrm{rhs}\\)</p> <p>Parameters:</p> <ul> <li> <code>rhs</code>               (<code>Matrix</code>)           \u2013            <p>The right-hand side matrix/vector <code>b</code> in <code>Ax = b</code>.</p> </li> <li> <code>verbosity</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Level of verbosity (default is <code>1</code>):</p> <ul> <li>0: No output.</li> <li>1: Display intermediate steps.</li> </ul> </li> <li> <code>matrices</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <ul> <li>1: Returns the least squares solution matrix.</li> <li>2: Returns a <code>PartGen</code> with the part solution and general solution.</li> </ul> </li> <li> <code>*args</code>           \u2013            <p>Additional positional arguments passed to SymPy's <code>solve_least_squares</code> method.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional arguments passed to to SymPy's <code>solve_least_squares</code> method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>If <code>matrices=1</code>, returns the least squares solution matrix.</p> </li> <li> <code>PartGen</code>           \u2013            <p>If <code>matrices=2</code>, returns a <code>PartGen</code> with the part solution and general solution.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; A = Matrix([[1, 0], [0, 0]])\n&gt;&gt;&gt; b = Matrix([1, 2])\n&gt;&gt;&gt; A.solve_least_squares(b, verbosity=0, matrices=1)\n... # in this case, least squares solution is not unique,\n... # so it returns a general solution.\nException Encountered: Matrix must be non-singular.\nAttempting custom solve...\nMatrix([\n[1]\n[y]\n])\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def solve_least_squares(\n    self, rhs: Matrix, verbosity: int = 1, matrices: int = 1, *args, **kwargs\n) -&gt; Matrix | PartGen:\n    r\"\"\"Solves the least squares problem $\\min || \\mathrm{self} \\, \\mathbf{x} - \\mathrm{rhs}||^2$.\n\n    Uses SymPy's built-in method for least squares when the rank condition is met, otherwise uses a custom\n    solution approach using the normal equations: $\\mathrm{self}^{\\top} \\mathrm{self} \\, \\mathbf{x} = \\mathrm{self}^{\\top} \\mathrm{rhs}$\n\n    Args:\n        rhs (Matrix): The right-hand side matrix/vector `b` in `Ax = b`.\n        verbosity (int, optional): Level of verbosity (default is `1`):\n\n            - 0: No output.\n            - 1: Display intermediate steps.\n        matrices (int, optional):\n\n            - 1: Returns the least squares solution matrix.\n            - 2: Returns a [`PartGen`][(p).] with the part solution and general solution.\n        *args: Additional positional arguments passed to SymPy's\n            [`solve_least_squares`][sympy.matrices.matrixbase.MatrixBase.solve_least_squares] method.\n        **kwargs: Additional arguments passed to to SymPy's\n            [`solve_least_squares`][sympy.matrices.matrixbase.MatrixBase.solve_least_squares] method.\n\n    Returns:\n        (Matrix): If `matrices=1`, returns the least squares solution matrix.\n        (PartGen): If `matrices=2`, returns a [`PartGen`][(p).] with the part solution and general solution.\n\n    Examples:\n        &gt;&gt;&gt; A = Matrix([[1, 0], [0, 0]])\n        &gt;&gt;&gt; b = Matrix([1, 2])\n        &gt;&gt;&gt; A.solve_least_squares(b, verbosity=0, matrices=1)\n        ... # in this case, least squares solution is not unique,\n        ... # so it returns a general solution.\n        Exception Encountered: Matrix must be non-singular.\n        Attempting custom solve...\n        Matrix([\n        [1]\n        [y]\n        ])\n    \"\"\"\n\n    if verbosity == 0:\n        try:\n            A, b = sym.Matrix(self), sym.Matrix(rhs)\n            return A.solve_least_squares(rhs=b, *args, **kwargs)\n        except Exception as e:\n            print(f\"Exception Encountered: {str(e)}\")\n            print(\"Attempting custom solve...\")\n\n    ATA, ATb = self.T @ self, self.T @ rhs\n    if ATA.det() != 0 and verbosity &gt;= 1:\n        print(\"self.T @ self is invertible. The lest squares solution is unique.\")\n        display(\n            \"\\\\mathbf{x} = \\\\left(\\\\mathbf{A}^\\\\top \\\\mathbf{A}\\\\right)^{-1} \\\\mathbf{A}^\\\\top \\\\mathbf{b}\",\n            opt=\"math\",\n        )\n        x = ATA.inv() @ ATb\n        display(x)\n        return x\n\n    # Custom solve using sympy's solve method\n    sol = Matrix.create_unk_matrix(ATb.rows, 1)\n    sol = sol.subs(sym.solve(ATA @ sol - ATb, dict=True)[0])\n\n    if verbosity &gt;= 1:\n        print(\"Before RREF: [self.T @ self | self.T @ rhs]\")\n        aug_matrix = ATA.copy().row_join(ATb)\n        display(aug_matrix)\n        print(\"\\nAfter RREF\")\n        display(aug_matrix.rref())\n\n    if matrices == 1:\n        return sol\n    else:\n        return sol.sep_part_gen()\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.create_vander","title":"<code>create_vander(num_rows: int = 1, num_cols: int = 1, symbol: str = 'x', is_real: bool = True) -&gt; Matrix</code>  <code>staticmethod</code>","text":"<p>Creates a Vandermonde matrix with symbolic entries.</p> <p>This method generates a Vandermonde matrix of size <code>num_rows</code> x <code>num_cols</code> where the entries are symbolic expressions. Each row in the matrix is formed by raising a symbolic variable (indexed by row) to increasing powers (from 0 to <code>num_cols-1</code>). The <code>is_real</code> flag determines whether the symbols are real-valued.</p> <p>Parameters:</p> <ul> <li> <code>num_rows</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The number of rows in the Vandermonde matrix.</p> </li> <li> <code>num_cols</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The number of columns in the Vandermonde matrix.</p> </li> <li> <code>symbol</code>               (<code>str</code>, default:                   <code>'x'</code> )           \u2013            <p>The base name for the symbols used in the matrix entries.</p> </li> <li> <code>is_real</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True (default), the symbols are real-valued; otherwise, they are complex.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>A Vandermonde matrix with symbolic entries.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; Matrix.create_vander(2, 4, symbol='a')\nMatrix([\n[1, a_1, a_1**2, a_1**3]\n[1, a_2, a_2**2, a_2**3]\n])\n</code></pre> See Also <ul> <li><code>apply_vander</code> for applying the Vandermonde transformation to a matrix.</li> </ul> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>@staticmethod\ndef create_vander(\n    num_rows: int = 1, num_cols: int = 1, symbol: str = \"x\", is_real: bool = True\n) -&gt; Matrix:\n    \"\"\"Creates a Vandermonde matrix with symbolic entries.\n\n    This method generates a Vandermonde matrix of size `num_rows` x `num_cols`\n    where the entries are symbolic expressions. Each row in the matrix is formed\n    by raising a symbolic variable (indexed by row) to increasing powers (from 0\n    to `num_cols-1`). The `is_real` flag determines whether the symbols are real-valued.\n\n    Args:\n        num_rows (int, optional): The number of rows in the Vandermonde matrix.\n        num_cols (int, optional): The number of columns in the Vandermonde matrix.\n        symbol (str, optional): The base name for the symbols used in the matrix entries.\n        is_real (bool, optional): If True (default), the symbols are real-valued;\n            otherwise, they are complex.\n\n    Returns:\n        (Matrix): A Vandermonde matrix with symbolic entries.\n\n    Examples:\n        &gt;&gt;&gt; Matrix.create_vander(2, 4, symbol='a')\n        Matrix([\n        [1, a_1, a_1**2, a_1**3]\n        [1, a_2, a_2**2, a_2**3]\n        ])\n\n    See Also:\n        - [`apply_vander`][..] for applying the Vandermonde transformation to a matrix.\n    \"\"\"\n\n    entries = sym.symbols(f\"{symbol}_(1:{num_rows + 1})\", is_real=is_real)\n    res = []\n    for entry in entries:\n        sub_res = []\n        for col_idx in range(num_cols):\n            # Raise the symbol to the power of the column index\n            sub_res.append(sym.Pow(entry, col_idx))\n        res.append(sub_res)\n    return Matrix(res)\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.apply_vander","title":"<code>apply_vander(x: Matrix) -&gt; Matrix</code>","text":"<p>Applies a Vandermonde transformation to the current matrix using the given vector.</p> <p>This method applies a Vandermonde transformation to the current matrix by substituting the free symbols in the last column with corresponding values from the provided vector <code>x</code>. The number of rows in <code>self</code> must match the number of elements in <code>x</code>, and <code>x</code> must be a column vector.</p> Note <ul> <li>The matrix <code>self</code> is expected to be created via <code>Matrix.create_vander()</code>.</li> <li>The <code>x</code> vector provides the values to substitute in place of these symbols.</li> </ul> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>Matrix</code>)           \u2013            <p>A column vector (Matrix object with a single column) containing the values to substitute into the last column of the matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>A new Matrix object where the free symbols in the last column of the original matrix are substituted by the corresponding values from <code>x</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ShapeError</code>             \u2013            <p>If <code>x</code> is not a column vector or if the number of rows in <code>self</code> does not match the size of <code>x</code>.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix.create_vander(2, 2)\n&gt;&gt;&gt; x = Matrix([1, 2])\n&gt;&gt;&gt; mat.apply_vander(x)\nMatrix([\n[1, 1]\n[1, 2]\n])\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def apply_vander(self, x: Matrix) -&gt; Matrix:\n    \"\"\"\n    Applies a Vandermonde transformation to the current matrix using the given vector.\n\n    This method applies a Vandermonde transformation to the current matrix by\n    substituting the free symbols in the last column with corresponding values\n    from the provided vector `x`. The number of rows in `self` must match the\n    number of elements in `x`, and `x` must be a column vector.\n\n    Note:\n        - The matrix `self` is expected to be created via [`Matrix.create_vander()`][..create_vander].\n        - The `x` vector provides the values to substitute in place of these symbols.\n\n    Args:\n        x (Matrix): A column vector (Matrix object with a single column) containing\n            the values to substitute into the last column of the matrix.\n\n    Returns:\n        (Matrix): A new Matrix object where the free symbols in the last column of\n            the original matrix are substituted by the corresponding values from `x`.\n\n    Raises:\n        sympy.matrices.exceptions.ShapeError: If `x` is not a column vector or if\n            the number of rows in `self` does not match the size of `x`.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix.create_vander(2, 2)\n        &gt;&gt;&gt; x = Matrix([1, 2])\n        &gt;&gt;&gt; mat.apply_vander(x)\n        Matrix([\n        [1, 1]\n        [1, 2]\n        ])\n    \"\"\"\n    # Validate the size of the vector x\n    if x.cols != 1:\n        raise sym.ShapeError(\n            f\"Input vector x must be a column vector. ({self.cols})\"\n        )\n    if self.rows != x.rows:\n        raise sym.ShapeError(\n            f\"Number of rows in matrix ({self.rows}) must match the size of the input vector ({x.rows})\"\n        )\n\n    # Get the free symbols from the last column of the matrix\n    ordered_syms = [entry.free_symbols.pop() for entry in self.select_cols(-1)]  # type: ignore\n\n    # Create a substitution dictionary mapping symbols to values from vector x\n    substitution = {var: val for var, val in zip(ordered_syms, x)}  # type: ignore\n    return self.subs(substitution)\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.cpoly","title":"<code>cpoly(force_factor: bool = True) -&gt; Mul | tuple[Mul, Mul]</code>","text":"<p>Computes the characteristic polynomial of the matrix and attempts to factor it into real and complex parts.</p> <p>The characteristic polynomial is defined as <code>det(x * I - self)</code>, where <code>I</code> is the identity matrix of the same size as <code>self</code>.</p> <p>Parameters:</p> <ul> <li> <code>force_factor</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>True</code>, the polynomial is fully factored, even if it doesn't have real factors. If <code>False</code>, the polynomial is returned in its factored form if possible.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Mul</code>           \u2013            <p>If the polynomial factors only into real terms, returns a single factored polynomial.</p> </li> <li> <code>tuple[Mul, Mul]</code>           \u2013            <p>If the polynomial has both real and complex factors, returns a tuple of two polynomials one with real factors and the other with complex factors.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[-1, 0], [0, 4]])\n&gt;&gt;&gt; mat.cpoly()\n(x - 4)*(x + 1)\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def cpoly(self, force_factor: bool = True) -&gt; Mul | tuple[Mul, Mul]:\n    \"\"\"Computes the characteristic polynomial of the matrix and attempts to factor it into real and complex parts.\n\n    The characteristic polynomial is defined as `det(x * I - self)`, where `I` is the identity matrix of the same size as `self`.\n\n    Args:\n        force_factor (bool): If `True`, the polynomial is fully factored, even if it doesn't have real factors.\n            If `False`, the polynomial is returned in its factored form if possible.\n\n    Returns:\n        (Mul): If the polynomial factors only into real terms, returns a single factored polynomial.\n        (tuple[Mul, Mul]): If the polynomial has both real and complex factors, returns a tuple of two polynomials\n            one with real factors and the other with complex factors.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[-1, 0], [0, 4]])\n        &gt;&gt;&gt; mat.cpoly()\n        (x - 4)*(x + 1)\n    \"\"\"\n    x = sym.symbols(\"x\", real=True)\n    poly = (x * self.elem() - self).det()\n    if not force_factor:\n        return poly.factor()\n    # Attempt to factor poly into real factors\n    try:\n        roots = sym.roots(\n            poly\n        )  # TODO: FIX sym.roots NotImplementedError for multi variable\n        real_fact = []\n        for root, mult in roots.items():\n            term = x - root\n            if mult != 1:\n                term = sym.Pow(term, mult, evaluate=False)\n            if root.is_real:\n                real_fact.append(term)\n                poly /= term\n\n        linear_fact = Mul(*real_fact, evaluate=False)\n        complex_fact = poly.expand().cancel().factor()\n\n        if complex_fact == 1:\n            return linear_fact  # type: ignore\n        else:\n            return linear_fact, complex_fact  # type: ignore\n    except Exception as error:\n        print(f\"Encountered Error: {error}\")\n        return poly.factor()\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.is_diagonalizable","title":"<code>is_diagonalizable(reals_only: bool = True, verbosity: int = 1, *args, **kwargs) -&gt; bool</code>","text":"<p>Checks if the matrix is diagonalizable, with the option to focus only on real eigenvalues.</p> <p>A matrix is diagonalizable if it has enough linearly independent eigenvectors to form a basis for the space.</p> <p>Parameters:</p> <ul> <li> <code>reals_only</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, diagonalization will focus on real eigenvalues.</p> </li> <li> <code>verbosity</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Controls the level of output during the diagonalization process.</p> <ul> <li>0: No output.</li> <li>1: Displays the characteristic polynomial, eigenvalues, algebraic multiplicities, and eigenspaces.</li> </ul> </li> <li> <code>*args</code>           \u2013            <p>Additional positional arguments passed to SymPy's <code>is_diagonalizable</code> method.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional arguments passed to SymPy's <code>is_diagonalizable</code> method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the matrix is diagonalizable, False otherwise.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 2, 0], [0, 3, 0], [2, -4, 2]])\n&gt;&gt;&gt; mat.is_diagonalizable(reals_only=True, verbosity=0)\nTrue\n</code></pre> See Also <ul> <li>SymPy's <code>Matrix.is_diagonalizable</code></li> <li>Sympy's <code>Matrix.eigenvects</code> for computing eigenvalues and their multiplicities.</li> <li><code>diagonalize</code> for diagonalizing the matrix.</li> </ul> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def is_diagonalizable(\n    self, reals_only: bool = True, verbosity: int = 1, *args, **kwargs\n) -&gt; bool:\n    \"\"\"Checks if the matrix is diagonalizable, with the option to focus only on real eigenvalues.\n\n    A matrix is diagonalizable if it has enough linearly independent eigenvectors to form a basis for the space.\n\n    Args:\n        reals_only (bool, optional): If True, diagonalization will focus on real eigenvalues.\n        verbosity (int, optional): Controls the level of output during the diagonalization process.\n\n            - 0: No output.\n            - 1: Displays the characteristic polynomial, eigenvalues, algebraic multiplicities, and eigenspaces.\n\n        *args: Additional positional arguments passed to SymPy's\n            [`is_diagonalizable`][sympy.matrices.matrixbase.MatrixBase.is_diagonalizable] method.\n        **kwargs: Additional arguments passed to SymPy's\n            [`is_diagonalizable`][sympy.matrices.matrixbase.MatrixBase.is_diagonalizable] method.\n\n    Returns:\n        (bool): True if the matrix is diagonalizable, False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[1, 2, 0], [0, 3, 0], [2, -4, 2]])\n        &gt;&gt;&gt; mat.is_diagonalizable(reals_only=True, verbosity=0)\n        True\n\n    See Also:\n        - SymPy's [`Matrix.is_diagonalizable`][sympy.matrices.matrixbase.MatrixBase.is_diagonalizable]\n        - Sympy's [`Matrix.eigenvects`][sympy.matrices.matrixbase.MatrixBase.eigenvects] for computing eigenvalues and their multiplicities.\n        - [`diagonalize`][..] for diagonalizing the matrix.\n    \"\"\"\n\n    # Changed default for reals_only to True to align with MA1522 syllabus\n    if verbosity &gt;= 1:\n        print(\"Characteristic Polynomial is: \")\n        display(self.cpoly())\n        print(\"\\nCheck if algebraic multiplicity equals number of eigenvectors.\\n\")\n        print(\"Eigenvectors are:\")\n        for val, mult, space in self.eigenvects():\n            if (val.is_real and reals_only) or not reals_only:\n                res = {\n                    \"eigenvalue\": val,\n                    \"algebraic multiplicity\": mult,\n                    \"eigenspace\": Matrix.from_list(space),\n                }\n                display(res, opt=\"dict\")\n\n    return super().is_diagonalizable(reals_only, *args, **kwargs)\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.eigenvects_associated","title":"<code>eigenvects_associated(eigenvalue: Expr | int | float) -&gt; list[Matrix] | None</code>","text":"<p>Computes the eigenvectors associated with a given eigenvalue.</p> <p>This method finds all (nonzero) vectors <code>v</code> such that <code>(eigenvalue * I - self) * v = 0</code> where <code>I</code> is the identity matrix of the same size as <code>self</code>.</p> <p>Parameters:</p> <ul> <li> <code>eigenvalue</code>               (<code>Expr | int | float</code>)           \u2013            <p>The eigenvalue for which to compute the associated eigenvectors.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Matrix]</code>           \u2013            <p>A list of eigenvectors (as Matrix objects) associated with the given eigenvalue,</p> </li> <li> <code>None</code>           \u2013            <p>If the eigenvalue does not correspond to any eigenvectors.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[2, 0], [0, 3]])\n&gt;&gt;&gt; mat.eigenvects_associated(2)\n[Matrix([\n[1],\n[0]])]\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def eigenvects_associated(\n    self, eigenvalue: Expr | int | float\n) -&gt; list[Matrix] | None:\n    \"\"\"Computes the eigenvectors associated with a given eigenvalue.\n\n    This method finds all (nonzero) vectors `v` such that `(eigenvalue * I - self) * v = 0`\n    where `I` is the identity matrix of the same size as `self`.\n\n    Args:\n        eigenvalue (Expr | int | float): The eigenvalue for which to compute the associated eigenvectors.\n\n    Returns:\n        (list[Matrix]): A list of eigenvectors (as Matrix objects) associated with the given eigenvalue,\n        (None): If the eigenvalue does not correspond to any eigenvectors.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[2, 0], [0, 3]])\n        &gt;&gt;&gt; mat.eigenvects_associated(2)\n        [Matrix([\n        [1],\n        [0]])]\n    \"\"\"\n    return (eigenvalue * self.elem() - self).nullspace()\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.diagonalize","title":"<code>diagonalize(reals_only: bool = True, verbosity: int = 0, *args, **kwargs) -&gt; PDP</code>","text":"<p>Diagonalizes the matrix if possible, focusing on real eigenvalues unless specified otherwise.</p> <p>Parameters:</p> <ul> <li> <code>reals_only</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>True</code>, diagonalization will focus on real eigenvalues.</p> </li> <li> <code>verbosity</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Controls the level of output during the diagonalization process.</p> <ul> <li>0: No output.</li> <li>1: Displays the characteristic polynomial and eigenvectors.</li> </ul> </li> <li> <code>*args</code>           \u2013            <p>Additional positional arguments passed to SymPy's <code>diagonalize</code> method.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional arguments passed to SymPy's <code>diagonalize</code> method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PDP</code>           \u2013            <p>A dataclass containing:</p> <ul> <li><code>P</code> (<code>Matrix</code>): The matrix of eigenvectors.</li> <li><code>D</code> (<code>Matrix</code>): The diagonal matrix of eigenvalues.</li> </ul> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 2], [3, 4]])\n&gt;&gt;&gt; mat.diagonalize()\nPDP(P=Matrix([\n[-sqrt(33)/6 - 1/2, -1/2 + sqrt(33)/6]\n[                1,                 1]\n]), D=Matrix([\n[5/2 - sqrt(33)/2,                0]\n[               0, 5/2 + sqrt(33)/2]\n]))\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def diagonalize(\n    self, reals_only: bool = True, verbosity: int = 0, *args, **kwargs\n) -&gt; PDP:\n    \"\"\"Diagonalizes the matrix if possible, focusing on real eigenvalues unless specified otherwise.\n\n    Args:\n        reals_only (bool, optional): If `True`, diagonalization will focus on real eigenvalues.\n        verbosity (int, optional): Controls the level of output during the diagonalization process.\n\n            - 0: No output.\n            - 1: Displays the characteristic polynomial and eigenvectors.\n        *args: Additional positional arguments passed to SymPy's\n            [`diagonalize`][sympy.matrices.matrixbase.MatrixBase.diagonalize] method.\n        **kwargs: Additional arguments passed to SymPy's\n            [`diagonalize`][sympy.matrices.matrixbase.MatrixBase.diagonalize] method.\n\n    Returns:\n        (PDP): A dataclass containing:\n\n            - `P` ([`Matrix`][...]): The matrix of eigenvectors.\n            - `D` ([`Matrix`][...]): The diagonal matrix of eigenvalues.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[1, 2], [3, 4]])\n        &gt;&gt;&gt; mat.diagonalize()\n        PDP(P=Matrix([\n        [-sqrt(33)/6 - 1/2, -1/2 + sqrt(33)/6]\n        [                1,                 1]\n        ]), D=Matrix([\n        [5/2 - sqrt(33)/2,                0]\n        [               0, 5/2 + sqrt(33)/2]\n        ]))\n    \"\"\"\n\n    # Changed default for reals_only to True to align with MA1522 syllabus\n    if verbosity &gt;= 1:\n        print(\"Characteristic Polynomial\")\n        poly = self.cpoly()\n        display(poly)\n        for root, _ in sym.roots(poly).items():\n            if root.is_real:\n                display(\n                    _textify(\"Before RREF: \")\n                    + sym.latex(root)\n                    + r\"\\mathbb{I} - \\mathrm{self}\",\n                    opt=\"math\",\n                )\n                expr = root * self.elem() - self\n                display(expr)\n\n                print(\"\\nAfter RREF:\")\n                display(expr.rref())\n\n                print(\"\\nEigenvectors:\")\n                display(expr.nullspace())\n                print(\"\\n\")\n\n    P, D = super().diagonalize(reals_only, *args, **kwargs)\n    P.rm_aug_line()  # Remove augmented line if exists\n    return PDP(P, D)\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.is_orthogonally_diagonalizable","title":"<code>is_orthogonally_diagonalizable(verbosity: int = 2) -&gt; bool</code>","text":"<p>Determines whether the matrix is orthogonally diagonalizable.</p> <p>A matrix is orthogonally diagonalizable if and only if it is symmetric. This method checks the symmetry of the matrix and optionally displays diagnostic information based on the verbosity level.</p> <p>Parameters:</p> <ul> <li> <code>verbosity</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>Level of diagnostic output.</p> <ul> <li>0: No output.</li> <li>1: Displays the matrix.</li> <li>2: Displays the result of the symmetry check.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the matrix is symmetric (orthogonally diagonalizable), False otherwise.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 2], [2, 1]])\n&gt;&gt;&gt; mat.is_orthogonally_diagonalizable(verbosity=0)\nTrue\n</code></pre> See Also <ul> <li>SymPy's <code>Matrix.is_symmetric</code></li> </ul> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def is_orthogonally_diagonalizable(self, verbosity: int = 2) -&gt; bool:\n    \"\"\"Determines whether the matrix is orthogonally diagonalizable.\n\n    A matrix is orthogonally diagonalizable if and only if it is symmetric.\n    This method checks the symmetry of the matrix and optionally displays\n    diagnostic information based on the verbosity level.\n\n    Args:\n        verbosity (int, optional): Level of diagnostic output.\n\n            - 0: No output.\n            - 1: Displays the matrix.\n            - 2: Displays the result of the symmetry check.\n\n    Returns:\n        (bool): True if the matrix is symmetric (orthogonally diagonalizable), False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[1, 2], [2, 1]])\n        &gt;&gt;&gt; mat.is_orthogonally_diagonalizable(verbosity=0)\n        True\n\n    See Also:\n        - SymPy's [`Matrix.is_symmetric`][sympy.matrices.matrixbase.MatrixBase.is_symmetric]\n\n    \"\"\"\n    if verbosity:\n        print(f\"Check if matrix is symmetric: {self.is_symmetric()}\")\n    if verbosity &gt;= 2:\n        print(\"\\nCheck if self == self^T:\")\n        display(self == self.T)\n    return self.is_symmetric()\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.orthogonally_diagonalize","title":"<code>orthogonally_diagonalize(reals_only: bool = True, factor: bool = True, verbosity=1, *args, **kwargs) -&gt; PDP</code>","text":"<p>Orthogonally diagonalizes the matrix, ensuring that eigenvectors corresponding to different eigenvalues are orthogonal.</p> <p>Parameters:</p> <ul> <li> <code>reals_only</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, only real eigenvalues are considered.</p> </li> <li> <code>factor</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the eigenvectors are orthogonalized using the Gram-Schmidt process.</p> </li> <li> <code>verbosity</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Controls the verbosity of output during the process.</p> </li> <li> <code>*args</code>           \u2013            <p>Additional positional arguments passed to the <code>diagonalize</code> method.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional arguments passed to the <code>diagonalize</code> method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PDP</code>           \u2013            <p>A dataclass containing:</p> <ul> <li><code>P</code> (<code>Matrix</code>): The orthogonal matrix of eigenvectors.</li> <li><code>D</code> (<code>Matrix</code>): The diagonal matrix of eigenvalues.</li> </ul> </li> </ul> <p>Raises:</p> <ul> <li> <code>AssertionError</code>             \u2013            <p>If the matrix is not orthogonally diagonalizable (i.e., not symmetric).</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1, 2], [2, 1]])\n&gt;&gt;&gt; mat.orthogonally_diagonalize(factor=False, verbosity=0)\nPDP(P=Matrix([\n[-sqrt(2)/2, sqrt(2)/2]\n[ sqrt(2)/2, sqrt(2)/2]\n]), D=Matrix([\n[-1, 0]\n[ 0, 3]\n]))\n</code></pre> See Also <ul> <li><code>is_orthogonally_diagonalizable</code> to check if the matrix is orthogonally diagonalizable.</li> <li><code>diagonalize</code> for diagonalizing the matrix.</li> </ul> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def orthogonally_diagonalize(\n    self, reals_only: bool = True, factor: bool = True, verbosity=1, *args, **kwargs\n) -&gt; PDP:\n    \"\"\"Orthogonally diagonalizes the matrix, ensuring that eigenvectors corresponding to different eigenvalues are orthogonal.\n\n    Args:\n        reals_only (bool): If True, only real eigenvalues are considered.\n        factor (bool): If True, the eigenvectors are orthogonalized using the Gram-Schmidt process.\n        verbosity (int): Controls the verbosity of output during the process.\n        *args: Additional positional arguments passed to the [`diagonalize`][..] method.\n        **kwargs: Additional arguments passed to the [`diagonalize`][..] method.\n\n    Returns:\n        (PDP): A dataclass containing:\n\n            - `P` ([`Matrix`][...]): The orthogonal matrix of eigenvectors.\n            - `D` ([`Matrix`][...]): The diagonal matrix of eigenvalues.\n\n    Raises:\n        AssertionError: If the matrix is not orthogonally diagonalizable (i.e., not symmetric).\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[1, 2], [2, 1]])\n        &gt;&gt;&gt; mat.orthogonally_diagonalize(factor=False, verbosity=0)\n        PDP(P=Matrix([\n        [-sqrt(2)/2, sqrt(2)/2]\n        [ sqrt(2)/2, sqrt(2)/2]\n        ]), D=Matrix([\n        [-1, 0]\n        [ 0, 3]\n        ]))\n\n    See Also:\n        - [`is_orthogonally_diagonalizable`][..] to check if the matrix is orthogonally diagonalizable.\n        - [`diagonalize`][..] for diagonalizing the matrix.\n    \"\"\"\n\n    # Changed default for reals_only to True to align with MA1522 syllabus\n    # Note that you can just apply GSP on P directly, since eigenspace associated to different eigenvalues are orthogonal\n    # However, we follow the steps given in MA1522 syllabus here\n    assert self.is_orthogonally_diagonalizable(verbosity=verbosity)\n    # P, D = super().diagonalize(reals_only, *args, **kwargs)\n    P, D = self.diagonalize(\n        reals_only=reals_only, verbosity=verbosity, *args, **kwargs\n    )\n\n    d: DefaultDict[Expr, list[Matrix]] = defaultdict(list)\n    for vec, val in zip(P.columnspace(), D.diagonal()):\n        d[val].append(vec)\n\n    result = []\n    for val, vecs in d.items():\n        if len(vecs) &gt; 1:\n            # Require Gram Schmidt to ensure eigenvectors are orthogonal\n            if verbosity &gt;= 1:\n                print(\"Eigenvalue: \", val)\n                print(\"[Gram Schmidt Process]\")\n            if factor:\n                gram_result = Matrix.from_list(vecs).gram_schmidt(\n                    factor=True, verbosity=verbosity\n                )\n                if isinstance(gram_result, ScalarFactor):\n                    result.append(gram_result.eval())\n                elif isinstance(gram_result, Matrix):\n                    result.append(gram_result)\n                else:\n                    raise TypeError(\n                        f\"Unexpected return type from gram_schmidt: {type(gram_result)}\"\n                    )\n            else:\n                result.append(\n                    Matrix.from_list(vecs).gram_schmidt(factor, verbosity)\n                )\n        else:\n            result.append(vecs[0].normalized())\n\n    if len(result) == 0:\n        ortho_P = P\n    else:\n        ortho_P = result[0]\n        for m in result[1:]:\n            ortho_P = ortho_P.row_join(m, aug_line=False)\n\n    assert (ortho_P @ D @ ortho_P.T - self).norm() == 0\n    return PDP(ortho_P, D)\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.is_stochastic","title":"<code>is_stochastic(verbosity: int = 1) -&gt; bool</code>","text":"<p>Checks if the matrix is stochastic.</p> <p>A matrix is stochastic if all its entries are non-negative and each column sums to 1. This property is commonly used to identify transition matrices in Markov chains.</p> <p>Parameters:</p> <ul> <li> <code>verbosity</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Level of diagnostic output.</p> <ul> <li>0: No output.</li> <li>1: Displays the result of the checks.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the matrix is stochastic, False otherwise.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[0.5, 0.1], [0.5, 0.9]])\n&gt;&gt;&gt; mat.simplify(rational=True) # Convert floats to symbolic fractions\n&gt;&gt;&gt; mat.is_stochastic(verbosity=0)\nTrue\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[1.1, 1], [-0.1, 0]])\n&gt;&gt;&gt; mat.is_stochastic(verbosity=0)\nFalse\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def is_stochastic(self, verbosity: int = 1) -&gt; bool:\n    \"\"\"Checks if the matrix is stochastic.\n\n    A matrix is stochastic if all its entries are non-negative and each column sums to 1.\n    This property is commonly used to identify transition matrices in Markov chains.\n\n    Args:\n        verbosity (int, optional): Level of diagnostic output.\n\n            - 0: No output.\n            - 1: Displays the result of the checks.\n\n    Returns:\n        (bool): True if the matrix is stochastic, False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[0.5, 0.1], [0.5, 0.9]])\n        &gt;&gt;&gt; mat.simplify(rational=True) # Convert floats to symbolic fractions\n        &gt;&gt;&gt; mat.is_stochastic(verbosity=0)\n        True\n\n        &gt;&gt;&gt; mat = Matrix([[1.1, 1], [-0.1, 0]])\n        &gt;&gt;&gt; mat.is_stochastic(verbosity=0)\n        False\n    \"\"\"\n    is_square = self.rows == self.cols\n    is_non_negative = all(entry &gt;= 0 for entry in self.flat())\n    is_prob_vectors = all(sum(self[:, i]) == 1 for i in range(self.cols))  # type: ignore\n    if verbosity &gt;= 1:\n        print(f\"Check if matrix is square: {is_square}\")\n        print(f\"Check if all entries are non-negative: {is_non_negative}\")\n        print(f\"Check if each column sums to 1: {is_prob_vectors}\")\n    return is_square and is_non_negative and is_prob_vectors\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.equilibrium_vectors","title":"<code>equilibrium_vectors() -&gt; Matrix</code>","text":"<p>Computes the equilibrium vectors of the matrix, i.e., the nullspace of (I - A).</p> Note <ul> <li>A matrix <code>P</code> has a unique equilibrium vector if it is stochastic and     there exists some positive integer <code>k</code> such that <code>P^k</code> only has positive entries.</li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>A matrix containing equilibrium vectors normalized so that their column sums to 1.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[0.1, 0.9], [0.9, 0.1]])\n&gt;&gt;&gt; mat.simplify()\n&gt;&gt;&gt; mat.equilibrium_vectors()\nMatrix([\n[1/2]\n[1/2]\n])\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def equilibrium_vectors(self) -&gt; Matrix:\n    \"\"\"Computes the equilibrium vectors of the matrix, i.e., the nullspace of (I - A).\n\n    Note:\n        - A matrix `P` has a unique equilibrium vector if it is stochastic and\n            there exists some positive integer `k` such that `P^k` only has positive entries.\n\n    Returns:\n        (Matrix): A matrix containing equilibrium vectors normalized so that their\n            column sums to 1.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[0.1, 0.9], [0.9, 0.1]])\n        &gt;&gt;&gt; mat.simplify()\n        &gt;&gt;&gt; mat.equilibrium_vectors()\n        Matrix([\n        [1/2]\n        [1/2]\n        ])\n    \"\"\"\n\n    P = Matrix.from_list((self.elem() - self).nullspace())\n    for i in range(P.cols):\n        if sum(P[:, i]) != 0:  # type: ignore\n            P[:, i] /= sum(P[:, i])  # type: ignore\n    return P\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.singular_value_decomposition","title":"<code>singular_value_decomposition(verbosity: int = 0, tol: float = 0.0, verify: bool = True) -&gt; SVD</code>","text":"<p>Performs Singular Value Decomposition (SVD) on the matrix, following the MA1522 syllabus.</p> Note <ul> <li>This function is known to take too much time and may kill Jupyter's kernel. Please use it with caution.     A workaround is to set <code>verify=False</code> to skip the verification step, or use the faster numerical SVD     method <code>fast_svd</code> instead.</li> </ul> <p>Parameters:</p> <ul> <li> <code>verbosity</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Controls the verbosity of the output.</p> <ul> <li>0: No output.</li> <li>1: Displays intermediate steps and results of the SVD process.</li> </ul> </li> <li> <code>tol</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Tolerance for verification of the SVD result.</p> </li> <li> <code>verify</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>True</code>, verifies the result of the SVD by checking if <code>self = U @ S @ V.T</code>. If <code>False</code>, skips the verification step for performance reasons.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SVD</code>           \u2013            <p>A dataclass containing:</p> <ul> <li><code>U</code> (<code>Matrix</code>): The left singular vectors.</li> <li><code>S</code> (<code>Matrix</code>): The diagonal matrix of singular values.</li> <li><code>V</code> (<code>Matrix</code>): The right singular vectors.</li> </ul> <p>Such that <code>self = U @ S @ V.T</code>.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[3, 2, 2], [2, 3, -2]])\n&gt;&gt;&gt; mat.singular_value_decomposition(verbosity=0, verify=False)\nSVD(U=Matrix([\n[sqrt(2)/2, -sqrt(2)/2]\n[sqrt(2)/2,  sqrt(2)/2]\n]), S=Matrix([\n[5, 0, 0]\n[0, 3, 0]\n]), V=Matrix([\n[sqrt(2)/2,   -sqrt(2)/6,  2/3]\n[sqrt(2)/2,    sqrt(2)/6, -2/3]\n[        0, -2*sqrt(2)/3, -1/3]\n]))\n</code></pre> See Also <ul> <li><code>fast_svd</code> for a faster numerical SVD</li> <li>SymPy's <code>Matrix.singular_value_decomposition</code></li> </ul> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def singular_value_decomposition(\n    self, verbosity: int = 0, tol: float = 0.0, verify: bool = True\n) -&gt; SVD:\n    \"\"\"Performs Singular Value Decomposition (SVD) on the matrix, following the MA1522 syllabus.\n\n    Note:\n        - This function is known to take too much time and may kill Jupyter's kernel. Please use it with caution.\n            A workaround is to set `verify=False` to skip the verification step, or use the faster numerical SVD\n            method [`fast_svd`][..fast_svd] instead.\n\n    Args:\n        verbosity (int, optional): Controls the verbosity of the output.\n\n            - 0: No output.\n            - 1: Displays intermediate steps and results of the SVD process.\n        tol (float, optional): Tolerance for verification of the SVD result.\n        verify (bool): If `True`, verifies the result of the SVD by checking if `self = U @ S @ V.T`.\n            If `False`, skips the verification step for performance reasons.\n\n    Returns:\n        (SVD): A dataclass containing:\n\n            - `U` ([`Matrix`][...]): The left singular vectors.\n            - `S` ([`Matrix`][...]): The diagonal matrix of singular values.\n            - `V` ([`Matrix`][...]): The right singular vectors.\n\n            Such that `self = U @ S @ V.T`.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[3, 2, 2], [2, 3, -2]])\n        &gt;&gt;&gt; mat.singular_value_decomposition(verbosity=0, verify=False)\n        SVD(U=Matrix([\n        [sqrt(2)/2, -sqrt(2)/2]\n        [sqrt(2)/2,  sqrt(2)/2]\n        ]), S=Matrix([\n        [5, 0, 0]\n        [0, 3, 0]\n        ]), V=Matrix([\n        [sqrt(2)/2,   -sqrt(2)/6,  2/3]\n        [sqrt(2)/2,    sqrt(2)/6, -2/3]\n        [        0, -2*sqrt(2)/3, -1/3]\n        ]))\n\n    See Also:\n        - [`fast_svd`][..fast_svd] for a faster numerical SVD\n        - SymPy's [`Matrix.singular_value_decomposition`][sympy.matrices.matrixbase.MatrixBase.singular_value_decomposition]\n    \"\"\"\n\n    if verbosity &gt;= 1:\n        AT_A = self.T @ self\n        print(\"A^T A\")\n        display(AT_A)\n        P, D = AT_A.orthogonally_diagonalize(verbosity=verbosity)\n        # Reverse index such that singular values are in decreasing order\n        sigma = [sym.sqrt(val) for val in D.diagonal()][::-1]\n        S = Matrix.diag(*[singular for singular in sigma if (singular != 0)])\n        V = P.select_cols(*[i for i in range(P.cols)][::-1])\n\n        u_list = []\n        for idx, vec, val in zip(range(1, S.rows + 1), V.columnspace(), sigma):\n            if val != 0:\n                u_i = self @ vec / val\n                u_list.append(u_i)\n                display(\n                    f\"u_{idx} = (1/{sym.latex(val)})A{sym.latex(vec)} = {sym.latex(u_i)}\",\n                    opt=\"math\",\n                )\n\n        U = Matrix.from_list(u_list)\n        # Extend basis using orthogonal complement and gram-schmidt if insufficient vectors\n        if U.cols &lt; self.rows:\n            print(\"\\nExtending U with its orthogonal complement.\")\n            if U.cols == 0:\n                # Pad edge case with identity\n                orth = Matrix.eye(self.rows)\n            else:\n                complement = U.orthogonal_complement(verbosity=verbosity)\n                gram_result = complement.gram_schmidt(\n                    factor=True, verbosity=verbosity\n                )\n                if isinstance(gram_result, ScalarFactor):\n                    orth = gram_result.full\n                else:\n                    orth = gram_result\n\n                orth = orth.normalized(factor=False)\n                assert isinstance(orth, Matrix), (\n                    f\"Expected orth to be a Matrix, got {type(orth)}\"\n                )\n            U = U.row_join(orth, aug_line=False)\n\n        # Add zero rows and columns to S so that matrix multiplication is defined\n        m, n = self.shape\n        r, c = S.shape\n        S = S.row_join(sym.zeros(r, n - c), aug_line=False).col_join(\n            sym.zeros(m - r, n)\n        )\n\n        if verify:\n            assert (U @ S @ V.T - self).norm() == 0\n        return SVD(U, S, V)\n\n    m, n = self.shape\n    U, S, V = super().singular_value_decomposition()\n    # Reverse index such that singular values are in decreasing order\n    new_S = Matrix.diag(*S.diagonal()[::-1])\n\n    S_index = [i for i in range(S.cols)][::-1]\n    new_U = Matrix(U).select_cols(*S_index)\n    new_V = Matrix(V).select_cols(*S_index)\n\n    # new_U = Matrix(U).\n    # Add orthonormal columns to U and V so that they are square matrices\n    new_U = new_U.QRdecomposition(full=True).Q\n    new_V = new_V.QRdecomposition(full=True).Q\n\n    # Add zero rows and columns to S so that matrix multiplication is defined\n    r, c = new_S.shape\n    new_S = new_S.row_join(sym.zeros(r, n - c), aug_line=False).col_join(\n        sym.zeros(m - r, n)\n    )\n\n    if verify and (residues := (new_U @ new_S @ new_V.T - self).norm()) &gt; tol:\n        res = residues.evalf()\n        warn(\n            f\"Verification failed: norm of residual is {res} &gt; {tol}\",\n            RuntimeWarning,\n            stacklevel=2,\n        )\n    return SVD(new_U, new_S, new_V)\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.fast_svd","title":"<code>fast_svd(option: Literal['np', 'sym'] = 'np', identify: bool = True, tol: float | None = None) -&gt; SVD | NumSVD</code>","text":"<p>A faster version of SVD that computes numerically using NumPy's SVD function.</p> <p>This method is designed to be efficient and suitable for large matrices, but it does not guarantee exact symbolic results like the <code>singular_value_decomposition</code> method. It uses <code>numpy.linalg.svd</code> function to compute the singular value decomposition and <code>mpmath.identify</code> function to identify rational numbers or surds if requested.</p> Note <ul> <li>This method might not return exact values, even if identification is enabled as it does     not use SymPy's symbolic computation for SVD.</li> <li>Use this method when performance is a concern and exact symbolic results are not required.</li> </ul> <p>Parameters:</p> <ul> <li> <code>option</code>               (<code>Literal['np', 'sym']</code>, default:                   <code>'np'</code> )           \u2013            <p>Whether to return numpy arrays or sympy matrices.</p> </li> <li> <code>identify</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to attempt identification of rational numbers or surds. If <code>True</code>, <code>option</code> must be <code>\"sym\"</code> to return symbolic matrices.</p> </li> <li> <code>tol</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>Tolerance for <code>mpmath.identify</code> function as well as for verifying the SVD result.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SVD</code>           \u2013            <p>A dataclass containing:</p> <ul> <li><code>U</code> (<code>Matrix</code>): The left singular vectors.</li> <li><code>S</code> (<code>Matrix</code>): The diagonal matrix of singular values.</li> <li><code>V</code> (<code>Matrix</code>): The right singular vectors.</li> </ul> </li> <li> <code>NumSVD</code>           \u2013            <p>A named tuple containing:</p> <ul> <li><code>U</code> (<code>numpy.ndarray</code>): The left singular vectors as a NumPy array.</li> <li><code>S</code> (<code>numpy.ndarray</code>): The diagonal matrix of singular values as a NumPy array.</li> <li><code>V</code> (<code>numpy.ndarray</code>): The right singular vectors as a NumPy array.</li> </ul> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = Matrix([[3, 2, 2], [2, 3, -2]])\n&gt;&gt;&gt; mat.fast_svd(option=\"sym\", identify=False)\nSVD(U=Matrix([\n[-0.707106781186548, -0.707106781186548]\n[-0.707106781186547,  0.707106781186548]\n]), S=Matrix([\n[5.0, 0.0, 0.0]\n[0.0, 3.0, 0.0]\n]), V=Matrix([\n[   -0.707106781186548, -0.235702260395516, -0.666666666666667]\n[   -0.707106781186548,  0.235702260395516,  0.666666666666667]\n[-6.47932334256779e-17, -0.942809041582063,  0.333333333333333]\n]))\n</code></pre> See Also <ul> <li><code>singular_value_decomposition</code> for the     symbolic version of SVD.</li> <li>NumPy's <code>numpy.linalg.svd</code> for the underlying numerical     SVD implementation.</li> </ul> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def fast_svd(\n    self,\n    option: Literal[\"np\", \"sym\"] = \"np\",\n    identify: bool = True,\n    tol: float | None = None,\n) -&gt; SVD | NumSVD:\n    \"\"\"A faster version of SVD that computes numerically using NumPy's SVD function.\n\n    This method is designed to be efficient and suitable for large matrices, but it does not guarantee\n    exact symbolic results like the [`singular_value_decomposition`][..singular_value_decomposition] method.\n    It uses [`numpy.linalg.svd`][numpy.linalg.svd] function to compute the singular value decomposition and\n    [`mpmath.identify`][mpmath.identify] function to identify rational numbers or surds if requested.\n\n    Note:\n        - This method might not return exact values, even if identification is enabled as it does\n            not use SymPy's symbolic computation for SVD.\n        - Use this method when performance is a concern and exact symbolic results are not required.\n\n    Args:\n        option (Literal[\"np\", \"sym\"], optional): Whether to return numpy arrays or sympy matrices.\n        identify (bool, optional): Whether to attempt identification of rational numbers or surds.\n            If `True`, `option` must be `\"sym\"` to return symbolic matrices.\n        tol (float, optional): Tolerance for [`mpmath.identify`][mpmath.identify] function as well as\n            for verifying the SVD result.\n\n    Returns:\n        (SVD): A dataclass containing:\n\n            - `U` ([`Matrix`][...]): The left singular vectors.\n            - `S` ([`Matrix`][...]): The diagonal matrix of singular values.\n            - `V` ([`Matrix`][...]): The right singular vectors.\n\n        (NumSVD): A named tuple containing:\n\n            - `U` ([`numpy.ndarray`][numpy.ndarray]): The left singular vectors as a NumPy array.\n            - `S` ([`numpy.ndarray`][numpy.ndarray]): The diagonal matrix of singular values as a NumPy array.\n            - `V` ([`numpy.ndarray`][numpy.ndarray]): The right singular vectors as a NumPy array.\n\n    Examples:\n        &gt;&gt;&gt; mat = Matrix([[3, 2, 2], [2, 3, -2]])\n        &gt;&gt;&gt; mat.fast_svd(option=\"sym\", identify=False)\n        SVD(U=Matrix([\n        [-0.707106781186548, -0.707106781186548]\n        [-0.707106781186547,  0.707106781186548]\n        ]), S=Matrix([\n        [5.0, 0.0, 0.0]\n        [0.0, 3.0, 0.0]\n        ]), V=Matrix([\n        [   -0.707106781186548, -0.235702260395516, -0.666666666666667]\n        [   -0.707106781186548,  0.235702260395516,  0.666666666666667]\n        [-6.47932334256779e-17, -0.942809041582063,  0.333333333333333]\n        ]))\n\n    See Also:\n        - [`singular_value_decomposition`][..singular_value_decomposition] for the\n            symbolic version of SVD.\n        - NumPy's [`numpy.linalg.svd`][numpy.linalg.svd] for the underlying numerical\n            SVD implementation.\n    \"\"\"\n\n    m, n = self.shape\n    U, S, Vh = np.linalg.svd(np.array(self, dtype=np.float64))\n    # To align with MA1522 Syllabus, return V instead of V.T\n    # Need not use conjugate transpose as MA1522 deals with real matrices\n    V = Vh.T\n\n    # Create sigma matrix from singular values\n    S = np.diag(S)\n    r, c = S.shape\n    S = np.concat((S, np.zeros((r, n - c))), axis=1)\n    S = np.concat((S, np.zeros((m - r, n))), axis=0)\n    if option == \"np\":\n        return NumSVD(U, S, V)\n    elif option == \"sym\":\n        U, S, V = Matrix(U), Matrix(S), Matrix(V)\n        if identify:\n            U = U.identify(tol=tol, suppress_warnings=True)\n            S = S.identify(tol=tol, suppress_warnings=True)\n            V = V.identify(tol=tol, suppress_warnings=True)\n            residues = (self - U @ S @ V.T).norm()\n            if residues &gt; tol:\n                res = residues.evalf()\n                warn(\n                    f\"Non-zero Identification Error: {res}\",\n                    RuntimeWarning,\n                    stacklevel=2,\n                )\n            return SVD(U, S, V)\n        else:\n            return SVD(U, S, V)\n    else:\n        warn(\n            f\"Invalid option '{option}'. Expected 'np' or 'sym'. Returning NumSVD.\",\n            SyntaxWarning,\n            stacklevel=2,\n        )\n        return NumSVD(U, S, V)\n</code></pre>"},{"location":"api/symbolic/#ma1522.symbolic.Matrix.standard_matrix","title":"<code>standard_matrix(out: Matrix, matrices: int = 1) -&gt; list[Matrix] | list[PartGen]</code>","text":"<p>Returns the standard matrix for the transformation from self to out.</p> <p>The standard matrix is a matrix <code>T</code> such that <code>T @ self = out</code>, where <code>self</code> is the matrix whos columns represent the input vectors and <code>out</code> is the matrix whose columns represent the output vectors.</p> Note <ul> <li>The standard matrix may not be unique if the transformation is not injective.</li> <li>If multiple solutions are found, the first solution is returned.</li> </ul> <p>Parameters:</p> <ul> <li> <code>out</code>               (<code>Matrix</code>)           \u2013            <p>The target matrix for the transformation.</p> </li> <li> <code>matrices</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The type of matrices to return:</p> <ul> <li>1: Returns the standard matrix.</li> <li>2: Returns a <code>PartGen</code> with the part solution and general solution.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Matrix]</code>           \u2013            <p>If <code>matrices=1</code>, returns the standard matrix for the transformation.</p> </li> <li> <code>list[PartGen]</code>           \u2013            <p>If <code>matrices=2</code>, returns a <code>PartGen</code> with the part solution and general solution.</p> </li> </ul> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; input = Matrix([[1, 0, 1], [2, -1, 0], [0, 3, 1]])\n&gt;&gt;&gt; output = Matrix([[4, 2, 3], [5, -1, 0], [1, 4, 2]])\n&gt;&gt;&gt; input.standard_matrix(output)\n[Matrix([\n[   2,    1,   1]\n[-3/5, 14/5, 3/5]\n[ 3/5,  1/5, 7/5]\n])]\n</code></pre> Source code in <code>src/ma1522/symbolic.py</code> Python<pre><code>def standard_matrix(\n    self, out: Matrix, matrices: int = 1\n) -&gt; list[Matrix] | list[PartGen]:\n    \"\"\"Returns the standard matrix for the transformation from self to out.\n\n    The standard matrix is a matrix `T` such that `T @ self = out`, where `self` is the matrix\n    whos columns represent the input vectors and `out` is the matrix whose columns represent the output vectors.\n\n    Note:\n        - The standard matrix may not be unique if the transformation is not injective.\n        - If multiple solutions are found, the first solution is returned.\n\n    Args:\n        out (Matrix): The target matrix for the transformation.\n        matrices (int): The type of matrices to return:\n\n            - 1: Returns the standard matrix.\n            - 2: Returns a [`PartGen`][(p).] with the part solution and general solution.\n\n    Returns:\n        (list[Matrix]): If `matrices=1`, returns the standard matrix for the transformation.\n        (list[PartGen]): If `matrices=2`, returns a [`PartGen`][(p).] with the part solution and general solution.\n\n    Examples:\n        &gt;&gt;&gt; input = Matrix([[1, 0, 1], [2, -1, 0], [0, 3, 1]])\n        &gt;&gt;&gt; output = Matrix([[4, 2, 3], [5, -1, 0], [1, 4, 2]])\n        &gt;&gt;&gt; input.standard_matrix(output)\n        [Matrix([\n        [   2,    1,   1]\n        [-3/5, 14/5, 3/5]\n        [ 3/5,  1/5, 7/5]\n        ])]\n    \"\"\"\n    X = Matrix.create_unk_matrix(r=out.rows, c=self.rows)\n    equal_0 = X @ self - out\n    if len(self.free_symbols) != 0:\n        # Add zeroing examples to condition the transformation matrix for unknown vectors\n        examples = []\n        for symbol in (symbols := self.free_symbols):\n            sub = {s: 0 for s in symbols if s != symbol}\n            sub[symbol] = 1\n            examples.append(equal_0.subs(sub))\n\n        # for _ in range(X.rows * X.cols):\n        #     # Add random examples to condition the transformation matrix\n        #     rand = Matrix.create_rand_matrix(r=len(self.free_symbols), c=1)\n        #     sub = {s: rand[i, 0] for i, s in enumerate(symbols)}\n        #     examples.append(equal_0.subs(sub))\n\n        condition = Matrix.from_list(examples)\n        equal_0 = equal_0.row_join(condition, aug_line=False)\n\n    sol = sym.solve(equal_0, X.free_symbols, dict=True)\n    if len(sol) == 0:\n        raise ValueError(\n            \"No solution found for the standard matrix. \"\n            \"This may indicate that the transformation is not linear.\"\n        )\n    res = []\n    for s in sol:\n        tmp = X.subs(s)\n        if matrices == 1:\n            res.append(tmp)\n        elif matrices == 2:\n            res.append(tmp.sep_part_gen())\n        else:\n            raise ValueError(\n                f\"Invalid value for matrices: {matrices}. Expected 1 or 2.\"\n            )\n    return res\n</code></pre>"},{"location":"api/utils/","title":"utils","text":"<p>Functions:</p> <ul> <li> <code>display</code>             \u2013              <p>Displays objects in a rich format, depending on the environment.</p> </li> </ul>"},{"location":"api/utils/#ma1522.utils.display","title":"<code>display(*args, opt: Literal['math', 'dict'] | None = None, **kwargs) -&gt; None</code>","text":"<p>Displays objects in a rich format, depending on the environment.</p> <p>This function displays objects using IPython's <code>display</code> mechanism if available, otherwise it falls back to <code>sympy.pprint</code>.</p> <p>Parameters:</p> <ul> <li> <code>*args</code>           \u2013            <p>The objects to display.</p> </li> <li> <code>opt</code>               (<code>Literal['math', 'dict'] | None</code>, default:                   <code>None</code> )           \u2013            <ul> <li>If \"math\", displays the object as a math expression.</li> <li>If \"dict\", generates a LaTeX representation of the dictionary for display.</li> <li>If none, assumes the object can be passed into IPython's [<code>display</code>][<code>display</code>] function directly.</li> </ul> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments to pass to the display function.</p> </li> </ul> See Also <ul> <li><code>IPython.display.display</code>: The class used to display     objects in IPython environments.</li> <li><code>sympy.pprint</code>: The class used to pretty-print     objects in non-IPython environments.</li> </ul> Source code in <code>src/ma1522/utils.py</code> Python<pre><code>def display(*args, opt: Literal[\"math\", \"dict\"] | None = None, **kwargs) -&gt; None:\n    \"\"\"Displays objects in a rich format, depending on the environment.\n\n    This function displays objects using IPython's [`display`][IPython.display] mechanism if available,\n    otherwise it falls back to [`sympy.pprint`][sympy.printing.pretty.pretty.PrettyPrinter].\n\n    Args:\n        *args: The objects to display.\n        opt:\n\n            - If \"math\", displays the object as a math expression.\n            - If \"dict\", generates a LaTeX representation of the dictionary for display.\n            - If none, assumes the object can be passed into IPython's [`display`][] function directly.\n        **kwargs: Additional keyword arguments to pass to the display function.\n\n    See Also:\n        - [`IPython.display.display`][IPython.display]: The class used to display\n            objects in IPython environments.\n        - [`sympy.pprint`][sympy.printing.pretty.pretty.PrettyPrinter]: The class used to pretty-print\n            objects in non-IPython environments.\n    \"\"\"\n    if _is_IPython():\n        import IPython.display\n\n        if opt == \"math\":\n            # Display the object as a math expression\n            IPython.display.display(IPython.display.Math(*args, **kwargs))\n        elif opt == \"dict\":\n            # Generate a LaTeX representation of the dictionary\n            from sympy.printing.latex import LatexPrinter\n\n            printer = kwargs.pop(\"printer\", LatexPrinter())\n            for arg in args:\n                if not isinstance(arg, dict):\n                    continue\n                IPython.display.display(\n                    IPython.display.Math(_gen_latex_repr_dict(arg, printer=printer))\n                )\n        else:\n            IPython.display.display(*args, **kwargs)\n    else:\n        sym.pprint(*args, **kwargs)\n</code></pre>"},{"location":"live/demo/","title":"Live Notebook","text":""},{"location":"tutorials/tut01/","title":"Tutorial 1","text":"In\u00a0[1]: Copied! <pre># Required imports\nimport sympy as sym\nfrom ma1522 import Matrix\n</pre> # Required imports import sympy as sym from ma1522 import Matrix In\u00a0[2]: Copied! <pre>mat = Matrix([[3, 2, -4],\n              [2, 3, 3],\n              [5, -3, 1]])\n\naug = Matrix([3, 15, 14])\n\naug_mat = mat.row_join(aug)\naug_mat\n</pre> mat = Matrix([[3, 2, -4],               [2, 3, 3],               [5, -3, 1]])  aug = Matrix([3, 15, 14])  aug_mat = mat.row_join(aug) aug_mat Out[2]:  $\\displaystyle \\left[\\begin{array}{ccc|c}3 &amp; 2 &amp; -4 &amp; 3\\\\2 &amp; 3 &amp; 3 &amp; 15\\\\5 &amp; -3 &amp; 1 &amp; 14\\end{array}\\right]$  In\u00a0[3]: Copied! <pre>plu = aug_mat.ref() # Show steps to get to Row Echelon Form\n</pre> plu = aug_mat.ref() # Show steps to get to Row Echelon Form  $\\displaystyle R_2 - \\left(\\frac{2}{3}\\right)R_1 \\rightarrow R_2$   $\\displaystyle \\left[\\begin{array}{ccc|c}3 &amp; 2 &amp; -4 &amp; 3\\\\0 &amp; \\frac{5}{3} &amp; \\frac{17}{3} &amp; 13\\\\5 &amp; -3 &amp; 1 &amp; 14\\end{array}\\right]$  <pre>\n\n</pre>  $\\displaystyle R_3 - \\left(\\frac{5}{3}\\right)R_1 \\rightarrow R_3$   $\\displaystyle \\left[\\begin{array}{ccc|c}3 &amp; 2 &amp; -4 &amp; 3\\\\0 &amp; \\frac{5}{3} &amp; \\frac{17}{3} &amp; 13\\\\0 &amp; - \\frac{19}{3} &amp; \\frac{23}{3} &amp; 9\\end{array}\\right]$  <pre>\n\n</pre>  $\\displaystyle R_3 - \\left(- \\frac{19}{5}\\right)R_2 \\rightarrow R_3$   $\\displaystyle \\left[\\begin{array}{ccc|c}3 &amp; 2 &amp; -4 &amp; 3\\\\0 &amp; \\frac{5}{3} &amp; \\frac{17}{3} &amp; 13\\\\0 &amp; 0 &amp; \\frac{146}{5} &amp; \\frac{292}{5}\\end{array}\\right]$  <pre>\n\n</pre> In\u00a0[4]: Copied! <pre>plu.U.rref()  # Reduced Row Echelon Form from Upper Triangular Matrix\n</pre> plu.U.rref()  # Reduced Row Echelon Form from Upper Triangular Matrix Out[4]:  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc|c}1 &amp; 0 &amp; 0 &amp; 3\\\\0 &amp; 1 &amp; 0 &amp; 1\\\\0 &amp; 0 &amp; 1 &amp; 2\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 2)\\right\\}$  In\u00a0[5]: Copied! <pre>mat = Matrix([[1, 1, -1, -2],\n              [2, 1, -1, 1],\n              [-1, 1, -3, 1]])\n\naug = Matrix([0, -2, 4])\n\naug_mat = mat.row_join(aug)\naug_mat\n</pre> mat = Matrix([[1, 1, -1, -2],               [2, 1, -1, 1],               [-1, 1, -3, 1]])  aug = Matrix([0, -2, 4])  aug_mat = mat.row_join(aug) aug_mat Out[5]:  $\\displaystyle \\left[\\begin{array}{cccc|c}1 &amp; 1 &amp; -1 &amp; -2 &amp; 0\\\\2 &amp; 1 &amp; -1 &amp; 1 &amp; -2\\\\-1 &amp; 1 &amp; -3 &amp; 1 &amp; 4\\end{array}\\right]$  In\u00a0[6]: Copied! <pre>aug_mat.rref() # Find Reduced Row Echelon Form\n</pre> aug_mat.rref() # Find Reduced Row Echelon Form Out[6]:  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cccc|c}1 &amp; 0 &amp; 0 &amp; 3 &amp; -2\\\\0 &amp; 1 &amp; 0 &amp; - \\frac{19}{2} &amp; 2\\\\0 &amp; 0 &amp; 1 &amp; - \\frac{9}{2} &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 2)\\right\\}$  In\u00a0[7]: Copied! <pre>mat.solve(aug)[0]  # Solve the system of equations represented by the augmented matrix\n</pre> mat.solve(aug)[0]  # Solve the system of equations represented by the augmented matrix Out[7]:  $\\displaystyle \\left[\\begin{array}{c}- 3 z - 2\\\\\\frac{19 z}{2} + 2\\\\\\frac{9 z}{2}\\\\z\\end{array}\\right]$  In\u00a0[8]: Copied! <pre># add aug_pos to specify the position of the augmented column\naug_mat = Matrix([[1, -4, 2, -2],\n                  [1, 2, -2, -3],\n                  [1, -1, 0, 4]], aug_pos = 2)\n\naug_mat\n</pre> # add aug_pos to specify the position of the augmented column aug_mat = Matrix([[1, -4, 2, -2],                   [1, 2, -2, -3],                   [1, -1, 0, 4]], aug_pos = 2)  aug_mat Out[8]:  $\\displaystyle \\left[\\begin{array}{ccc|c}1 &amp; -4 &amp; 2 &amp; -2\\\\1 &amp; 2 &amp; -2 &amp; -3\\\\1 &amp; -1 &amp; 0 &amp; 4\\end{array}\\right]$  In\u00a0[9]: Copied! <pre>aug_mat.rref()\n</pre> aug_mat.rref() Out[9]:  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc|c}1 &amp; 0 &amp; - \\frac{2}{3} &amp; 0\\\\0 &amp; 1 &amp; - \\frac{2}{3} &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 3)\\right\\}$  In\u00a0[10]: Copied! <pre>mat = aug_mat.select_cols(0, 1, 2)  # Remove the augmented column\naug = aug_mat.select_cols(3)  # Select the augmented column\n# Solve the system of equations represented by the augmented matrix\ntry:\n    mat.solve(aug)\nexcept ValueError as e:\n    print(\"Error raised due to inconsistent system:\", e)\n</pre> mat = aug_mat.select_cols(0, 1, 2)  # Remove the augmented column aug = aug_mat.select_cols(3)  # Select the augmented column # Solve the system of equations represented by the augmented matrix try:     mat.solve(aug) except ValueError as e:     print(\"Error raised due to inconsistent system:\", e)  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc|c}1 &amp; 0 &amp; - \\frac{2}{3} &amp; 0\\\\0 &amp; 1 &amp; - \\frac{2}{3} &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 3)\\right\\}$  <pre>Error raised due to inconsistent system: No solution found for the linear system. The system may be inconsistent.\n</pre> In\u00a0[11]: Copied! <pre>a, b = sym.symbols('a b') # Define symbolic variables\n\nmat = Matrix([[a, 0, b, 2],\n              [a, a, 4, 4],\n              [0, a, 2, b]], aug_pos=2)\n\nmat\n</pre> a, b = sym.symbols('a b') # Define symbolic variables  mat = Matrix([[a, 0, b, 2],               [a, a, 4, 4],               [0, a, 2, b]], aug_pos=2)  mat Out[11]:  $\\displaystyle \\left[\\begin{array}{ccc|c}a &amp; 0 &amp; b &amp; 2\\\\a &amp; a &amp; 4 &amp; 4\\\\0 &amp; a &amp; 2 &amp; b\\end{array}\\right]$  In\u00a0[12]: Copied! <pre>plu = mat.ref()  # Reduced Row Echelon Form using PLU decomposition\n</pre> plu = mat.ref()  # Reduced Row Echelon Form using PLU decomposition  $\\displaystyle R_2 - \\left(1\\right)R_1 \\rightarrow R_2$   $\\displaystyle \\left[\\begin{array}{ccc|c}a &amp; 0 &amp; b &amp; 2\\\\0 &amp; a &amp; 4 - b &amp; 2\\\\0 &amp; a &amp; 2 &amp; b\\end{array}\\right]$  <pre>\n\n</pre>  $\\displaystyle R_3 - \\left(1\\right)R_2 \\rightarrow R_3$   $\\displaystyle \\left[\\begin{array}{ccc|c}a &amp; 0 &amp; b &amp; 2\\\\0 &amp; a &amp; 4 - b &amp; 2\\\\0 &amp; 0 &amp; b - 2 &amp; b - 2\\end{array}\\right]$  <pre>\n\n</pre> In\u00a0[13]: Copied! <pre># Case 1: b != 2, a = 0\n\nplu.U.subs({a: 0}).rref()  # substitute a = 0\n</pre> # Case 1: b != 2, a = 0  plu.U.subs({a: 0}).rref()  # substitute a = 0 Out[13]:  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc|c}0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\\\0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (2, 3)\\right\\}$  In\u00a0[14]: Copied! <pre># Case 2: b != 2, a != 0\n\nplu.U.rref()\n</pre> # Case 2: b != 2, a != 0  plu.U.rref() Out[14]:  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc|c}1 &amp; 0 &amp; 0 &amp; \\frac{2 - b}{a}\\\\0 &amp; 1 &amp; 0 &amp; \\frac{b - 2}{a}\\\\0 &amp; 0 &amp; 1 &amp; 1\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 2)\\right\\}$  In\u00a0[15]: Copied! <pre># Case 3: b = 2, a != 0\nplu.U.subs({b: 2}).rref()  # substitute b = 2\n</pre> # Case 3: b = 2, a != 0 plu.U.subs({b: 2}).rref()  # substitute b = 2 Out[15]:  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc|c}1 &amp; 0 &amp; \\frac{2}{a} &amp; \\frac{2}{a}\\\\0 &amp; 1 &amp; \\frac{2}{a} &amp; \\frac{2}{a}\\\\0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1)\\right\\}$  In\u00a0[16]: Copied! <pre># Case 4: b = 2, a = 0\nplu.U.subs({a: 0, b: 2}).rref()  # substitute a = 0 and b = 2\n</pre> # Case 4: b = 2, a = 0 plu.U.subs({a: 0, b: 2}).rref()  # substitute a = 0 and b = 2 Out[16]:  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc|c}0 &amp; 0 &amp; 1 &amp; 1\\\\0 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (2,)\\right\\}$  In\u00a0[17]: Copied! <pre>mat = Matrix([[1, -1, 2, 6],\n              [2, 2, -5, 3],\n              [2, 5, 1, 9]], aug_pos=2)\n\nmat\n</pre> mat = Matrix([[1, -1, 2, 6],               [2, 2, -5, 3],               [2, 5, 1, 9]], aug_pos=2)  mat Out[17]:  $\\displaystyle \\left[\\begin{array}{ccc|c}1 &amp; -1 &amp; 2 &amp; 6\\\\2 &amp; 2 &amp; -5 &amp; 3\\\\2 &amp; 5 &amp; 1 &amp; 9\\end{array}\\right]$  In\u00a0[18]: Copied! <pre>mat.rref()\n</pre> mat.rref() Out[18]:  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc|c}1 &amp; 0 &amp; 0 &amp; 4\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 1\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 2)\\right\\}$  In\u00a0[19]: Copied! <pre># Alternative Method: Using sym.solve\n\nx, y, z = sym.symbols('x y z')  # Define symbolic variables for the solution\n\nvec = Matrix([x**2, y**2, z**2])  # Define a vector of symbolic variables\n\nmat = Matrix([[1, -1, 2],\n              [2, 2, -5],\n              [2, 5, 1]])\n\naug = Matrix([6, 3, 9])\n\nmat, vec, aug\n</pre> # Alternative Method: Using sym.solve  x, y, z = sym.symbols('x y z')  # Define symbolic variables for the solution  vec = Matrix([x**2, y**2, z**2])  # Define a vector of symbolic variables  mat = Matrix([[1, -1, 2],               [2, 2, -5],               [2, 5, 1]])  aug = Matrix([6, 3, 9])  mat, vec, aug Out[19]:  $\\displaystyle \\left( \\left[\\begin{array}{ccc}1 &amp; -1 &amp; 2\\\\2 &amp; 2 &amp; -5\\\\2 &amp; 5 &amp; 1\\end{array}\\right], \\  \\left[\\begin{array}{c}x^{2}\\\\y^{2}\\\\z^{2}\\end{array}\\right], \\  \\left[\\begin{array}{c}6\\\\3\\\\9\\end{array}\\right]\\right)$  In\u00a0[20]: Copied! <pre>sols = sym.solve(mat @ vec - aug)  # Solve the system of equations\nfor sol in sols:\n    display(sol)  # Print the solutions for each variable\n</pre> sols = sym.solve(mat @ vec - aug)  # Solve the system of equations for sol in sols:     display(sol)  # Print the solutions for each variable  $\\displaystyle \\left\\{ x : -2, \\  y : 0, \\  z : -1\\right\\}$   $\\displaystyle \\left\\{ x : -2, \\  y : 0, \\  z : 1\\right\\}$   $\\displaystyle \\left\\{ x : 2, \\  y : 0, \\  z : -1\\right\\}$   $\\displaystyle \\left\\{ x : 2, \\  y : 0, \\  z : 1\\right\\}$  In\u00a0[21]: Copied! <pre>aug_mat = Matrix([[1, 0, 1, 0, 0, 0, 0, 800],\n                  [1, -1, 0, 1, 0, 0, 0, 200],\n                  [0, 1, 0, 0, -1, 0, 0, 500],\n                  [0, 0, 1, 0, 0, 1, 0, 750],\n                  [0, 0, 0, -1, 0, -1, 1, -600],\n                  [0, 0, 0, 0, 1, 0, -1, -50]], aug_pos=6)\n\naug_mat\n</pre> aug_mat = Matrix([[1, 0, 1, 0, 0, 0, 0, 800],                   [1, -1, 0, 1, 0, 0, 0, 200],                   [0, 1, 0, 0, -1, 0, 0, 500],                   [0, 0, 1, 0, 0, 1, 0, 750],                   [0, 0, 0, -1, 0, -1, 1, -600],                   [0, 0, 0, 0, 1, 0, -1, -50]], aug_pos=6)  aug_mat Out[21]:  $\\displaystyle \\left[\\begin{array}{ccccccc|c}1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 800\\\\1 &amp; -1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 200\\\\0 &amp; 1 &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; 0 &amp; 500\\\\0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 750\\\\0 &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; -1 &amp; 1 &amp; -600\\\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; -1 &amp; -50\\end{array}\\right]$  In\u00a0[22]: Copied! <pre>aug_mat.rref()\n</pre> aug_mat.rref() Out[22]:  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccccccc|c}1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; 50\\\\0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; 450\\\\0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 750\\\\0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; -1 &amp; 600\\\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; -1 &amp; -50\\\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 2, 3, 4)\\right\\}$  In\u00a0[23]: Copied! <pre>mat = aug_mat.select_cols(*range(7))\naug = aug_mat.select_cols(7)\n\nsol = mat.solve(aug)[0]\nsol\n</pre> mat = aug_mat.select_cols(*range(7)) aug = aug_mat.select_cols(7)  sol = mat.solve(aug)[0] sol Out[23]:  $\\displaystyle \\left[\\begin{array}{c}y + 50\\\\z + 450\\\\750 - y\\\\- y + z + 600\\\\z - 50\\\\y\\\\z\\end{array}\\right]$  In\u00a0[24]: Copied! <pre>y = sol[5]\nz = sol[6]\nsol.subs({y: 50, z: 100})  # Substitute y and z with specified values\n</pre> y = sol[5] z = sol[6] sol.subs({y: 50, z: 100})  # Substitute y and z with specified values Out[24]:  $\\displaystyle \\left[\\begin{array}{c}100\\\\550\\\\700\\\\650\\\\50\\\\50\\\\100\\end{array}\\right]$  In\u00a0[25]: Copied! <pre>sol.subs({y: -50}) # Set sol[0] = 0\n</pre> sol.subs({y: -50}) # Set sol[0] = 0 Out[25]:  $\\displaystyle \\left[\\begin{array}{c}0\\\\z + 450\\\\800\\\\z + 650\\\\z - 50\\\\-50\\\\z\\end{array}\\right]$"},{"location":"tutorials/tut01/#tutorial-1-ay2425-sem-1","title":"Tutorial 1 (AY24/25 Sem 1)\u00b6","text":""},{"location":"tutorials/tut01/#question-3","title":"Question 3\u00b6","text":"<p>Solve the following linear systems.</p>"},{"location":"tutorials/tut01/#a","title":"(a)\u00b6","text":"<p>$$\\begin{cases} 3x_1 &amp; + &amp; 2x_2 &amp; - &amp; 4x_3 &amp; = &amp; 3 \\\\ 2x_1 &amp; + &amp; 3x_2 &amp; + &amp; 3x_3 &amp; = &amp; 15  \\\\ 5x_1 &amp; - &amp; 3x_2 &amp; + &amp; x_3 &amp; = &amp; 14 \\end{cases}$$</p>"},{"location":"tutorials/tut01/#b","title":"(b)\u00b6","text":"<p>$$\\begin{cases} a &amp;+&amp; b &amp;-&amp; c &amp;-&amp; 2d &amp;=&amp; 0  \\\\  2a &amp;+&amp; b &amp;-&amp; c &amp;+&amp; d &amp;=&amp; -2  \\\\  -a &amp;+&amp; b &amp;-&amp; 3c &amp;+&amp; d &amp;=&amp; 4 \\end{cases}$$</p>"},{"location":"tutorials/tut01/#c","title":"(c)\u00b6","text":"<p>$$\\begin{cases} x &amp;-&amp; 4y &amp;+&amp; 2z &amp;=&amp; -2  \\\\  x &amp;+&amp; 2y &amp;-&amp; 2z &amp;=&amp; -3  \\\\  x &amp;-&amp; y &amp;&amp; &amp;=&amp; 4 \\end{cases}$$</p>"},{"location":"tutorials/tut01/#question-4","title":"Question 4\u00b6","text":"<p>Determine the values of $a$ and $b$ so that the linear system</p> <p>$$\\begin{cases} ax &amp;&amp; &amp;+&amp; bz &amp;=&amp; 2  \\\\  ax &amp;+&amp; ay &amp;+&amp; 4z &amp;=&amp; 4  \\\\  &amp;&amp; ay &amp;+&amp; 2z &amp;=&amp; b \\end{cases}$$</p>"},{"location":"tutorials/tut01/#a","title":"(a)\u00b6","text":"<p>has no solution</p>"},{"location":"tutorials/tut01/#b","title":"(b)\u00b6","text":"<p>has only one solution</p>"},{"location":"tutorials/tut01/#c","title":"(c)\u00b6","text":"<p>has infinitely many solutions and a general solution has one arbitrary parameter</p>"},{"location":"tutorials/tut01/#d","title":"(d)\u00b6","text":"<p>has infinitely many solutions and a general solution has two arbitrary parameters.</p>"},{"location":"tutorials/tut01/#question-6","title":"Question 6\u00b6","text":"<p>Solve the following system of non-linear equations:</p> <p>$$\\begin{cases} x^2 &amp;-&amp; y^2 &amp;+&amp; 2z^2 &amp;=&amp; 6  \\\\  2x^2 &amp;+&amp; 2y^2 &amp;-&amp; 5z^2 &amp;=&amp; 3  \\\\  2x^2 &amp;+&amp; 5y^2 &amp;+&amp; z^2 &amp;=&amp; 9 \\end{cases}$$</p>"},{"location":"tutorials/tut01/#question-7","title":"Question 7\u00b6","text":"<p>A network of one-way streets of a downtown section can be represented by the diagram below, with traffic flowing in the direction indicated. The average hourly volume of traffic entering and leaving this section during rush hour is given in the diagram.</p>"},{"location":"tutorials/tut01/#a","title":"(a)\u00b6","text":"<p>Do we have enough information to find the traffic volumes $x_1$, $x_2$, $x_3$, $x_4$, $x_5$, $x_6$, and $x_7$?</p>"},{"location":"tutorials/tut01/#b","title":"(b)\u00b6","text":"<p>Suppose $x_6 = 50$ and $x_7 = 100$. What is $x_1$, $x_2$, $x_3$, $x_4$, and $x_5$?</p>"},{"location":"tutorials/tut01/#c","title":"(c)\u00b6","text":"<p>Can the road between junction A and B be closed for construction while still keeping the traffic flowing in the same directions on the other streets? Explain.</p>"},{"location":"tutorials/tut02/","title":"Tutorial 2","text":"In\u00a0[1]: Copied! <pre># Required imports\nimport sympy as sym\nfrom ma1522 import Matrix, PartGen\n</pre> # Required imports import sympy as sym from ma1522 import Matrix, PartGen In\u00a0[2]: Copied! <pre>A = Matrix.from_str(\"1 1 0 1; 0 1 1 0; 0 0 1 1\", col_sep=\" \", row_sep=\";\")\nA\n</pre> A = Matrix.from_str(\"1 1 0 1; 0 1 1 0; 0 0 1 1\", col_sep=\" \", row_sep=\";\") A Out[2]:  $\\displaystyle \\left[\\begin{array}{cccc}1 &amp; 1 &amp; 0 &amp; 1\\\\0 &amp; 1 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 1\\end{array}\\right]$  In\u00a0[3]: Copied! <pre>X = A.inverse(\"right\", matrices=2, verbosity=1) \nX\n# matrices=2 separates X into two matrices, the particular and general solution to see the results clearly\n</pre> X = A.inverse(\"right\", matrices=2, verbosity=1)  X # matrices=2 separates X into two matrices, the particular and general solution to see the results clearly <pre>Before RREF: [self | eye]\n</pre>  $\\displaystyle \\left[\\begin{array}{cccc|c|c|c}1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cccc|c|c|c}1 &amp; 0 &amp; 0 &amp; 2 &amp; 1 &amp; -1 &amp; 1\\\\0 &amp; 1 &amp; 0 &amp; -1 &amp; 0 &amp; 1 &amp; -1\\\\0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 2)\\right\\}$  Out[3]:  $\\left(\\left[\\begin{array}{ccc}1 &amp; -1 &amp; 1\\\\0 &amp; 1 &amp; -1\\\\0 &amp; 0 &amp; 1\\\\0 &amp; 0 &amp; 0\\end{array}\\right] + \\left[\\begin{array}{ccc}- 2 x_{4,1} &amp; - 2 x_{4,2} &amp; - 2 x_{4,3}\\\\x_{4,1} &amp; x_{4,2} &amp; x_{4,3}\\\\- x_{4,1} &amp; - x_{4,2} &amp; - x_{4,3}\\\\x_{4,1} &amp; x_{4,2} &amp; x_{4,3}\\end{array}\\right]\\right)$  In\u00a0[4]: Copied! <pre># Further factorisation\nscalar_factor = X.gen_sol.scalar_factor(column=True)\nscalar_factor\n</pre> # Further factorisation scalar_factor = X.gen_sol.scalar_factor(column=True) scalar_factor Out[4]:  $\\left[\\begin{array}{ccc}-2 &amp; -2 &amp; -2\\\\1 &amp; 1 &amp; 1\\\\-1 &amp; -1 &amp; -1\\\\1 &amp; 1 &amp; 1\\end{array}\\right]\\left[\\begin{array}{ccc}x_{4,1} &amp; 0 &amp; 0\\\\0 &amp; x_{4,2} &amp; 0\\\\0 &amp; 0 &amp; x_{4,3}\\end{array}\\right]$  In\u00a0[5]: Copied! <pre># Therefore, X can be expressed as:\nPartGen(X.part_sol, scalar_factor)\n</pre> # Therefore, X can be expressed as: PartGen(X.part_sol, scalar_factor) Out[5]:  $\\left(\\left[\\begin{array}{ccc}1 &amp; -1 &amp; 1\\\\0 &amp; 1 &amp; -1\\\\0 &amp; 0 &amp; 1\\\\0 &amp; 0 &amp; 0\\end{array}\\right] + \\left[\\begin{array}{ccc}-2 &amp; -2 &amp; -2\\\\1 &amp; 1 &amp; 1\\\\-1 &amp; -1 &amp; -1\\\\1 &amp; 1 &amp; 1\\end{array}\\right]\\left[\\begin{array}{ccc}x_{4,1} &amp; 0 &amp; 0\\\\0 &amp; x_{4,2} &amp; 0\\\\0 &amp; 0 &amp; x_{4,3}\\end{array}\\right]\\right)$  In\u00a0[6]: Copied! <pre>B = Matrix.from_str(\"1 0 1; 1 1 0; 0 1 1; 0 0 1\", col_sep=\" \", row_sep=\";\")\nB\n</pre> B = Matrix.from_str(\"1 0 1; 1 1 0; 0 1 1; 0 0 1\", col_sep=\" \", row_sep=\";\") B Out[6]:  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 0 &amp; 1\\\\1 &amp; 1 &amp; 0\\\\0 &amp; 1 &amp; 1\\\\0 &amp; 0 &amp; 1\\end{array}\\right]$  In\u00a0[7]: Copied! <pre>Y = B.inverse(\"left\", matrices=2, verbosity=1)  # Find the right inverse of B\nY\n</pre> Y = B.inverse(\"left\", matrices=2, verbosity=1)  # Find the right inverse of B Y <pre>Before RREF: [self^T | eye]\n</pre>  $\\displaystyle \\left[\\begin{array}{cccc|c|c|c}1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0\\\\1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cccc|c|c|c}1 &amp; 0 &amp; 0 &amp; \\frac{1}{2} &amp; \\frac{1}{2} &amp; - \\frac{1}{2} &amp; \\frac{1}{2}\\\\0 &amp; 1 &amp; 0 &amp; - \\frac{1}{2} &amp; \\frac{1}{2} &amp; \\frac{1}{2} &amp; - \\frac{1}{2}\\\\0 &amp; 0 &amp; 1 &amp; \\frac{1}{2} &amp; - \\frac{1}{2} &amp; \\frac{1}{2} &amp; \\frac{1}{2}\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 2)\\right\\}$  Out[7]:  $\\left(\\left[\\begin{array}{cccc}\\frac{1}{2} &amp; \\frac{1}{2} &amp; - \\frac{1}{2} &amp; 0\\\\- \\frac{1}{2} &amp; \\frac{1}{2} &amp; \\frac{1}{2} &amp; 0\\\\\\frac{1}{2} &amp; - \\frac{1}{2} &amp; \\frac{1}{2} &amp; 0\\end{array}\\right] + \\left[\\begin{array}{cccc}- \\frac{x_{1,4}}{2} &amp; \\frac{x_{1,4}}{2} &amp; - \\frac{x_{1,4}}{2} &amp; x_{1,4}\\\\- \\frac{x_{2,4}}{2} &amp; \\frac{x_{2,4}}{2} &amp; - \\frac{x_{2,4}}{2} &amp; x_{2,4}\\\\- \\frac{x_{3,4}}{2} &amp; \\frac{x_{3,4}}{2} &amp; - \\frac{x_{3,4}}{2} &amp; x_{3,4}\\end{array}\\right]\\right)$  In\u00a0[8]: Copied! <pre>PartGen(Y.part_sol, Y.gen_sol.scalar_factor(column=False))\n</pre> PartGen(Y.part_sol, Y.gen_sol.scalar_factor(column=False)) Out[8]:  $\\left(\\left[\\begin{array}{cccc}\\frac{1}{2} &amp; \\frac{1}{2} &amp; - \\frac{1}{2} &amp; 0\\\\- \\frac{1}{2} &amp; \\frac{1}{2} &amp; \\frac{1}{2} &amp; 0\\\\\\frac{1}{2} &amp; - \\frac{1}{2} &amp; \\frac{1}{2} &amp; 0\\end{array}\\right] + \\left[\\begin{array}{ccc}x_{1,4} &amp; 0 &amp; 0\\\\0 &amp; x_{2,4} &amp; 0\\\\0 &amp; 0 &amp; x_{3,4}\\end{array}\\right]\\left[\\begin{array}{cccc}- \\frac{1}{2} &amp; \\frac{1}{2} &amp; - \\frac{1}{2} &amp; 1\\\\- \\frac{1}{2} &amp; \\frac{1}{2} &amp; - \\frac{1}{2} &amp; 1\\\\- \\frac{1}{2} &amp; \\frac{1}{2} &amp; - \\frac{1}{2} &amp; 1\\end{array}\\right]\\right)$  In\u00a0[9]: Copied! <pre>A = Matrix.from_str(\"5 -2 6 0; -2 1 3 1\")\nA\n</pre> A = Matrix.from_str(\"5 -2 6 0; -2 1 3 1\") A Out[9]:  $\\displaystyle \\left[\\begin{array}{cccc}5 &amp; -2 &amp; 6 &amp; 0\\\\-2 &amp; 1 &amp; 3 &amp; 1\\end{array}\\right]$  In\u00a0[10]: Copied! <pre># Tip: Use `copy()` to avoid modifying the original matrix so that \n# the same cell can be ran multiple times without side effects.\n\n(A.copy()\n .reduce_row(1, -2/5, 0)\n .scale_row(0, 1/5)\n .scale_row(1, 5)\n .reduce_row(0, -2/5, 1)\n)\n</pre> # Tip: Use `copy()` to avoid modifying the original matrix so that  # the same cell can be ran multiple times without side effects.  (A.copy()  .reduce_row(1, -2/5, 0)  .scale_row(0, 1/5)  .scale_row(1, 5)  .reduce_row(0, -2/5, 1) )  $\\displaystyle R_2 - \\left(-0.4\\right)R_1 \\rightarrow R_2$   $\\displaystyle \\left[\\begin{array}{cccc}5 &amp; -2 &amp; 6 &amp; 0\\\\0 &amp; \\frac{1}{5} &amp; \\frac{27}{5} &amp; 1\\end{array}\\right]$  <pre>\n\n</pre>  $\\displaystyle \\left(0.2\\right) R_1 \\rightarrow R_1$   $\\displaystyle \\left[\\begin{array}{cccc}1 &amp; - \\frac{2}{5} &amp; \\frac{6}{5} &amp; 0\\\\0 &amp; \\frac{1}{5} &amp; \\frac{27}{5} &amp; 1\\end{array}\\right]$  <pre>\n\n</pre>  $\\displaystyle \\left(5\\right) R_2 \\rightarrow R_2$   $\\displaystyle \\left[\\begin{array}{cccc}1 &amp; - \\frac{2}{5} &amp; \\frac{6}{5} &amp; 0\\\\0 &amp; 1 &amp; 27 &amp; 5\\end{array}\\right]$  <pre>\n\n</pre>  $\\displaystyle R_1 - \\left(-0.4\\right)R_2 \\rightarrow R_1$   $\\displaystyle \\left[\\begin{array}{cccc}1 &amp; 0 &amp; 12 &amp; 2\\\\0 &amp; 1 &amp; 27 &amp; 5\\end{array}\\right]$  <pre>\n\n</pre> Out[10]:  $\\displaystyle \\left[\\begin{array}{cccc}1 &amp; 0 &amp; 12 &amp; 2\\\\0 &amp; 1 &amp; 27 &amp; 5\\end{array}\\right]$  In\u00a0[11]: Copied! <pre>A = Matrix.from_str(\"-1 3 -4; 2 4 1; -4 2 -9\")\nA\n</pre> A = Matrix.from_str(\"-1 3 -4; 2 4 1; -4 2 -9\") A Out[11]:  $\\displaystyle \\left[\\begin{array}{ccc}-1 &amp; 3 &amp; -4\\\\2 &amp; 4 &amp; 1\\\\-4 &amp; 2 &amp; -9\\end{array}\\right]$  In\u00a0[12]: Copied! <pre>(A.copy()\n .reduce_row(1, -2, 0)\n .reduce_row(2, 4, 0)\n .reduce_row(2, -1, 1)\n .scale_row(0, -1)\n .scale_row(1, 1/10)\n .reduce_row(0, -3, 1)\n)\n</pre> (A.copy()  .reduce_row(1, -2, 0)  .reduce_row(2, 4, 0)  .reduce_row(2, -1, 1)  .scale_row(0, -1)  .scale_row(1, 1/10)  .reduce_row(0, -3, 1) )  $\\displaystyle R_2 - \\left(-2\\right)R_1 \\rightarrow R_2$   $\\displaystyle \\left[\\begin{array}{ccc}-1 &amp; 3 &amp; -4\\\\0 &amp; 10 &amp; -7\\\\-4 &amp; 2 &amp; -9\\end{array}\\right]$  <pre>\n\n</pre>  $\\displaystyle R_3 - \\left(4\\right)R_1 \\rightarrow R_3$   $\\displaystyle \\left[\\begin{array}{ccc}-1 &amp; 3 &amp; -4\\\\0 &amp; 10 &amp; -7\\\\0 &amp; -10 &amp; 7\\end{array}\\right]$  <pre>\n\n</pre>  $\\displaystyle R_3 - \\left(-1\\right)R_2 \\rightarrow R_3$   $\\displaystyle \\left[\\begin{array}{ccc}-1 &amp; 3 &amp; -4\\\\0 &amp; 10 &amp; -7\\\\0 &amp; 0 &amp; 0\\end{array}\\right]$  <pre>\n\n</pre>  $\\displaystyle \\left(-1\\right) R_1 \\rightarrow R_1$   $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; -3 &amp; 4\\\\0 &amp; 10 &amp; -7\\\\0 &amp; 0 &amp; 0\\end{array}\\right]$  <pre>\n\n</pre>  $\\displaystyle \\left(0.1\\right) R_2 \\rightarrow R_2$   $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; -3 &amp; 4\\\\0 &amp; 1 &amp; - \\frac{7}{10}\\\\0 &amp; 0 &amp; 0\\end{array}\\right]$  <pre>\n\n</pre>  $\\displaystyle R_1 - \\left(-3\\right)R_2 \\rightarrow R_1$   $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 0 &amp; \\frac{19}{10}\\\\0 &amp; 1 &amp; - \\frac{7}{10}\\\\0 &amp; 0 &amp; 0\\end{array}\\right]$  <pre>\n\n</pre> Out[12]:  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 0 &amp; \\frac{19}{10}\\\\0 &amp; 1 &amp; - \\frac{7}{10}\\\\0 &amp; 0 &amp; 0\\end{array}\\right]$  In\u00a0[13]: Copied! <pre>A = Matrix.from_str(\"1 -1 0; 2 -2 1; 1 2 3\")\nA\n</pre> A = Matrix.from_str(\"1 -1 0; 2 -2 1; 1 2 3\") A Out[13]:  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; -1 &amp; 0\\\\2 &amp; -2 &amp; 1\\\\1 &amp; 2 &amp; 3\\end{array}\\right]$  In\u00a0[14]: Copied! <pre>(A.copy()\n .reduce_row(1, 2, 0)\n .reduce_row(2, 1, 0)\n .swap_row(1, 2)\n .scale_row(1, sym.Rational(1, 3)) # To avoid floating point errors\n .reduce_row(1, 1, 2)\n .reduce_row(0, -1, 1)\n)\n</pre> (A.copy()  .reduce_row(1, 2, 0)  .reduce_row(2, 1, 0)  .swap_row(1, 2)  .scale_row(1, sym.Rational(1, 3)) # To avoid floating point errors  .reduce_row(1, 1, 2)  .reduce_row(0, -1, 1) )  $\\displaystyle R_2 - \\left(2\\right)R_1 \\rightarrow R_2$   $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; -1 &amp; 0\\\\0 &amp; 0 &amp; 1\\\\1 &amp; 2 &amp; 3\\end{array}\\right]$  <pre>\n\n</pre>  $\\displaystyle R_3 - \\left(1\\right)R_1 \\rightarrow R_3$   $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; -1 &amp; 0\\\\0 &amp; 0 &amp; 1\\\\0 &amp; 3 &amp; 3\\end{array}\\right]$  <pre>\n\n</pre>  $\\displaystyle R_2 \\leftrightarrow R_3$   $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; -1 &amp; 0\\\\0 &amp; 3 &amp; 3\\\\0 &amp; 0 &amp; 1\\end{array}\\right]$  <pre>\n\n</pre>  $\\displaystyle \\left(\\frac{1}{3}\\right) R_2 \\rightarrow R_2$   $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; -1 &amp; 0\\\\0 &amp; 1 &amp; 1\\\\0 &amp; 0 &amp; 1\\end{array}\\right]$  <pre>\n\n</pre>  $\\displaystyle R_2 - \\left(1\\right)R_3 \\rightarrow R_2$   $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; -1 &amp; 0\\\\0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 1\\end{array}\\right]$  <pre>\n\n</pre>  $\\displaystyle R_1 - \\left(-1\\right)R_2 \\rightarrow R_1$   $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 1\\end{array}\\right]$  <pre>\n\n</pre> Out[14]:  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 1\\end{array}\\right]$  In\u00a0[15]: Copied! <pre>mat = Matrix.from_str(\"-1 3; 3 -2\")\nmat.inverse(verbosity=2)\n</pre> mat = Matrix.from_str(\"-1 3; 3 -2\") mat.inverse(verbosity=2) <pre>Left inverse found!\nRight inverse found!\nBefore RREF: [self | eye]\n</pre>  $\\displaystyle \\left[\\begin{array}{cc|c|c}-1 &amp; 3 &amp; 1 &amp; 0\\\\3 &amp; -2 &amp; 0 &amp; 1\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cc|c|c}1 &amp; 0 &amp; \\frac{2}{7} &amp; \\frac{3}{7}\\\\0 &amp; 1 &amp; \\frac{3}{7} &amp; \\frac{1}{7}\\end{array}\\right], \\quad\\text{pivots} = (0, 1)\\right\\}$  Out[15]:  $\\displaystyle \\left[\\begin{array}{cc}\\frac{2}{7} &amp; \\frac{3}{7}\\\\\\frac{3}{7} &amp; \\frac{1}{7}\\end{array}\\right]$  In\u00a0[16]: Copied! <pre>mat = Matrix.from_str(\"-1 3 -4; 2 4 1; -4 2 -9\")\n\ntry:\n    mat.inverse(verbosity=2) # without specifying the option, no rref will be shown\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n</pre> mat = Matrix.from_str(\"-1 3 -4; 2 4 1; -4 2 -9\")  try:     mat.inverse(verbosity=2) # without specifying the option, no rref will be shown except ValueError as e:     print(f\"Error: {e}\") <pre>Error: No inverse found! Rank: 2, Rows: 3, Columns: 3. Try pseudo-inverse: .pinv()\n</pre> In\u00a0[17]: Copied! <pre>try:\n    mat.inverse(\"both\", verbosity=2)\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n</pre> try:     mat.inverse(\"both\", verbosity=2) except ValueError as e:     print(f\"Error: {e}\") <pre>Before RREF: [self | eye]\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc|c|c|c}-1 &amp; 3 &amp; -4 &amp; 1 &amp; 0 &amp; 0\\\\2 &amp; 4 &amp; 1 &amp; 0 &amp; 1 &amp; 0\\\\-4 &amp; 2 &amp; -9 &amp; 0 &amp; 0 &amp; 1\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc|c|c|c}1 &amp; 0 &amp; \\frac{19}{10} &amp; 0 &amp; \\frac{1}{10} &amp; - \\frac{1}{5}\\\\0 &amp; 1 &amp; - \\frac{7}{10} &amp; 0 &amp; \\frac{1}{5} &amp; \\frac{1}{10}\\\\0 &amp; 0 &amp; 0 &amp; 1 &amp; - \\frac{1}{2} &amp; - \\frac{1}{2}\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 3)\\right\\}$  <pre>Error: No both inverse found! Try pseudo-inverse: .pinv()\n</pre> In\u00a0[18]: Copied! <pre>a, b, c = sym.symbols(\"a b c\")\nmat = Matrix.from_str(\"1 1 1; a b c; a**2 b**2 c**2\")\nmat\n</pre> a, b, c = sym.symbols(\"a b c\") mat = Matrix.from_str(\"1 1 1; a b c; a**2 b**2 c**2\") mat Out[18]:  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 1 &amp; 1\\\\a &amp; b &amp; c\\\\a^{2} &amp; b^{2} &amp; c^{2}\\end{array}\\right]$  In\u00a0[19]: Copied! <pre>inv = mat.inverse(verbosity=2)\ninv\n</pre> inv = mat.inverse(verbosity=2) inv <pre>Left inverse found!\nRight inverse found!\nBefore RREF: [self | eye]\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc|c|c|c}1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0\\\\a &amp; b &amp; c &amp; 0 &amp; 1 &amp; 0\\\\a^{2} &amp; b^{2} &amp; c^{2} &amp; 0 &amp; 0 &amp; 1\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc|c|c|c}1 &amp; 0 &amp; 0 &amp; \\frac{b c}{a^{2} - a b - a c + b c} &amp; \\frac{- b - c}{a^{2} - a b - a c + b c} &amp; \\frac{1}{a^{2} - a b - a c + b c}\\\\0 &amp; 1 &amp; 0 &amp; - \\frac{a c}{a b - a c - b^{2} + b c} &amp; \\frac{a + c}{a b - a c - b^{2} + b c} &amp; - \\frac{1}{a b - a c - b^{2} + b c}\\\\0 &amp; 0 &amp; 1 &amp; \\frac{a b}{a b - a c - b c + c^{2}} &amp; \\frac{- a - b}{a b - a c - b c + c^{2}} &amp; \\frac{1}{a b - a c - b c + c^{2}}\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 2)\\right\\}$  Out[19]:  $\\displaystyle \\left[\\begin{array}{ccc}\\frac{b c}{a^{2} - a b - a c + b c} &amp; \\frac{- b - c}{a^{2} - a b - a c + b c} &amp; \\frac{1}{a^{2} - a b - a c + b c}\\\\- \\frac{a c}{a b - a c - b^{2} + b c} &amp; \\frac{a + c}{a b - a c - b^{2} + b c} &amp; - \\frac{1}{a b - a c - b^{2} + b c}\\\\\\frac{a b}{a b - a c - b c + c^{2}} &amp; \\frac{- a - b}{a b - a c - b c + c^{2}} &amp; \\frac{1}{a b - a c - b c + c^{2}}\\end{array}\\right]$  In\u00a0[20]: Copied! <pre># For inverse to exist, all the divisors must be non-zero\n\ndivisors = 1\nfor entry in inv.select_cols(0): # same divisor along columns\n    _, divisor = sym.fraction(entry)\n    divisors *= divisor\n\nsym.solve(divisors)\n# This means that a != b and a != c and b != c for the inverse to exist\n</pre> # For inverse to exist, all the divisors must be non-zero  divisors = 1 for entry in inv.select_cols(0): # same divisor along columns     _, divisor = sym.fraction(entry)     divisors *= divisor  sym.solve(divisors) # This means that a != b and a != c and b != c for the inverse to exist Out[20]:  $\\displaystyle \\left[ \\left\\{ a : b\\right\\}, \\  \\left\\{ a : c\\right\\}, \\  \\left\\{ b : c\\right\\}\\right]$  In\u00a0[21]: Copied! <pre># Alternative Method via determinant\n\ndet = mat.det()\ndet.factor()\n</pre> # Alternative Method via determinant  det = mat.det() det.factor() Out[21]:  $\\displaystyle - \\left(a - b\\right) \\left(a - c\\right) \\left(b - c\\right)$"},{"location":"tutorials/tut02/#tutorial-2-ay2425-sem-1","title":"Tutorial 2 (AY24/25 Sem 1)\u00b6","text":""},{"location":"tutorials/tut02/#question-2","title":"Question 2\u00b6","text":""},{"location":"tutorials/tut02/#a","title":"(a)\u00b6","text":"<p>Let $A = \\begin{pmatrix} 1 &amp; 1 &amp; 0 &amp; 1  \\\\  0 &amp; 1 &amp; 1 &amp; 0  \\\\  0 &amp; 0 &amp; 1 &amp; 1 \\end{pmatrix}$. Find a $4 \\times 3$ matrix $X$ such that $AX = I_3$.</p>"},{"location":"tutorials/tut02/#b","title":"(b)\u00b6","text":"<p>Let $B = \\begin{pmatrix} 1 &amp; 0 &amp; 1  \\\\  1 &amp; 1 &amp; 0  \\\\  0 &amp; 1 &amp; 1  \\\\  0 &amp; 0 &amp; 1 \\end{pmatrix}$. Find a $3 \\times 4$ matrix $Y$ such that $YB = I_3$.</p>"},{"location":"tutorials/tut02/#question-3","title":"Question 3\u00b6","text":"<p>(i) Reduce the following matrices $A$ to its reduced row-echelon form $R$.</p> <p>(ii) For each of the elementary row operation, write the corresponding elementary matrix.</p> <p>(iii) Write the matrices $A$ in the form $E_1 E_2 \\ldots E_n R$ where $E_1, E_2, \\ldots, E_n$ are elementary matrices and $R$ is the reduced row-echelon form of $A$.</p>"},{"location":"tutorials/tut02/#a","title":"(a)\u00b6","text":"<p>$A = \\begin{pmatrix} 5 &amp; -2 &amp; 6 &amp; 0 \\\\ -2 &amp; 1 &amp; 3 &amp; 1 \\end{pmatrix}$.</p>"},{"location":"tutorials/tut02/#b","title":"(b)\u00b6","text":"<p>$A = \\begin{pmatrix} -1 &amp; 3 &amp; -4 \\\\ 2 &amp; 4 &amp; 1 \\\\ -4 &amp; 2 &amp; -9 \\end{pmatrix}$.</p>"},{"location":"tutorials/tut02/#c","title":"(c)\u00b6","text":"<p>$A = \\begin{pmatrix} 1 &amp; -1 &amp; 0 \\\\ 2 &amp; -2 &amp; 1 \\\\ 1 &amp; 2 &amp; 3 \\end{pmatrix}$.</p>"},{"location":"tutorials/tut02/#question-4","title":"Question 4\u00b6","text":"<p>Determine if the following matrices are invertible. If the matrix is invertible, find its inverse.</p>"},{"location":"tutorials/tut02/#a","title":"(a)\u00b6","text":"<p>$\\begin{pmatrix} -1 &amp; 3 \\\\ 3 &amp; -2 \\end{pmatrix}$.</p>"},{"location":"tutorials/tut02/#b","title":"(b)\u00b6","text":"<p>$\\begin{pmatrix} -1 &amp; 3 &amp; -4 \\\\ 2 &amp; 4 &amp; 1 \\\\ -4 &amp; 2 &amp; -9 \\end{pmatrix}$.</p>"},{"location":"tutorials/tut02/#question-5","title":"Question 5\u00b6","text":"<p>Write down the conditions so that the matrix $\\begin{pmatrix} 1 &amp; 1 &amp; 1 \\\\ a &amp; b &amp; c \\\\ a^2 &amp; b^2 &amp; c^2 \\end{pmatrix}$ is invertible.</p>"},{"location":"tutorials/tut03/","title":"Tutorial 3","text":"In\u00a0[1]: Copied! <pre>import sympy as sym\nfrom ma1522 import Matrix\n</pre> import sympy as sym from ma1522 import Matrix In\u00a0[2]: Copied! <pre>E_1 = Matrix.eye(4).scale_row(1, sym.Rational(1, 2))\nE_2 = Matrix.eye(4).reduce_row(0, 1, 1)\nE_3 = Matrix.eye(4).swap_row(1, 3)\nE_4 = Matrix.eye(4).reduce_row(2, -3, 0)\n</pre> E_1 = Matrix.eye(4).scale_row(1, sym.Rational(1, 2)) E_2 = Matrix.eye(4).reduce_row(0, 1, 1) E_3 = Matrix.eye(4).swap_row(1, 3) E_4 = Matrix.eye(4).reduce_row(2, -3, 0)  $\\displaystyle \\left(\\frac{1}{2}\\right) R_2 \\rightarrow R_2$   $\\displaystyle \\left[\\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; \\frac{1}{2} &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{array}\\right]$  <pre>\n\n</pre>  $\\displaystyle R_1 - \\left(1\\right)R_2 \\rightarrow R_1$   $\\displaystyle \\left[\\begin{array}{cccc}1 &amp; -1 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{array}\\right]$  <pre>\n\n</pre>  $\\displaystyle R_2 \\leftrightarrow R_4$   $\\displaystyle \\left[\\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\end{array}\\right]$  <pre>\n\n</pre>  $\\displaystyle R_3 - \\left(-3\\right)R_1 \\rightarrow R_3$   $\\displaystyle \\left[\\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\3 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{array}\\right]$  <pre>\n\n</pre> In\u00a0[3]: Copied! <pre># The matrix A^-1 is the product of these elementary matrices\nE_1**-1, E_2**-1, E_3**-1, E_4**-1\n</pre> # The matrix A^-1 is the product of these elementary matrices E_1**-1, E_2**-1, E_3**-1, E_4**-1 Out[3]:  $\\displaystyle \\left( \\left[\\begin{matrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 2 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{matrix}\\right], \\  \\left[\\begin{matrix}1 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{matrix}\\right], \\  \\left[\\begin{matrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\end{matrix}\\right], \\  \\left[\\begin{matrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\-3 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{matrix}\\right]\\right)$  In\u00a0[4]: Copied! <pre>A = Matrix.from_str(\"2 -1 2; -6 0 -2; 8 -1 5\")\nb = Matrix.from_str(\"1; 0; 4\")\n\naug_mat = A.row_join(b)\naug_mat\n</pre> A = Matrix.from_str(\"2 -1 2; -6 0 -2; 8 -1 5\") b = Matrix.from_str(\"1; 0; 4\")  aug_mat = A.row_join(b) aug_mat Out[4]:  $\\displaystyle \\left[\\begin{array}{ccc|c}2 &amp; -1 &amp; 2 &amp; 1\\\\-6 &amp; 0 &amp; -2 &amp; 0\\\\8 &amp; -1 &amp; 5 &amp; 4\\end{array}\\right]$  In\u00a0[5]: Copied! <pre>plu = A.ref(verbosity=2)\nplu # The LU factorization of A is given by the matrices L and U\n# You may ignore P as it is the identity matrix, which suggest that it is LU factorisable.\n</pre> plu = A.ref(verbosity=2) plu # The LU factorization of A is given by the matrices L and U # You may ignore P as it is the identity matrix, which suggest that it is LU factorisable.  $\\displaystyle R_2 - \\left(-3\\right)R_1 \\rightarrow R_2$   $\\displaystyle \\left[\\begin{array}{ccc}2 &amp; -1 &amp; 2\\\\0 &amp; -3 &amp; 4\\\\8 &amp; -1 &amp; 5\\end{array}\\right]$  <pre>\n\n</pre>  $\\displaystyle R_3 - \\left(4\\right)R_1 \\rightarrow R_3$   $\\displaystyle \\left[\\begin{array}{ccc}2 &amp; -1 &amp; 2\\\\0 &amp; -3 &amp; 4\\\\0 &amp; 3 &amp; -3\\end{array}\\right]$  <pre>\n\n</pre>  $\\displaystyle R_3 - \\left(-1\\right)R_2 \\rightarrow R_3$   $\\displaystyle \\left[\\begin{array}{ccc}2 &amp; -1 &amp; 2\\\\0 &amp; -3 &amp; 4\\\\0 &amp; 0 &amp; 1\\end{array}\\right]$  <pre>\n\n</pre> Out[5]:  $\\left[\\begin{array}{ccc}1 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 1\\end{array}\\right]\\left[\\begin{array}{ccc}1 &amp; 0 &amp; 0\\\\-3 &amp; 1 &amp; 0\\\\4 &amp; -1 &amp; 1\\end{array}\\right]\\left[\\begin{array}{ccc}2 &amp; -1 &amp; 2\\\\0 &amp; -3 &amp; 4\\\\0 &amp; 0 &amp; 1\\end{array}\\right]$  In\u00a0[6]: Copied! <pre>y = plu.L.solve(b)\ny\n</pre> y = plu.L.solve(b) y Out[6]:  $\\displaystyle \\left[ \\left[\\begin{array}{c}1\\\\3\\\\3\\end{array}\\right]\\right]$  In\u00a0[7]: Copied! <pre>x = plu.U.solve(y)\nx\n</pre> x = plu.U.solve(y) x <pre>\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[7], line 1\n----&gt; 1 x = plu.U.solve(y)\n      2 x\n\nFile ~/work/linear-algebra/linear-algebra/src/ma1522/symbolic.py:1852, in Matrix.solve(self, rhs)\n   1850 # Use sympy's solve function directly\n   1851 x = Matrix.create_unk_matrix(r=self.cols, c=1)\n-&gt; 1852 solution = sym.solve(self @ x - rhs, x.free_symbols, dict=True)\n   1854 if len(solution) == 0:\n   1855     # If no solution is found (e.g., inconsistent system or empty list), raise an error\n   1856     display(self.row_join(rhs, aug_line=True).rref())\n\nFile ~/work/linear-algebra/linear-algebra/.venv/lib/python3.10/site-packages/sympy/core/decorators.py:106, in call_highest_priority.&lt;locals&gt;.priority_decorator.&lt;locals&gt;.binary_op_wrapper(self, other)\n    104         if f is not None:\n    105             return f(self)\n--&gt; 106 return func(self, other)\n\nFile ~/work/linear-algebra/linear-algebra/.venv/lib/python3.10/site-packages/sympy/matrices/matrixbase.py:3047, in MatrixBase.__sub__(self, a)\n   3045 @call_highest_priority('__rsub__')\n   3046 def __sub__(self, a):\n-&gt; 3047     return self + (-a)\n\nTypeError: bad operand type for unary -: 'list'</pre> In\u00a0[8]: Copied! <pre>A = Matrix.from_str(\"2 -4 4 -2; 6 -9 7 -3; -1 -4 8 0\")\nb = Matrix.from_str(\"0; 0; 5\")\n\naug_mat = A.row_join(b)\naug_mat\n</pre> A = Matrix.from_str(\"2 -4 4 -2; 6 -9 7 -3; -1 -4 8 0\") b = Matrix.from_str(\"0; 0; 5\")  aug_mat = A.row_join(b) aug_mat Out[8]:  $\\displaystyle \\left[\\begin{array}{cccc|c}2 &amp; -4 &amp; 4 &amp; -2 &amp; 0\\\\6 &amp; -9 &amp; 7 &amp; -3 &amp; 0\\\\-1 &amp; -4 &amp; 8 &amp; 0 &amp; 5\\end{array}\\right]$  In\u00a0[9]: Copied! <pre>plu = A.ref(verbosity=2)\nplu\n</pre> plu = A.ref(verbosity=2) plu  $\\displaystyle R_2 - \\left(3\\right)R_1 \\rightarrow R_2$   $\\displaystyle \\left[\\begin{array}{cccc}2 &amp; -4 &amp; 4 &amp; -2\\\\0 &amp; 3 &amp; -5 &amp; 3\\\\-1 &amp; -4 &amp; 8 &amp; 0\\end{array}\\right]$  <pre>\n\n</pre>  $\\displaystyle R_3 - \\left(- \\frac{1}{2}\\right)R_1 \\rightarrow R_3$   $\\displaystyle \\left[\\begin{array}{cccc}2 &amp; -4 &amp; 4 &amp; -2\\\\0 &amp; 3 &amp; -5 &amp; 3\\\\0 &amp; -6 &amp; 10 &amp; -1\\end{array}\\right]$  <pre>\n\n</pre>  $\\displaystyle R_3 - \\left(-2\\right)R_2 \\rightarrow R_3$   $\\displaystyle \\left[\\begin{array}{cccc}2 &amp; -4 &amp; 4 &amp; -2\\\\0 &amp; 3 &amp; -5 &amp; 3\\\\0 &amp; 0 &amp; 0 &amp; 5\\end{array}\\right]$  <pre>\n\n</pre> Out[9]:  $\\left[\\begin{array}{ccc}1 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 1\\end{array}\\right]\\left[\\begin{array}{ccc}1 &amp; 0 &amp; 0\\\\3 &amp; 1 &amp; 0\\\\- \\frac{1}{2} &amp; -2 &amp; 1\\end{array}\\right]\\left[\\begin{array}{cccc}2 &amp; -4 &amp; 4 &amp; -2\\\\0 &amp; 3 &amp; -5 &amp; 3\\\\0 &amp; 0 &amp; 0 &amp; 5\\end{array}\\right]$  In\u00a0[10]: Copied! <pre>y = plu.L.solve(b)\ny\n</pre> y = plu.L.solve(b) y Out[10]:  $\\displaystyle \\left[ \\left[\\begin{array}{c}0\\\\0\\\\5\\end{array}\\right]\\right]$  In\u00a0[11]: Copied! <pre>x = plu.U.solve(y)\nx\n</pre> x = plu.U.solve(y) x <pre>\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[11], line 1\n----&gt; 1 x = plu.U.solve(y)\n      2 x\n\nFile ~/work/linear-algebra/linear-algebra/src/ma1522/symbolic.py:1852, in Matrix.solve(self, rhs)\n   1850 # Use sympy's solve function directly\n   1851 x = Matrix.create_unk_matrix(r=self.cols, c=1)\n-&gt; 1852 solution = sym.solve(self @ x - rhs, x.free_symbols, dict=True)\n   1854 if len(solution) == 0:\n   1855     # If no solution is found (e.g., inconsistent system or empty list), raise an error\n   1856     display(self.row_join(rhs, aug_line=True).rref())\n\nFile ~/work/linear-algebra/linear-algebra/.venv/lib/python3.10/site-packages/sympy/core/decorators.py:106, in call_highest_priority.&lt;locals&gt;.priority_decorator.&lt;locals&gt;.binary_op_wrapper(self, other)\n    104         if f is not None:\n    105             return f(self)\n--&gt; 106 return func(self, other)\n\nFile ~/work/linear-algebra/linear-algebra/.venv/lib/python3.10/site-packages/sympy/matrices/matrixbase.py:3047, in MatrixBase.__sub__(self, a)\n   3045 @call_highest_priority('__rsub__')\n   3046 def __sub__(self, a):\n-&gt; 3047     return self + (-a)\n\nTypeError: bad operand type for unary -: 'list'</pre> In\u00a0[12]: Copied! <pre>A = Matrix.from_str(\"2 -6 6; -4 5 -7; 3 5 -1; -6 4 -8; 8 -3 9\")\nA\n</pre> A = Matrix.from_str(\"2 -6 6; -4 5 -7; 3 5 -1; -6 4 -8; 8 -3 9\") A Out[12]:  $\\displaystyle \\left[\\begin{array}{ccc}2 &amp; -6 &amp; 6\\\\-4 &amp; 5 &amp; -7\\\\3 &amp; 5 &amp; -1\\\\-6 &amp; 4 &amp; -8\\\\8 &amp; -3 &amp; 9\\end{array}\\right]$  In\u00a0[13]: Copied! <pre>plu = A.ref(verbosity=2)\nplu\n</pre> plu = A.ref(verbosity=2) plu  $\\displaystyle R_2 - \\left(-2\\right)R_1 \\rightarrow R_2$   $\\displaystyle \\left[\\begin{array}{ccc}2 &amp; -6 &amp; 6\\\\0 &amp; -7 &amp; 5\\\\3 &amp; 5 &amp; -1\\\\-6 &amp; 4 &amp; -8\\\\8 &amp; -3 &amp; 9\\end{array}\\right]$  <pre>\n\n</pre>  $\\displaystyle R_3 - \\left(\\frac{3}{2}\\right)R_1 \\rightarrow R_3$   $\\displaystyle \\left[\\begin{array}{ccc}2 &amp; -6 &amp; 6\\\\0 &amp; -7 &amp; 5\\\\0 &amp; 14 &amp; -10\\\\-6 &amp; 4 &amp; -8\\\\8 &amp; -3 &amp; 9\\end{array}\\right]$  <pre>\n\n</pre>  $\\displaystyle R_4 - \\left(-3\\right)R_1 \\rightarrow R_4$   $\\displaystyle \\left[\\begin{array}{ccc}2 &amp; -6 &amp; 6\\\\0 &amp; -7 &amp; 5\\\\0 &amp; 14 &amp; -10\\\\0 &amp; -14 &amp; 10\\\\8 &amp; -3 &amp; 9\\end{array}\\right]$  <pre>\n\n</pre>  $\\displaystyle R_5 - \\left(4\\right)R_1 \\rightarrow R_5$   $\\displaystyle \\left[\\begin{array}{ccc}2 &amp; -6 &amp; 6\\\\0 &amp; -7 &amp; 5\\\\0 &amp; 14 &amp; -10\\\\0 &amp; -14 &amp; 10\\\\0 &amp; 21 &amp; -15\\end{array}\\right]$  <pre>\n\n</pre>  $\\displaystyle R_3 - \\left(-2\\right)R_2 \\rightarrow R_3$   $\\displaystyle \\left[\\begin{array}{ccc}2 &amp; -6 &amp; 6\\\\0 &amp; -7 &amp; 5\\\\0 &amp; 0 &amp; 0\\\\0 &amp; -14 &amp; 10\\\\0 &amp; 21 &amp; -15\\end{array}\\right]$  <pre>\n\n</pre>  $\\displaystyle R_4 - \\left(2\\right)R_2 \\rightarrow R_4$   $\\displaystyle \\left[\\begin{array}{ccc}2 &amp; -6 &amp; 6\\\\0 &amp; -7 &amp; 5\\\\0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0\\\\0 &amp; 21 &amp; -15\\end{array}\\right]$  <pre>\n\n</pre>  $\\displaystyle R_5 - \\left(-3\\right)R_2 \\rightarrow R_5$   $\\displaystyle \\left[\\begin{array}{ccc}2 &amp; -6 &amp; 6\\\\0 &amp; -7 &amp; 5\\\\0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0\\end{array}\\right]$  <pre>\n\n</pre> Out[13]:  $\\left[\\begin{array}{ccccc}1 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 1\\end{array}\\right]\\left[\\begin{array}{ccccc}1 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\-2 &amp; 1 &amp; 0 &amp; 0 &amp; 0\\\\\\frac{3}{2} &amp; -2 &amp; 1 &amp; 0 &amp; 0\\\\-3 &amp; 2 &amp; 0 &amp; 1 &amp; 0\\\\4 &amp; -3 &amp; 0 &amp; 0 &amp; 1\\end{array}\\right]\\left[\\begin{array}{ccc}2 &amp; -6 &amp; 6\\\\0 &amp; -7 &amp; 5\\\\0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0\\end{array}\\right]$  In\u00a0[14]: Copied! <pre>A = Matrix.from_str(\"-x 1 0; 0 -x 1; 2 -5 4-x\")\nA\n</pre> A = Matrix.from_str(\"-x 1 0; 0 -x 1; 2 -5 4-x\") A Out[14]:  $\\displaystyle \\left[\\begin{array}{ccc}- x &amp; 1 &amp; 0\\\\0 &amp; - x &amp; 1\\\\2 &amp; -5 &amp; 4 - x\\end{array}\\right]$  In\u00a0[15]: Copied! <pre>A.det().factor()\n</pre> A.det().factor() Out[15]:  $\\displaystyle - \\left(x - 2\\right) \\left(x - 1\\right)^{2}$  In\u00a0[16]: Copied! <pre>a, b, c, p, q, r, u, v, w, x = sym.symbols(\"a b c p q r u v w x\")\n\nlhs = Matrix([[a + p*x, b + q*x, c + r*x],\n              [p + u*x, q + v*x, r + w*x],\n              [u + a*x, v + b*x, w + c*x]])\n\nlhs\n</pre> a, b, c, p, q, r, u, v, w, x = sym.symbols(\"a b c p q r u v w x\")  lhs = Matrix([[a + p*x, b + q*x, c + r*x],               [p + u*x, q + v*x, r + w*x],               [u + a*x, v + b*x, w + c*x]])  lhs Out[16]:  $\\displaystyle \\left[\\begin{array}{ccc}a + p x &amp; b + q x &amp; c + r x\\\\p + u x &amp; q + v x &amp; r + w x\\\\a x + u &amp; b x + v &amp; c x + w\\end{array}\\right]$  In\u00a0[17]: Copied! <pre>lhs.det()\n</pre> lhs.det() Out[17]:  $\\displaystyle a q w x^{3} + a q w - a r v x^{3} - a r v - b p w x^{3} - b p w + b r u x^{3} + b r u + c p v x^{3} + c p v - c q u x^{3} - c q u$  In\u00a0[18]: Copied! <pre>rhs = Matrix.from_str(\"a b c; p q r; u v w\")\nrhs\n</pre> rhs = Matrix.from_str(\"a b c; p q r; u v w\") rhs Out[18]:  $\\displaystyle \\left[\\begin{array}{ccc}a &amp; b &amp; c\\\\p &amp; q &amp; r\\\\u &amp; v &amp; w\\end{array}\\right]$  In\u00a0[19]: Copied! <pre>rhs.det()\n</pre> rhs.det() Out[19]:  $\\displaystyle a q w - a r v - b p w + b r u + c p v - c q u$  In\u00a0[20]: Copied! <pre>sym.simplify(lhs.det() / rhs.det())\n</pre> sym.simplify(lhs.det() / rhs.det()) Out[20]:  $\\displaystyle \\frac{a q w x^{3} + a q w - a r v x^{3} - a r v - b p w x^{3} - b p w + b r u x^{3} + b r u + c p v x^{3} + c p v - c q u x^{3} - c q u}{a q w - a r v - b p w + b r u + c p v - c q u}$  In\u00a0[21]: Copied! <pre># Alternative way: less brute force\n\n(lhs.copy()\n .reduce_row(1, x, 2)\n .reduce_row(0, x, 1)\n .scale_row(0, 1/(1 + x**3))\n .reduce_row(1, -x**2, 0)\n .reduce_row(2, x, 0)\n )\n</pre> # Alternative way: less brute force  (lhs.copy()  .reduce_row(1, x, 2)  .reduce_row(0, x, 1)  .scale_row(0, 1/(1 + x**3))  .reduce_row(1, -x**2, 0)  .reduce_row(2, x, 0)  )  $\\displaystyle R_2 - \\left(x\\right)R_3 \\rightarrow R_2$   $\\displaystyle \\left[\\begin{array}{ccc}a + p x &amp; b + q x &amp; c + r x\\\\- a x^{2} + p &amp; - b x^{2} + q &amp; - c x^{2} + r\\\\a x + u &amp; b x + v &amp; c x + w\\end{array}\\right]$  <pre>\n\n</pre>  $\\displaystyle R_1 - \\left(x\\right)R_2 \\rightarrow R_1$   $\\displaystyle \\left[\\begin{array}{ccc}a x^{3} + a &amp; b x^{3} + b &amp; c x^{3} + c\\\\- a x^{2} + p &amp; - b x^{2} + q &amp; - c x^{2} + r\\\\a x + u &amp; b x + v &amp; c x + w\\end{array}\\right]$  <pre>\n\n</pre>  $\\displaystyle \\left(\\frac{1}{x^{3} + 1}\\right) R_1 \\rightarrow R_1$   $\\displaystyle \\left[\\begin{array}{ccc}a &amp; b &amp; c\\\\- a x^{2} + p &amp; - b x^{2} + q &amp; - c x^{2} + r\\\\a x + u &amp; b x + v &amp; c x + w\\end{array}\\right]$  <pre>\n\n</pre>  $\\displaystyle R_2 - \\left(- x^{2}\\right)R_1 \\rightarrow R_2$   $\\displaystyle \\left[\\begin{array}{ccc}a &amp; b &amp; c\\\\p &amp; q &amp; r\\\\a x + u &amp; b x + v &amp; c x + w\\end{array}\\right]$  <pre>\n\n</pre>  $\\displaystyle R_3 - \\left(x\\right)R_1 \\rightarrow R_3$   $\\displaystyle \\left[\\begin{array}{ccc}a &amp; b &amp; c\\\\p &amp; q &amp; r\\\\u &amp; v &amp; w\\end{array}\\right]$  <pre>\n\n</pre> Out[21]:  $\\displaystyle \\left[\\begin{array}{ccc}a &amp; b &amp; c\\\\p &amp; q &amp; r\\\\u &amp; v &amp; w\\end{array}\\right]$  In\u00a0[22]: Copied! <pre># Therefore, det has only been scaled by a factor of 1 + x**3\n</pre> # Therefore, det has only been scaled by a factor of 1 + x**3 In\u00a0[23]: Copied! <pre>Matrix.from_str(\"1 5 3; 0 2 -2; 0 1 3\").cramer_solve(Matrix.from_str(\"1; 2; 0\"))\n</pre> Matrix.from_str(\"1 5 3; 0 2 -2; 0 1 3\").cramer_solve(Matrix.from_str(\"1; 2; 0\"))   <pre>Modified matrix for column 1:\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 5 &amp; 3\\\\2 &amp; 2 &amp; -2\\\\0 &amp; 1 &amp; 3\\end{array}\\right]$   $\\displaystyle \\text{Determinant for column }1: -2$  <pre>Modified matrix for column 2:\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 1 &amp; 3\\\\0 &amp; 2 &amp; -2\\\\0 &amp; 0 &amp; 3\\end{array}\\right]$   $\\displaystyle \\text{Determinant for column }2: \\frac{3}{4}$  <pre>Modified matrix for column 3:\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 5 &amp; 1\\\\0 &amp; 2 &amp; 2\\\\0 &amp; 1 &amp; 0\\end{array}\\right]$   $\\displaystyle \\text{Determinant for column }3: - \\frac{1}{4}$  Out[23]:  $\\displaystyle \\left[\\begin{array}{c}-2\\\\\\frac{3}{4}\\\\- \\frac{1}{4}\\end{array}\\right]$  In\u00a0[24]: Copied! <pre>mat = Matrix.from_str(\"1 5 3; 0 2 -2; 0 1 3\")\nrhs = Matrix.from_str(\"1; 2; 0\")\n\nmat.cramer_solve(rhs, verbosity=2)\n</pre> mat = Matrix.from_str(\"1 5 3; 0 2 -2; 0 1 3\") rhs = Matrix.from_str(\"1; 2; 0\")  mat.cramer_solve(rhs, verbosity=2) <pre>Modified matrix for column 1:\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 5 &amp; 3\\\\2 &amp; 2 &amp; -2\\\\0 &amp; 1 &amp; 3\\end{array}\\right]$   $\\displaystyle \\text{Determinant for column }1: -2$  <pre>Modified matrix for column 2:\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 1 &amp; 3\\\\0 &amp; 2 &amp; -2\\\\0 &amp; 0 &amp; 3\\end{array}\\right]$   $\\displaystyle \\text{Determinant for column }2: \\frac{3}{4}$  <pre>Modified matrix for column 3:\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 5 &amp; 1\\\\0 &amp; 2 &amp; 2\\\\0 &amp; 1 &amp; 0\\end{array}\\right]$   $\\displaystyle \\text{Determinant for column }3: - \\frac{1}{4}$  Out[24]:  $\\displaystyle \\left[\\begin{array}{c}-2\\\\\\frac{3}{4}\\\\- \\frac{1}{4}\\end{array}\\right]$  In\u00a0[25]: Copied! <pre>A = Matrix.from_str(\"1 -1 2; 0 2 1; 3 0 6\")\n\nA\n</pre> A = Matrix.from_str(\"1 -1 2; 0 2 1; 3 0 6\")  A Out[25]:  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; -1 &amp; 2\\\\0 &amp; 2 &amp; 1\\\\3 &amp; 0 &amp; 6\\end{array}\\right]$  In\u00a0[26]: Copied! <pre># Note: Please use `adj` method instead of `adjoint` or `adjugate` \n# even if they are aliased correctly based on MA1522 definitions as\n# they are not the same as the SymPy's `adjoint` or `adjugate` methods.\n\nA.adj()\n</pre> # Note: Please use `adj` method instead of `adjoint` or `adjugate`  # even if they are aliased correctly based on MA1522 definitions as # they are not the same as the SymPy's `adjoint` or `adjugate` methods.  A.adj() Out[26]:  $\\displaystyle \\left[\\begin{matrix}12 &amp; 6 &amp; -5\\\\3 &amp; 0 &amp; -1\\\\-6 &amp; -3 &amp; 2\\end{matrix}\\right]$  In\u00a0[27]: Copied! <pre>A.adjoint()\n</pre> A.adjoint() <pre>/tmp/ipykernel_2323/2803142297.py:1: DeprecationWarning: The classical adjoint of the matrix is computed rather than the conjugate transpose.\n            Please use self.adj() instead to remove ambiguity.\n  A.adjoint()\n</pre> Out[27]:  $\\displaystyle \\left[\\begin{matrix}12 &amp; 6 &amp; -5\\\\3 &amp; 0 &amp; -1\\\\-6 &amp; -3 &amp; 2\\end{matrix}\\right]$  In\u00a0[28]: Copied! <pre>A_inv = A.adj() / A.det()\nA_inv\n</pre> A_inv = A.adj() / A.det() A_inv Out[28]:  $\\displaystyle \\left[\\begin{array}{ccc}-4 &amp; -2 &amp; \\frac{5}{3}\\\\-1 &amp; 0 &amp; \\frac{1}{3}\\\\2 &amp; 1 &amp; - \\frac{2}{3}\\end{array}\\right]$"},{"location":"tutorials/tut03/#tutorial-3-ay2425-sem-1","title":"Tutorial 3 (AY24/25 Sem 1)\u00b6","text":""},{"location":"tutorials/tut03/#question-1","title":"Question 1\u00b6","text":"<p>Let $\\mathbf{A}$ be the $4 \\times 4$ matrix obtained from $\\mathbf{I}$ by the following sequence of elementary row operations:</p> <p>$$\\mathbf{I} \\xrightarrow{\\frac{1}{2}R_2} \\xrightarrow{R_1 - R_2} \\xrightarrow{R_2 \\leftrightarrow R_4} \\xrightarrow{R_3 + 3R_1} \\mathbf{A}$$</p> <p>Write $\\mathbf{A}^{-1}$ as a product of four elementary matrices.</p>"},{"location":"tutorials/tut03/#question-2","title":"Question 2\u00b6","text":"<p>Find an LU factorization for the matrices $\\mathbf{A}$, and solve the equation $\\mathbf{A}x = b$.</p>"},{"location":"tutorials/tut03/#a","title":"(a)\u00b6","text":"<p>$\\mathbf{A} = \\begin{pmatrix} 2 &amp; -1 &amp; 2 \\\\ -6 &amp; 0 &amp; -2 \\\\ 8 &amp; -1 &amp; 5 \\end{pmatrix}$ and $b = \\begin{pmatrix} 1 \\\\ 0 \\\\ 4 \\end{pmatrix}$.</p>"},{"location":"tutorials/tut03/#b","title":"(b)\u00b6","text":"<p>$\\mathbf{A} = \\begin{pmatrix} 2 &amp; -4 &amp; 4 &amp; -2 \\\\ 6 &amp; -9 &amp; 7 &amp; -3 \\\\ -1 &amp; -4 &amp; 8 &amp; 0 \\end{pmatrix}$ and $b = \\begin{pmatrix} 0 \\\\ 0 \\\\ 5 \\end{pmatrix}$.</p>"},{"location":"tutorials/tut03/#question-3","title":"Question 3\u00b6","text":"<p>Let $\\mathbf{A} = \\begin{pmatrix} 2 &amp; -6 &amp; 6 \\\\ -4 &amp; 5 &amp; -7 \\\\ 3 &amp; 5 &amp; -1 \\\\ -6 &amp; 4 &amp; -8 \\\\ 8 &amp; -3 &amp; 9 \\end{pmatrix}$.</p>"},{"location":"tutorials/tut03/#a","title":"(a)\u00b6","text":"<p>Find an LU factorization of $\\mathbf{A}$.</p>"},{"location":"tutorials/tut03/#question-4","title":"Question 4\u00b6","text":"<p>Let $\\mathbf{A} = \\begin{pmatrix} -x &amp; 1 &amp; 0 \\\\ 0 &amp; -x &amp; 1 \\\\ 2 &amp; -5 &amp; 4-x \\end{pmatrix}$. Compute the determinant of $\\mathbf{A}$ and find all the values of $x$ such that $\\mathbf{A}$ is singular.</p>"},{"location":"tutorials/tut03/#question-5","title":"Question 5\u00b6","text":"<p>Show that $$\\begin{vmatrix} a + px &amp; b + qx &amp; c + rx \\\\ p + ux &amp; q + vx &amp; r + wx \\\\ u + ax &amp; v + bx &amp; w + cx \\end{vmatrix} = (1 + x^3) \\begin{vmatrix} a &amp; b &amp; c \\\\ p &amp; q &amp; r \\\\ u &amp; v &amp; w \\end{vmatrix}$$</p>"},{"location":"tutorials/tut03/#question-7","title":"Question 7\u00b6","text":"<p>Use Cramer's rule to solve $$\\begin{cases}  x &amp;+&amp; 5y &amp;+&amp; 3z &amp;=&amp; 1 \\\\  &amp;&amp; 2y &amp;-&amp; 2z &amp;=&amp; 2 \\\\ &amp;&amp; y &amp;+&amp; 3z &amp;=&amp; 0  \\end{cases}$$</p>"},{"location":"tutorials/tut03/#question-8","title":"Question 8\u00b6","text":"<p>Compute the adjoint of $\\mathbf{A} = \\begin{pmatrix} 1 &amp; -1 &amp; 2 \\\\ 0 &amp; 2 &amp; 1 \\\\ 3 &amp; 0 &amp; 6 \\end{pmatrix}$, and use it to compute $\\mathbf{A}^{-1}$.</p>"},{"location":"tutorials/tut04/","title":"Tutorial 4","text":"In\u00a0[1]: Copied! <pre># Required imports\nimport sympy as sym\nfrom ma1522 import Matrix\n</pre> # Required imports import sympy as sym from ma1522 import Matrix In\u00a0[2]: Copied! <pre>U = Matrix.from_str(\"2 1 0 3; 3 -1 5 2; -1 0 2 1\").T\nU\n</pre> U = Matrix.from_str(\"2 1 0 3; 3 -1 5 2; -1 0 2 1\").T U Out[2]:  $\\displaystyle \\left[\\begin{array}{ccc}2 &amp; 3 &amp; -1\\\\1 &amp; -1 &amp; 0\\\\0 &amp; 5 &amp; 2\\\\3 &amp; 2 &amp; 1\\end{array}\\right]$  In\u00a0[3]: Copied! <pre>U.column_constraints(verbosity=1)\n</pre> U.column_constraints(verbosity=1) <pre>Before RREF: [self | vec]\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc|c}2 &amp; 3 &amp; -1 &amp; x_{1}\\\\1 &amp; -1 &amp; 0 &amp; x_{2}\\\\0 &amp; 5 &amp; 2 &amp; x_{3}\\\\3 &amp; 2 &amp; 1 &amp; x_{4}\\end{array}\\right]$  <pre>After RREF\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc|c}1 &amp; 0 &amp; 0 &amp; - \\frac{x_{2}}{5} - \\frac{x_{3}}{5} + \\frac{2 x_{4}}{5}\\\\0 &amp; 1 &amp; 0 &amp; - \\frac{6 x_{2}}{5} - \\frac{x_{3}}{5} + \\frac{2 x_{4}}{5}\\\\0 &amp; 0 &amp; 1 &amp; 3 x_{2} + x_{3} - x_{4}\\\\0 &amp; 0 &amp; 0 &amp; x_{1} + 7 x_{2} + 2 x_{3} - 3 x_{4}\\end{array}\\right]$  <pre>For the system to be consistent, the following constraints must be satisfied.\n</pre>  $\\displaystyle x_{1} + 7 x_{2} + 2 x_{3} - 3 x_{4} = 0$  Out[3]:  $\\displaystyle \\left[\\begin{array}{ccc|c}1 &amp; 0 &amp; 0 &amp; - \\frac{x_{2}}{5} - \\frac{x_{3}}{5} + \\frac{2 x_{4}}{5}\\\\0 &amp; 1 &amp; 0 &amp; - \\frac{6 x_{2}}{5} - \\frac{x_{3}}{5} + \\frac{2 x_{4}}{5}\\\\0 &amp; 0 &amp; 1 &amp; 3 x_{2} + x_{3} - x_{4}\\\\0 &amp; 0 &amp; 0 &amp; x_{1} + 7 x_{2} + 2 x_{3} - 3 x_{4}\\end{array}\\right]$  In\u00a0[4]: Copied! <pre># Alternative Method based on RREF\nrhs = Matrix.from_str(\"2 3 -7 3; 0 0 0 0; 1 1 1 1; -4 6 -13 4\").T\nrhs = Matrix(rhs, aug_pos=range(3))\nrhs\n</pre> # Alternative Method based on RREF rhs = Matrix.from_str(\"2 3 -7 3; 0 0 0 0; 1 1 1 1; -4 6 -13 4\").T rhs = Matrix(rhs, aug_pos=range(3)) rhs Out[4]:  $\\displaystyle \\left[\\begin{array}{c|c|c|c}2 &amp; 0 &amp; 1 &amp; -4\\\\3 &amp; 0 &amp; 1 &amp; 6\\\\-7 &amp; 0 &amp; 1 &amp; -13\\\\3 &amp; 0 &amp; 1 &amp; 4\\end{array}\\right]$  In\u00a0[5]: Copied! <pre>aug_mat = U.row_join(rhs)\naug_mat\n</pre> aug_mat = U.row_join(rhs) aug_mat Out[5]:  $\\displaystyle \\left[\\begin{array}{ccc|c|c|c|c}2 &amp; 3 &amp; -1 &amp; 2 &amp; 0 &amp; 1 &amp; -4\\\\1 &amp; -1 &amp; 0 &amp; 3 &amp; 0 &amp; 1 &amp; 6\\\\0 &amp; 5 &amp; 2 &amp; -7 &amp; 0 &amp; 1 &amp; -13\\\\3 &amp; 2 &amp; 1 &amp; 3 &amp; 0 &amp; 1 &amp; 4\\end{array}\\right]$  In\u00a0[6]: Copied! <pre>aug_mat.rref()\n</pre> aug_mat.rref() Out[6]:  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc|c|c|c|c}1 &amp; 0 &amp; 0 &amp; 2 &amp; 0 &amp; 0 &amp; 3\\\\0 &amp; 1 &amp; 0 &amp; -1 &amp; 0 &amp; 0 &amp; -3\\\\0 &amp; 0 &amp; 1 &amp; -1 &amp; 0 &amp; 0 &amp; 1\\\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 2, 5)\\right\\}$  In\u00a0[7]: Copied! <pre>E = U.extend_basis(verbosity=2)\nE\n</pre> E = U.extend_basis(verbosity=2) E <pre>Before RREF: [self | span_subspace]\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc|c|c|c|c}2 &amp; 3 &amp; -1 &amp; 1 &amp; 0 &amp; 0 &amp; 0\\\\1 &amp; -1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 5 &amp; 2 &amp; 0 &amp; 0 &amp; 1 &amp; 0\\\\3 &amp; 2 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc|c|c|c|c}1 &amp; 0 &amp; 0 &amp; 0 &amp; - \\frac{1}{5} &amp; - \\frac{1}{5} &amp; \\frac{2}{5}\\\\0 &amp; 1 &amp; 0 &amp; 0 &amp; - \\frac{6}{5} &amp; - \\frac{1}{5} &amp; \\frac{2}{5}\\\\0 &amp; 0 &amp; 1 &amp; 0 &amp; 3 &amp; 1 &amp; -1\\\\0 &amp; 0 &amp; 0 &amp; 1 &amp; 7 &amp; 2 &amp; -3\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 2, 3)\\right\\}$  <pre>Select columns of rref([self | span_subspace]) corresponding to pivot positions.\n</pre> Out[7]:  $\\displaystyle \\left[\\begin{array}{cccc}2 &amp; 3 &amp; -1 &amp; 1\\\\1 &amp; -1 &amp; 0 &amp; 0\\\\0 &amp; 5 &amp; 2 &amp; 0\\\\3 &amp; 2 &amp; 1 &amp; 0\\end{array}\\right]$  In\u00a0[8]: Copied! <pre>v_1 = E.select_cols(-1) # Not in subspace spanned by U\nv_2 = v_1 + U.select_cols(0) # Not a multiple of v_1 or in subspace spanned by U\nv_1, v_2\n</pre> v_1 = E.select_cols(-1) # Not in subspace spanned by U v_2 = v_1 + U.select_cols(0) # Not a multiple of v_1 or in subspace spanned by U v_1, v_2 Out[8]:  $\\displaystyle \\left( \\left[\\begin{array}{c}1\\\\0\\\\0\\\\0\\end{array}\\right], \\  \\left[\\begin{array}{c}3\\\\1\\\\0\\\\3\\end{array}\\right]\\right)$  In\u00a0[9]: Copied! <pre>V = Matrix([[1, -1, -1]]).nullspace()\nV\n</pre> V = Matrix([[1, -1, -1]]).nullspace() V Out[9]:  $\\displaystyle \\left[ \\left[\\begin{matrix}1\\\\1\\\\0\\end{matrix}\\right], \\  \\left[\\begin{matrix}1\\\\0\\\\1\\end{matrix}\\right]\\right]$  In\u00a0[10]: Copied! <pre>S = Matrix.from_str(\"1 1 0; 5 2 3\").T\n\nS.is_same_subspace(Matrix.from_list(V), verbosity=2)\n</pre> S = Matrix.from_str(\"1 1 0; 5 2 3\").T  S.is_same_subspace(Matrix.from_list(V), verbosity=2) <pre>Check if span(self) is subspace of span(other), and vice versa.\nCheck if span(self) is subspace of span(other)\n\nBefore RREF: [other | self]\n</pre>  $\\displaystyle \\left[\\begin{array}{cc|cc}1 &amp; 1 &amp; 1 &amp; 5\\\\1 &amp; 0 &amp; 1 &amp; 2\\\\0 &amp; 1 &amp; 0 &amp; 3\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cc|cc}1 &amp; 0 &amp; 1 &amp; 2\\\\0 &amp; 1 &amp; 0 &amp; 3\\\\0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1)\\right\\}$  <pre>Span(self) is a subspace of span(other).\n\nCheck if span(self) is subspace of span(other)\n\nBefore RREF: [other | self]\n</pre>  $\\displaystyle \\left[\\begin{array}{cc|cc}1 &amp; 5 &amp; 1 &amp; 1\\\\1 &amp; 2 &amp; 1 &amp; 0\\\\0 &amp; 3 &amp; 0 &amp; 1\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cc|cc}1 &amp; 0 &amp; 1 &amp; - \\frac{2}{3}\\\\0 &amp; 1 &amp; 0 &amp; \\frac{1}{3}\\\\0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1)\\right\\}$  <pre>Span(self) is a subspace of span(other).\n\n</pre> Out[10]: <pre>True</pre> In\u00a0[11]: Copied! <pre>S\n</pre> S Out[11]:  $\\displaystyle \\left[\\begin{array}{cc}1 &amp; 5\\\\1 &amp; 2\\\\0 &amp; 3\\end{array}\\right]$  In\u00a0[12]: Copied! <pre>T = S.row_join(Matrix.from_str(\"0 0 1\").T)\nT.rm_aug_line()\n\n# If no `other` subspace is provided, it is assumed to be the entire R^n\nT.is_same_subspace(verbosity=2)\n</pre> T = S.row_join(Matrix.from_str(\"0 0 1\").T) T.rm_aug_line()  # If no `other` subspace is provided, it is assumed to be the entire R^n T.is_same_subspace(verbosity=2) <pre>Check rref(self) does not have zero rows\nBefore RREF: self\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 5 &amp; 0\\\\1 &amp; 2 &amp; 0\\\\0 &amp; 3 &amp; 1\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 1\\end{array}\\right]$  Out[12]: <pre>True</pre> In\u00a0[13]: Copied! <pre>S = Matrix.from_str(\"1 0 0 1; 0 1 0 0; 1 1 1 1; 1 1 1 0\").T\nS\n</pre> S = Matrix.from_str(\"1 0 0 1; 0 1 0 0; 1 1 1 1; 1 1 1 0\").T S Out[13]:  $\\displaystyle \\left[\\begin{array}{cccc}1 &amp; 0 &amp; 1 &amp; 1\\\\0 &amp; 1 &amp; 1 &amp; 1\\\\0 &amp; 0 &amp; 1 &amp; 1\\\\1 &amp; 0 &amp; 1 &amp; 0\\end{array}\\right]$  In\u00a0[14]: Copied! <pre>S.is_same_subspace(verbosity=2)\n</pre> S.is_same_subspace(verbosity=2) <pre>Check rref(self) does not have zero rows\nBefore RREF: self\n</pre>  $\\displaystyle \\left[\\begin{array}{cccc}1 &amp; 0 &amp; 1 &amp; 1\\\\0 &amp; 1 &amp; 1 &amp; 1\\\\0 &amp; 0 &amp; 1 &amp; 1\\\\1 &amp; 0 &amp; 1 &amp; 0\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\displaystyle \\left[\\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{array}\\right]$  Out[14]: <pre>True</pre> In\u00a0[15]: Copied! <pre>S = Matrix.from_str(\"1 2 1 0; 1 1 -1 0; 0 0 0 1\").T\nS\n</pre> S = Matrix.from_str(\"1 2 1 0; 1 1 -1 0; 0 0 0 1\").T S Out[15]:  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 1 &amp; 0\\\\2 &amp; 1 &amp; 0\\\\1 &amp; -1 &amp; 0\\\\0 &amp; 0 &amp; 1\\end{array}\\right]$  In\u00a0[16]: Copied! <pre>S.is_same_subspace(verbosity=2)\n</pre> S.is_same_subspace(verbosity=2) <pre>Check rref(self) does not have zero rows\nBefore RREF: self\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 1 &amp; 0\\\\2 &amp; 1 &amp; 0\\\\1 &amp; -1 &amp; 0\\\\0 &amp; 0 &amp; 1\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 1\\\\0 &amp; 0 &amp; 0\\end{array}\\right]$  Out[16]: <pre>False</pre> In\u00a0[17]: Copied! <pre>S = Matrix.from_str(\"6 4 -2 4; 2 0 0 1; 3 2 -1 2; 5 6 -3 2; 0 4 -2 -1\").T\nS\n</pre> S = Matrix.from_str(\"6 4 -2 4; 2 0 0 1; 3 2 -1 2; 5 6 -3 2; 0 4 -2 -1\").T S Out[17]:  $\\displaystyle \\left[\\begin{array}{ccccc}6 &amp; 2 &amp; 3 &amp; 5 &amp; 0\\\\4 &amp; 0 &amp; 2 &amp; 6 &amp; 4\\\\-2 &amp; 0 &amp; -1 &amp; -3 &amp; -2\\\\4 &amp; 1 &amp; 2 &amp; 2 &amp; -1\\end{array}\\right]$  In\u00a0[18]: Copied! <pre>S.is_same_subspace(verbosity=2)\n</pre> S.is_same_subspace(verbosity=2) <pre>Check rref(self) does not have zero rows\nBefore RREF: self\n</pre>  $\\displaystyle \\left[\\begin{array}{ccccc}6 &amp; 2 &amp; 3 &amp; 5 &amp; 0\\\\4 &amp; 0 &amp; 2 &amp; 6 &amp; 4\\\\-2 &amp; 0 &amp; -1 &amp; -3 &amp; -2\\\\4 &amp; 1 &amp; 2 &amp; 2 &amp; -1\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\displaystyle \\left[\\begin{array}{ccccc}1 &amp; 0 &amp; \\frac{1}{2} &amp; 0 &amp; - \\frac{1}{2}\\\\0 &amp; 1 &amp; 0 &amp; 0 &amp; -1\\\\0 &amp; 0 &amp; 0 &amp; 1 &amp; 1\\\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right]$  Out[18]: <pre>False</pre> In\u00a0[19]: Copied! <pre>S = Matrix.from_str(\"1 1 0 0; 1 2 -1 1; 0 0 1 1; 2 1 2 1; 1 2 3 4\").T\nS\n</pre> S = Matrix.from_str(\"1 1 0 0; 1 2 -1 1; 0 0 1 1; 2 1 2 1; 1 2 3 4\").T S Out[19]:  $\\displaystyle \\left[\\begin{array}{ccccc}1 &amp; 1 &amp; 0 &amp; 2 &amp; 1\\\\1 &amp; 2 &amp; 0 &amp; 1 &amp; 2\\\\0 &amp; -1 &amp; 1 &amp; 2 &amp; 3\\\\0 &amp; 1 &amp; 1 &amp; 1 &amp; 4\\end{array}\\right]$  In\u00a0[20]: Copied! <pre>S.is_same_subspace(verbosity=2)\n</pre> S.is_same_subspace(verbosity=2) <pre>Check rref(self) does not have zero rows\nBefore RREF: self\n</pre>  $\\displaystyle \\left[\\begin{array}{ccccc}1 &amp; 1 &amp; 0 &amp; 2 &amp; 1\\\\1 &amp; 2 &amp; 0 &amp; 1 &amp; 2\\\\0 &amp; -1 &amp; 1 &amp; 2 &amp; 3\\\\0 &amp; 1 &amp; 1 &amp; 1 &amp; 4\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\displaystyle \\left[\\begin{array}{ccccc}1 &amp; 0 &amp; 0 &amp; 0 &amp; 3\\\\0 &amp; 1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0 &amp; 5\\\\0 &amp; 0 &amp; 0 &amp; 1 &amp; -1\\end{array}\\right]$  Out[20]: <pre>True</pre> In\u00a0[21]: Copied! <pre>U = Matrix.from_str(\"2 -2 0; -1 1 -1; 0 0 9\").T\nV = Matrix.from_str(\"1 -1 -5; 0 1 1\").T\nU, V\n</pre> U = Matrix.from_str(\"2 -2 0; -1 1 -1; 0 0 9\").T V = Matrix.from_str(\"1 -1 -5; 0 1 1\").T U, V Out[21]:  $\\displaystyle \\left( \\left[\\begin{array}{ccc}2 &amp; -1 &amp; 0\\\\-2 &amp; 1 &amp; 0\\\\0 &amp; -1 &amp; 9\\end{array}\\right], \\  \\left[\\begin{array}{cc}1 &amp; 0\\\\-1 &amp; 1\\\\-5 &amp; 1\\end{array}\\right]\\right)$  In\u00a0[22]: Copied! <pre>U.is_same_subspace(V, verbosity=2)\n</pre> U.is_same_subspace(V, verbosity=2) <pre>Check if span(self) is subspace of span(other), and vice versa.\nCheck if span(self) is subspace of span(other)\n\nBefore RREF: [other | self]\n</pre>  $\\displaystyle \\left[\\begin{array}{cc|ccc}1 &amp; 0 &amp; 2 &amp; -1 &amp; 0\\\\-1 &amp; 1 &amp; -2 &amp; 1 &amp; 0\\\\-5 &amp; 1 &amp; 0 &amp; -1 &amp; 9\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cc|ccc}1 &amp; 0 &amp; 0 &amp; \\frac{1}{5} &amp; - \\frac{9}{5}\\\\0 &amp; 1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; - \\frac{3}{5} &amp; \\frac{9}{10}\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 2)\\right\\}$  <pre>Span(self) is not a subspace of span(other).\n\n</pre> Out[22]: <pre>False</pre> In\u00a0[23]: Copied! <pre>U = Matrix.from_str(\"1 6 4; 2 4 -1; -1 2 5\").T\nV = Matrix.from_str(\"1 -2 -5; 0 8 9\").T\nU, V\n</pre> U = Matrix.from_str(\"1 6 4; 2 4 -1; -1 2 5\").T V = Matrix.from_str(\"1 -2 -5; 0 8 9\").T U, V Out[23]:  $\\displaystyle \\left( \\left[\\begin{array}{ccc}1 &amp; 2 &amp; -1\\\\6 &amp; 4 &amp; 2\\\\4 &amp; -1 &amp; 5\\end{array}\\right], \\  \\left[\\begin{array}{cc}1 &amp; 0\\\\-2 &amp; 8\\\\-5 &amp; 9\\end{array}\\right]\\right)$  In\u00a0[24]: Copied! <pre>U.is_same_subspace(V, verbosity=2)\n</pre> U.is_same_subspace(V, verbosity=2) <pre>Check if span(self) is subspace of span(other), and vice versa.\nCheck if span(self) is subspace of span(other)\n\nBefore RREF: [other | self]\n</pre>  $\\displaystyle \\left[\\begin{array}{cc|ccc}1 &amp; 0 &amp; 1 &amp; 2 &amp; -1\\\\-2 &amp; 8 &amp; 6 &amp; 4 &amp; 2\\\\-5 &amp; 9 &amp; 4 &amp; -1 &amp; 5\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cc|ccc}1 &amp; 0 &amp; 1 &amp; 2 &amp; -1\\\\0 &amp; 1 &amp; 1 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1)\\right\\}$  <pre>Span(self) is a subspace of span(other).\n\nCheck if span(self) is subspace of span(other)\n\nBefore RREF: [other | self]\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc|cc}1 &amp; 2 &amp; -1 &amp; 1 &amp; 0\\\\6 &amp; 4 &amp; 2 &amp; -2 &amp; 8\\\\4 &amp; -1 &amp; 5 &amp; -5 &amp; 9\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc|cc}1 &amp; 0 &amp; 1 &amp; -1 &amp; 2\\\\0 &amp; 1 &amp; -1 &amp; 1 &amp; -1\\\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1)\\right\\}$  <pre>Span(self) is a subspace of span(other).\n\n</pre> Out[24]: <pre>True</pre>"},{"location":"tutorials/tut04/#tutorial-4-ay2425-sem-1","title":"Tutorial 4 (AY24/25 Sem 1)\u00b6","text":""},{"location":"tutorials/tut04/#question-2","title":"Question 2\u00b6","text":"<p>Let $u_1 = \\begin{pmatrix} 2 \\\\ 1 \\\\ 0 \\\\ 3 \\end{pmatrix}$, $u_2 = \\begin{pmatrix} 3 \\\\ -1 \\\\ 5 \\\\ 2 \\end{pmatrix}$, and $u_3 = \\begin{pmatrix} -1 \\\\ 0 \\\\ 2 \\\\ 1 \\end{pmatrix}$.</p>"},{"location":"tutorials/tut04/#a","title":"(a)\u00b6","text":"<p>If possible, express each of the following vectors as a linear combination of $u_1$, $u_2$, $u_3$.</p> <p>(i) $\\begin{pmatrix} 2 \\\\ 3 \\\\ -7 \\\\ 3 \\end{pmatrix}$</p> <p>(ii) $\\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{pmatrix}$</p> <p>(iii) $\\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\\\ 1 \\end{pmatrix}$</p> <p>(iv) $\\begin{pmatrix} -4 \\\\ 6 \\\\ -13 \\\\ 4 \\end{pmatrix}$</p>"},{"location":"tutorials/tut04/#b","title":"(b)\u00b6","text":"<p>Is it possible to find 2 vectors $v_1$ and $v_2$ such that they are not a multiple of each other, and both are not a linear combination of $u_1$, $u_2$, $u_3$?</p>"},{"location":"tutorials/tut04/#question-3","title":"Question 3\u00b6","text":"<p>Let $V = \\left\\{ \\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix} \\middle| x - y - z = 0 \\right\\}$ be a subset of $\\mathbb{R}^3$.</p>"},{"location":"tutorials/tut04/#a","title":"(a)\u00b6","text":"<p>Let $S = \\left\\{\\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\end{pmatrix}, \\begin{pmatrix} 5 \\\\ 2 \\\\ 3 \\end{pmatrix} \\right\\}$. Show that $\\text{span}(S) = V$.</p>"},{"location":"tutorials/tut04/#b","title":"(b)\u00b6","text":"<p>Let $T = S \\cup \\left\\{\\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix}\\right\\}$. Show that $\\text{span}(T) = \\mathbb{R}^3$.</p>"},{"location":"tutorials/tut04/#question-4","title":"Question 4\u00b6","text":"<p>Which of the following sets $S$ spans $\\mathbb{R}^4$?</p>"},{"location":"tutorials/tut04/#i","title":"(i)\u00b6","text":"<p>$S = \\left\\{\\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 1 \\end{pmatrix}, \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\\\ 0 \\end{pmatrix}, \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\\\ 1 \\end{pmatrix}, \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\\\ 0 \\end{pmatrix}\\right\\}$.</p>"},{"location":"tutorials/tut04/#ii","title":"(ii)\u00b6","text":"<p>$S = \\left\\{\\begin{pmatrix} 1 \\\\ 2 \\\\ 1 \\\\ 0 \\end{pmatrix}, \\begin{pmatrix} 1 \\\\ 1 \\\\ -1 \\\\ 0 \\end{pmatrix}, \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 1 \\end{pmatrix}\\right\\}$</p>"},{"location":"tutorials/tut04/#iii","title":"(iii)\u00b6","text":"<p>$S = \\left\\{\\begin{pmatrix} 6 \\\\ 4 \\\\ -2 \\\\ 4 \\end{pmatrix}, \\begin{pmatrix} 2 \\\\ 0 \\\\ 0 \\\\ 1 \\end{pmatrix}, \\begin{pmatrix} 3 \\\\ 2 \\\\ -1 \\\\ 2 \\end{pmatrix}, \\begin{pmatrix} 5 \\\\ 6 \\\\ -3 \\\\ 2 \\end{pmatrix}, \\begin{pmatrix} 0 \\\\ 4 \\\\ -2 \\\\ -1 \\end{pmatrix}\\right\\}$.</p>"},{"location":"tutorials/tut04/#iv","title":"(iv)\u00b6","text":"<p>$S = \\left\\{\\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\\\ 0 \\end{pmatrix}, \\begin{pmatrix} 1 \\\\ 2 \\\\ -1 \\\\ 1 \\end{pmatrix}, \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\\\ 1 \\end{pmatrix}, \\begin{pmatrix} 2 \\\\ 1 \\\\ 2 \\\\ 1 \\end{pmatrix}, \\begin{pmatrix} 1 \\\\ 2 \\\\ 3 \\\\ 4 \\end{pmatrix}\\right\\}$.</p>"},{"location":"tutorials/tut04/#question-5","title":"Question 5\u00b6","text":"<p>Determine whether $\\text{span}\\{u_1, u_2, u_3\\} \\subseteq \\text{span}\\{v_1, v_2\\}$ and/or $\\text{span}\\{v_1, v_2\\} \\subseteq \\text{span}\\{u_1, u_2, u_3\\}$ if</p>"},{"location":"tutorials/tut04/#a","title":"(a)\u00b6","text":"<p>$u_1 = \\begin{pmatrix} 2 \\\\ -2 \\\\ 0 \\end{pmatrix}$, $u_2 = \\begin{pmatrix} -1 \\\\ 1 \\\\ -1 \\end{pmatrix}$, $u_3 = \\begin{pmatrix} 0 \\\\ 0 \\\\ 9 \\end{pmatrix}$, $v_1 = \\begin{pmatrix} 1 \\\\ -1 \\\\ -5 \\end{pmatrix}$, $v_2 = \\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix}$.</p>"},{"location":"tutorials/tut04/#b","title":"(b)\u00b6","text":"<p>$u_1 = \\begin{pmatrix} 1 \\\\ 6 \\\\ 4 \\end{pmatrix}$, $u_2 = \\begin{pmatrix} 2 \\\\ 4 \\\\ -1 \\end{pmatrix}$, $u_3 = \\begin{pmatrix} -1 \\\\ 2 \\\\ 5 \\end{pmatrix}$, $v_1 = \\begin{pmatrix} 1 \\\\ -2 \\\\ -5 \\end{pmatrix}$, $v_2 = \\begin{pmatrix} 0 \\\\ 8 \\\\ 9 \\end{pmatrix}$.</p>"},{"location":"tutorials/tut05/","title":"Tutorial 5","text":"In\u00a0[1]: Copied! <pre># Required imports\nimport sympy as sym\nfrom ma1522 import Matrix\n</pre> # Required imports import sympy as sym from ma1522 import Matrix In\u00a0[2]: Copied! <pre>S = Matrix.from_str(\"2 -1 0; 0 3 2; 2 4 3; 3 6 6\").T\nS\n</pre> S = Matrix.from_str(\"2 -1 0; 0 3 2; 2 4 3; 3 6 6\").T S Out[2]:  $\\displaystyle \\left[\\begin{array}{cccc}2 &amp; 0 &amp; 2 &amp; 3\\\\-1 &amp; 3 &amp; 4 &amp; 6\\\\0 &amp; 2 &amp; 3 &amp; 6\\end{array}\\right]$  In\u00a0[3]: Copied! <pre>S.is_linearly_independent(verbosity=2)\n</pre> S.is_linearly_independent(verbosity=2) <pre>Before RREF: self\n</pre>  $\\displaystyle \\left[\\begin{array}{cccc}2 &amp; 0 &amp; 2 &amp; 3\\\\-1 &amp; 3 &amp; 4 &amp; 6\\\\0 &amp; 2 &amp; 3 &amp; 6\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\displaystyle \\left[\\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; \\frac{9}{2}\\\\0 &amp; 1 &amp; 0 &amp; \\frac{15}{2}\\\\0 &amp; 0 &amp; 1 &amp; -3\\end{array}\\right]$  <pre>Check if Number of columns (4) == Number of pivot columns (3)\n</pre> Out[3]: <pre>False</pre> <p>Based on the RREF, the last column can be expressed as a linear combination of the first three columns</p> In\u00a0[4]: Copied! <pre>S = Matrix.from_str(\"1 1 0; 3 4 2\").T\nS\n</pre> S = Matrix.from_str(\"1 1 0; 3 4 2\").T S Out[4]:  $\\displaystyle \\left[\\begin{array}{cc}1 &amp; 3\\\\1 &amp; 4\\\\0 &amp; 2\\end{array}\\right]$  In\u00a0[5]: Copied! <pre>S.is_linearly_independent(verbosity=2)\n</pre> S.is_linearly_independent(verbosity=2) <pre>Before RREF: self\n</pre>  $\\displaystyle \\left[\\begin{array}{cc}1 &amp; 3\\\\1 &amp; 4\\\\0 &amp; 2\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\displaystyle \\left[\\begin{array}{cc}1 &amp; 0\\\\0 &amp; 1\\\\0 &amp; 0\\end{array}\\right]$  <pre>Check if Number of columns (2) == Number of pivot columns (2)\n</pre> Out[5]: <pre>True</pre> In\u00a0[6]: Copied! <pre>S = Matrix.from_str(\"1 1 0; 3 4 2; 0 0 0\").T\nS\n</pre> S = Matrix.from_str(\"1 1 0; 3 4 2; 0 0 0\").T S Out[6]:  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 3 &amp; 0\\\\1 &amp; 4 &amp; 0\\\\0 &amp; 2 &amp; 0\\end{array}\\right]$  In\u00a0[7]: Copied! <pre>S.is_linearly_independent(verbosity=2)\n</pre> S.is_linearly_independent(verbosity=2) <pre>Before RREF: self\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 3 &amp; 0\\\\1 &amp; 4 &amp; 0\\\\0 &amp; 2 &amp; 0\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0\\end{array}\\right]$  <pre>Check if Number of columns (3) == Number of pivot columns (2)\n</pre> Out[7]: <pre>False</pre> In\u00a0[8]: Copied! <pre>S = Matrix.from_str(\"1 0 0; 0 1 1; 1 2 -1\").T\nS\n</pre> S = Matrix.from_str(\"1 0 0; 0 1 1; 1 2 -1\").T S Out[8]:  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 0 &amp; 1\\\\0 &amp; 1 &amp; 2\\\\0 &amp; 1 &amp; -1\\end{array}\\right]$  In\u00a0[9]: Copied! <pre>S.is_linearly_independent(verbosity=2)\n</pre> S.is_linearly_independent(verbosity=2) <pre>Before RREF: self\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 0 &amp; 1\\\\0 &amp; 1 &amp; 2\\\\0 &amp; 1 &amp; -1\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 1\\end{array}\\right]$  <pre>Check if Number of columns (3) == Number of pivot columns (3)\n</pre> Out[9]: <pre>True</pre> In\u00a0[10]: Copied! <pre># Tip: Use `sympy.solve` to help you find non-trivial solutions\n\na, b, c = sym.symbols(\"a b c\")\nu, v, w = sym.symbols(\"u v w\")\n\nv1 = u\nv2 = u + v\nv3 = u + v + w\n\n# Solve the system of equations to find the coefficients a, b, c\nsols = sym.solve(a*v1 + b*v2 + c*v3, (a, b, c))\nsols # only trivial solution exists -&gt; the set is linearly independent\n</pre> # Tip: Use `sympy.solve` to help you find non-trivial solutions  a, b, c = sym.symbols(\"a b c\") u, v, w = sym.symbols(\"u v w\")  v1 = u v2 = u + v v3 = u + v + w  # Solve the system of equations to find the coefficients a, b, c sols = sym.solve(a*v1 + b*v2 + c*v3, (a, b, c)) sols # only trivial solution exists -&gt; the set is linearly independent Out[10]:  $\\displaystyle \\left\\{ a : 0, \\  b : 0, \\  c : 0\\right\\}$  In\u00a0[11]: Copied! <pre>a, b, c, d = sym.symbols(\"a b c d\")\nu, v, w = sym.symbols(\"u v w\")\n\nv1 = u + v\nv2 = v + w\nv3 = u + w\nv4 = u + v + w\n\n# Solve the system of equations to find the coefficients a, b, c, d\nsols = sym.solve(a*v1 + b*v2 + c*v3 + d*v4, (a, b, c, d))\nsols # non-trivial solution exists -&gt; the set is linearly dependent\n</pre> a, b, c, d = sym.symbols(\"a b c d\") u, v, w = sym.symbols(\"u v w\")  v1 = u + v v2 = v + w v3 = u + w v4 = u + v + w  # Solve the system of equations to find the coefficients a, b, c, d sols = sym.solve(a*v1 + b*v2 + c*v3 + d*v4, (a, b, c, d)) sols # non-trivial solution exists -&gt; the set is linearly dependent Out[11]:  $\\displaystyle \\left[ \\left( - \\frac{d}{2}, \\  - \\frac{d}{2}, \\  - \\frac{d}{2}, \\  d\\right)\\right]$  In\u00a0[12]: Copied! <pre>V = Matrix.from_str(\"a+b; a+c; c+d; b+d\")\nvecs = V.sep_unk()\nvecs\n</pre> V = Matrix.from_str(\"a+b; a+c; c+d; b+d\") vecs = V.sep_unk() vecs Out[12]:  $\\displaystyle \\left\\{ a : \\left[\\begin{array}{c}1\\\\1\\\\0\\\\0\\end{array}\\right], \\  b : \\left[\\begin{array}{c}1\\\\0\\\\0\\\\1\\end{array}\\right], \\  c : \\left[\\begin{array}{c}0\\\\1\\\\1\\\\0\\end{array}\\right], \\  d : \\left[\\begin{array}{c}0\\\\0\\\\1\\\\1\\end{array}\\right]\\right\\}$  In\u00a0[13]: Copied! <pre>V = Matrix.from_list([*vecs.values()])\nV\n</pre> V = Matrix.from_list([*vecs.values()]) V Out[13]:  $\\displaystyle \\left[\\begin{array}{cccc}0 &amp; 1 &amp; 0 &amp; 1\\\\1 &amp; 1 &amp; 0 &amp; 0\\\\1 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 1\\end{array}\\right]$  In\u00a0[14]: Copied! <pre># Tip: Use pivots in the RREF to get linearly independent vectors\nV.get_linearly_independent_vectors(verbosity=1)\n</pre> # Tip: Use pivots in the RREF to get linearly independent vectors V.get_linearly_independent_vectors(verbosity=1) <pre>Before RREF: [self]\n</pre>  $\\displaystyle \\left[\\begin{array}{cccc}0 &amp; 1 &amp; 0 &amp; 1\\\\1 &amp; 1 &amp; 0 &amp; 0\\\\1 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 1\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; -1\\\\0 &amp; 1 &amp; 0 &amp; 1\\\\0 &amp; 0 &amp; 1 &amp; 1\\\\0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 2)\\right\\}$  <pre>Select columns of self corresponding to pivot positions.\n</pre> Out[14]:  $\\displaystyle \\left[\\begin{array}{ccc}0 &amp; 1 &amp; 0\\\\1 &amp; 1 &amp; 0\\\\1 &amp; 0 &amp; 1\\\\0 &amp; 0 &amp; 1\\end{array}\\right]$  In\u00a0[15]: Copied! <pre>V = Matrix.from_str(\"1 0 -1; -1 2 3; 0 3 0; 1 -1 1\").T\nV\n</pre> V = Matrix.from_str(\"1 0 -1; -1 2 3; 0 3 0; 1 -1 1\").T V Out[15]:  $\\displaystyle \\left[\\begin{array}{cccc}1 &amp; -1 &amp; 0 &amp; 1\\\\0 &amp; 2 &amp; 3 &amp; -1\\\\-1 &amp; 3 &amp; 0 &amp; 1\\end{array}\\right]$  In\u00a0[16]: Copied! <pre>V.get_linearly_independent_vectors(verbosity=1)\n</pre> V.get_linearly_independent_vectors(verbosity=1) <pre>Before RREF: [self]\n</pre>  $\\displaystyle \\left[\\begin{array}{cccc}1 &amp; -1 &amp; 0 &amp; 1\\\\0 &amp; 2 &amp; 3 &amp; -1\\\\-1 &amp; 3 &amp; 0 &amp; 1\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; 2\\\\0 &amp; 1 &amp; 0 &amp; 1\\\\0 &amp; 0 &amp; 1 &amp; -1\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 2)\\right\\}$  <pre>Select columns of self corresponding to pivot positions.\n</pre> Out[16]:  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; -1 &amp; 0\\\\0 &amp; 2 &amp; 3\\\\-1 &amp; 3 &amp; 0\\end{array}\\right]$  In\u00a0[17]: Copied! <pre>mat = Matrix.from_str(\"1 0 1 1 -1; 0 1 1 2 1; 1 1 2 1 -2\")\nmat\n</pre> mat = Matrix.from_str(\"1 0 1 1 -1; 0 1 1 2 1; 1 1 2 1 -2\") mat Out[17]:  $\\displaystyle \\left[\\begin{array}{ccccc}1 &amp; 0 &amp; 1 &amp; 1 &amp; -1\\\\0 &amp; 1 &amp; 1 &amp; 2 &amp; 1\\\\1 &amp; 1 &amp; 2 &amp; 1 &amp; -2\\end{array}\\right]$  In\u00a0[18]: Copied! <pre>V = mat.nullspace()\nV\n</pre> V = mat.nullspace() V Out[18]:  $\\displaystyle \\left[ \\left[\\begin{matrix}-1\\\\-1\\\\1\\\\0\\\\0\\end{matrix}\\right], \\  \\left[\\begin{matrix}2\\\\1\\\\0\\\\-1\\\\1\\end{matrix}\\right]\\right]$  In\u00a0[19]: Copied! <pre>Matrix.from_list(V).get_linearly_independent_vectors(verbosity=1)\n</pre> Matrix.from_list(V).get_linearly_independent_vectors(verbosity=1) <pre>Before RREF: [self]\n</pre>  $\\displaystyle \\left[\\begin{array}{cc}-1 &amp; 2\\\\-1 &amp; 1\\\\1 &amp; 0\\\\0 &amp; -1\\\\0 &amp; 1\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cc}1 &amp; 0\\\\0 &amp; 1\\\\0 &amp; 0\\\\0 &amp; 0\\\\0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1)\\right\\}$  <pre>Select columns of self corresponding to pivot positions.\n</pre> Out[19]:  $\\displaystyle \\left[\\begin{array}{cc}-1 &amp; 2\\\\-1 &amp; 1\\\\1 &amp; 0\\\\0 &amp; -1\\\\0 &amp; 1\\end{array}\\right]$  In\u00a0[20]: Copied! <pre>a = sym.symbols(\"a\", real=True) # remember to set real=True for real numbers only\nU = Matrix([[a, 1, -1], [-1, a, 1], [1, -1, a]]).T\nU\n</pre> a = sym.symbols(\"a\", real=True) # remember to set real=True for real numbers only U = Matrix([[a, 1, -1], [-1, a, 1], [1, -1, a]]).T U Out[20]:  $\\displaystyle \\left[\\begin{array}{ccc}a &amp; -1 &amp; 1\\\\1 &amp; a &amp; -1\\\\-1 &amp; 1 &amp; a\\end{array}\\right]$  In\u00a0[21]: Copied! <pre>sym.solve(U.det()) # basis for R^3 if a != 0\n</pre> sym.solve(U.det()) # basis for R^3 if a != 0 Out[21]:  $\\displaystyle \\left[ 0\\right]$  In\u00a0[22]: Copied! <pre>U = Matrix.from_str(\"1 1 1 1; 1 2 2 1\").T\nV = Matrix.from_str(\"1 0 1 0; 1 0 2 -1\").T\n\nU, V\n</pre> U = Matrix.from_str(\"1 1 1 1; 1 2 2 1\").T V = Matrix.from_str(\"1 0 1 0; 1 0 2 -1\").T  U, V Out[22]:  $\\displaystyle \\left( \\left[\\begin{array}{cc}1 &amp; 1\\\\1 &amp; 2\\\\1 &amp; 2\\\\1 &amp; 1\\end{array}\\right], \\  \\left[\\begin{array}{cc}1 &amp; 1\\\\0 &amp; 0\\\\1 &amp; 2\\\\0 &amp; -1\\end{array}\\right]\\right)$  In\u00a0[23]: Copied! <pre>U.row_join(V).get_linearly_independent_vectors(verbosity=1)\n</pre> U.row_join(V).get_linearly_independent_vectors(verbosity=1) <pre>Before RREF: [self]\n</pre>  $\\displaystyle \\left[\\begin{array}{cc|cc}1 &amp; 1 &amp; 1 &amp; 1\\\\1 &amp; 2 &amp; 0 &amp; 0\\\\1 &amp; 2 &amp; 1 &amp; 2\\\\1 &amp; 1 &amp; 0 &amp; -1\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cc|cc}1 &amp; 0 &amp; 0 &amp; -2\\\\0 &amp; 1 &amp; 0 &amp; 1\\\\0 &amp; 0 &amp; 1 &amp; 2\\\\0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 2)\\right\\}$  <pre>Select columns of self corresponding to pivot positions.\n</pre> Out[23]:  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 1 &amp; 1\\\\1 &amp; 2 &amp; 0\\\\1 &amp; 2 &amp; 1\\\\1 &amp; 1 &amp; 0\\end{array}\\right]$  In\u00a0[24]: Copied! <pre>U.intersect_subspace(V, verbosity=2) # intersection of U and V\n</pre> U.intersect_subspace(V, verbosity=2) # intersection of U and V <pre>A linear system whose solution space is the subspace of self. Null(self^T)^T\n</pre>  $\\displaystyle \\left[\\begin{array}{cccc}0 &amp; -1 &amp; 1 &amp; 0\\\\-1 &amp; 0 &amp; 0 &amp; 1\\end{array}\\right]$  <pre>\nA linear system whose solution space is the subspace of other. Null(other^T)^T\n</pre>  $\\displaystyle \\left[\\begin{array}{cccc}0 &amp; 1 &amp; 0 &amp; 0\\\\-1 &amp; 0 &amp; 1 &amp; 1\\end{array}\\right]$  <pre>\nBefore RREF: [self ; other]\n</pre>  $\\displaystyle \\left[\\begin{array}{cccc}0 &amp; -1 &amp; 1 &amp; 0\\\\-1 &amp; 0 &amp; 0 &amp; 1\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\-1 &amp; 0 &amp; 1 &amp; 1\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; -1\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 2)\\right\\}$  Out[24]:  $\\displaystyle \\left[\\begin{array}{c}1\\\\0\\\\0\\\\1\\end{array}\\right]$"},{"location":"tutorials/tut05/#tutorial-5-ay2425-sem-1","title":"Tutorial 5 (AY24/25 Sem 1)\u00b6","text":""},{"location":"tutorials/tut05/#question-1","title":"Question 1\u00b6","text":"<p>For each of the following sets of vectors $S$,</p> <p>(i) Determine if $S$ is linearly independent.</p> <p>(ii) If $S$ is linearly dependent, express one of the vectors in $S$ as a linear combination of the others.</p>"},{"location":"tutorials/tut05/#a","title":"(a)\u00b6","text":"<p>$S = \\left\\{\\begin{pmatrix} 2 \\\\ -1 \\\\ 0 \\end{pmatrix}, \\begin{pmatrix} 0 \\\\ 3 \\\\ 2 \\end{pmatrix}, \\begin{pmatrix} 2 \\\\ 4 \\\\ 3 \\end{pmatrix}, \\begin{pmatrix} 3 \\\\ 6 \\\\ 6 \\end{pmatrix}\\right\\}$.</p>"},{"location":"tutorials/tut05/#b","title":"(b)\u00b6","text":"<p>$S = \\left\\{\\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\end{pmatrix}, \\begin{pmatrix} 3 \\\\ 4 \\\\ 2 \\end{pmatrix}\\right\\}$.</p>"},{"location":"tutorials/tut05/#c","title":"(c)\u00b6","text":"<p>$S = \\left\\{\\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\end{pmatrix}, \\begin{pmatrix} 3 \\\\ 4 \\\\ 2 \\end{pmatrix}, \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}\\right\\}$.</p>"},{"location":"tutorials/tut05/#d","title":"(d)\u00b6","text":"<p>$S = \\left\\{\\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}, \\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix}, \\begin{pmatrix} 1 \\\\ 2 \\\\ -1 \\end{pmatrix}\\right\\}$.</p>"},{"location":"tutorials/tut05/#question-2","title":"Question 2\u00b6","text":"<p>Suppose $u$, $v$, $w$ are linearly independent vectors in $\\mathbb{R}^n$. Determine which of the sets $S_1$ to $S_5$ are linearly independent.</p>"},{"location":"tutorials/tut05/#d","title":"(d)\u00b6","text":"<p>$S_4 = \\{u, u + v, u + v + w\\}$.</p>"},{"location":"tutorials/tut05/#e","title":"(e)\u00b6","text":"<p>$S_5 = \\{u + v, v + w, u + w, u + v + w\\}$.</p>"},{"location":"tutorials/tut05/#question-3","title":"Question 3\u00b6","text":"<p>For each of the following subspaces $V$, write down a basis for $V$.</p>"},{"location":"tutorials/tut05/#a","title":"(a)\u00b6","text":"<p>$V = \\left\\{\\begin{pmatrix} a + b \\\\ a + c \\\\ c + d \\\\ b + d \\end{pmatrix} \\middle| \\, a, b, c, d \\in \\mathbb{R}\\right\\}$.</p>"},{"location":"tutorials/tut05/#b","title":"(b)\u00b6","text":"<p>$V = \\text{span}\\left\\{\\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\end{pmatrix}, \\begin{pmatrix} -1 \\\\ 2 \\\\ 3 \\end{pmatrix}, \\begin{pmatrix} 0 \\\\ 3 \\\\ 0 \\end{pmatrix}, \\begin{pmatrix} 1 \\\\ -1 \\\\ 1 \\end{pmatrix}\\right\\}$.</p>"},{"location":"tutorials/tut05/#c","title":"(c)\u00b6","text":"<p>$V$ is the solution space of the following homogeneous linear system $$\\begin{cases} a_1 &amp;&amp; &amp;+&amp; a_3 &amp;+&amp; a_4 &amp;-&amp; a_5 &amp;=&amp; 0 \\\\ &amp;&amp; a_2 &amp;+&amp; a_3 &amp;+&amp; 2a_4 &amp;+&amp; a_5 &amp;=&amp; 0 \\\\ a_1 &amp;+&amp; a_2 &amp;+&amp; 2a_3 &amp;+&amp; a_4 &amp;-&amp; 2a_5 &amp;=&amp; 0 \\end{cases}$$</p>"},{"location":"tutorials/tut05/#question-4","title":"Question 4\u00b6","text":"<p>For what values of $a$ will $u_1 = \\begin{pmatrix} a \\\\ 1 \\\\ -1 \\end{pmatrix}$, $u_2 = \\begin{pmatrix} -1 \\\\ a \\\\ 1 \\end{pmatrix}$, $u_3 = \\begin{pmatrix} 1 \\\\ -1 \\\\ a \\end{pmatrix}$ form a basis for $\\mathbb{R}^3$?</p>"},{"location":"tutorials/tut05/#question-5","title":"Question 5\u00b6","text":"<p>Let $U$ and $V$ be subspaces of $\\mathbb{R}^n$. We define the sum $U + V$ to be the set of vectors $\\{u + v \\mid u \\in U \\text{ and } v \\in V\\}$.</p> <p>Suppose $U = \\text{span}\\left\\{\\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\\\ 1 \\end{pmatrix}, \\begin{pmatrix} 1 \\\\ 2 \\\\ 2 \\\\ 1 \\end{pmatrix}\\right\\}$, $V = \\text{span}\\left\\{\\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\\\ 0 \\end{pmatrix}, \\begin{pmatrix} 1 \\\\ 0 \\\\ 2 \\\\ -1 \\end{pmatrix}\\right\\}$.</p>"},{"location":"tutorials/tut05/#b","title":"(b)\u00b6","text":"<p>Show that $U + V$ is a subspace of $\\mathbb{R}^n$ by showing that it can be written as a span of a set. What is the dimension?</p>"},{"location":"tutorials/tut05/#e","title":"(e)\u00b6","text":"<p>Show that $U \\cap V$ a subspace by showing that it can be written as a span of a set. What is the dimension?</p>"},{"location":"tutorials/tut06/","title":"Tutorial 6","text":"In\u00a0[1]: Copied! <pre># Required imports\nimport sympy as sym\nfrom ma1522 import Matrix\n</pre> # Required imports import sympy as sym from ma1522 import Matrix In\u00a0[2]: Copied! <pre>S = Matrix.from_str(\"1 2 -1; 0 2 1; 0 -1 3\").T\nS\n</pre> S = Matrix.from_str(\"1 2 -1; 0 2 1; 0 -1 3\").T S Out[2]:  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 0 &amp; 0\\\\2 &amp; 2 &amp; -1\\\\-1 &amp; 1 &amp; 3\\end{array}\\right]$  In\u00a0[3]: Copied! <pre>S.get_linearly_independent_vectors(verbosity=1)\n</pre> S.get_linearly_independent_vectors(verbosity=1) <pre>Before RREF: [self]\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 0 &amp; 0\\\\2 &amp; 2 &amp; -1\\\\-1 &amp; 1 &amp; 3\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc}1 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 1\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 2)\\right\\}$  <pre>Select columns of self corresponding to pivot positions.\n</pre> Out[3]:  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 0 &amp; 0\\\\2 &amp; 2 &amp; -1\\\\-1 &amp; 1 &amp; 3\\end{array}\\right]$  In\u00a0[4]: Copied! <pre>w = Matrix.from_str(\"1; 1; 1\")\n\nw.coords_relative(S, verbosity=2)\n</pre> w = Matrix.from_str(\"1; 1; 1\")  w.coords_relative(S, verbosity=2) <pre>Before RREF: [to | self]\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc|c}1 &amp; 0 &amp; 0 &amp; 1\\\\2 &amp; 2 &amp; -1 &amp; 1\\\\-1 &amp; 1 &amp; 3 &amp; 1\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc|c}1 &amp; 0 &amp; 0 &amp; 1\\\\0 &amp; 1 &amp; 0 &amp; - \\frac{1}{7}\\\\0 &amp; 0 &amp; 1 &amp; \\frac{5}{7}\\end{array}\\right]$  Out[4]:  $\\displaystyle \\left[\\begin{array}{c}1\\\\- \\frac{1}{7}\\\\\\frac{5}{7}\\end{array}\\right]$  In\u00a0[5]: Copied! <pre>T = Matrix.from_str(\"1 5 4; -1 3 7; 2 2 4\").T\n\nP_T_to_S = T.transition_matrix(S, verbosity=2)\nP_T_to_S\n</pre> T = Matrix.from_str(\"1 5 4; -1 3 7; 2 2 4\").T  P_T_to_S = T.transition_matrix(S, verbosity=2) P_T_to_S <pre>Before RREF: [to | self]\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc|ccc}1 &amp; 0 &amp; 0 &amp; 1 &amp; -1 &amp; 2\\\\2 &amp; 2 &amp; -1 &amp; 5 &amp; 3 &amp; 2\\\\-1 &amp; 1 &amp; 3 &amp; 4 &amp; 7 &amp; 4\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc|ccc}1 &amp; 0 &amp; 0 &amp; 1 &amp; -1 &amp; 2\\\\0 &amp; 1 &amp; 0 &amp; 2 &amp; 3 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 2\\end{array}\\right]$  Out[5]:  $\\displaystyle \\left[\\begin{matrix}1 &amp; -1 &amp; 2\\\\2 &amp; 3 &amp; 0\\\\1 &amp; 1 &amp; 2\\end{matrix}\\right]$  In\u00a0[6]: Copied! <pre>P_S_to_T = S.transition_matrix(T, verbosity=2)\nP_S_to_T\n</pre> P_S_to_T = S.transition_matrix(T, verbosity=2) P_S_to_T <pre>Before RREF: [to | self]\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc|ccc}1 &amp; -1 &amp; 2 &amp; 1 &amp; 0 &amp; 0\\\\5 &amp; 3 &amp; 2 &amp; 2 &amp; 2 &amp; -1\\\\4 &amp; 7 &amp; 4 &amp; -1 &amp; 1 &amp; 3\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc|ccc}1 &amp; 0 &amp; 0 &amp; \\frac{3}{4} &amp; \\frac{1}{2} &amp; - \\frac{3}{4}\\\\0 &amp; 1 &amp; 0 &amp; - \\frac{1}{2} &amp; 0 &amp; \\frac{1}{2}\\\\0 &amp; 0 &amp; 1 &amp; - \\frac{1}{8} &amp; - \\frac{1}{4} &amp; \\frac{5}{8}\\end{array}\\right]$  Out[6]:  $\\displaystyle \\left[\\begin{matrix}\\frac{3}{4} &amp; \\frac{1}{2} &amp; - \\frac{3}{4}\\\\- \\frac{1}{2} &amp; 0 &amp; \\frac{1}{2}\\\\- \\frac{1}{8} &amp; - \\frac{1}{4} &amp; \\frac{5}{8}\\end{matrix}\\right]$  In\u00a0[7]: Copied! <pre>## Alternatively\nP_S_to_T = P_T_to_S.inverse()\nP_S_to_T\n</pre> ## Alternatively P_S_to_T = P_T_to_S.inverse() P_S_to_T Out[7]:  $\\displaystyle \\left[\\begin{array}{ccc}\\frac{3}{4} &amp; \\frac{1}{2} &amp; - \\frac{3}{4}\\\\- \\frac{1}{2} &amp; 0 &amp; \\frac{1}{2}\\\\- \\frac{1}{8} &amp; - \\frac{1}{4} &amp; \\frac{5}{8}\\end{array}\\right]$  In\u00a0[8]: Copied! <pre>w.coords_relative(T, verbosity=2)\n</pre> w.coords_relative(T, verbosity=2) <pre>Before RREF: [to | self]\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc|c}1 &amp; -1 &amp; 2 &amp; 1\\\\5 &amp; 3 &amp; 2 &amp; 1\\\\4 &amp; 7 &amp; 4 &amp; 1\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc|c}1 &amp; 0 &amp; 0 &amp; \\frac{1}{7}\\\\0 &amp; 1 &amp; 0 &amp; - \\frac{1}{7}\\\\0 &amp; 0 &amp; 1 &amp; \\frac{5}{14}\\end{array}\\right]$  Out[8]:  $\\displaystyle \\left[\\begin{array}{c}\\frac{1}{7}\\\\- \\frac{1}{7}\\\\\\frac{5}{14}\\end{array}\\right]$  In\u00a0[9]: Copied! <pre>A = Matrix.from_str(\"1 -1 1; 1 1 -1; -1 -1 1\")\nb = Matrix.from_str(\"2; 1; 0\")\n\ntry:\n    b.coords_relative(A, verbosity=2)\nexcept ValueError as e:\n    print(f\"Error: {e}\") # b is not in the column space of A\n</pre> A = Matrix.from_str(\"1 -1 1; 1 1 -1; -1 -1 1\") b = Matrix.from_str(\"2; 1; 0\")  try:     b.coords_relative(A, verbosity=2) except ValueError as e:     print(f\"Error: {e}\") # b is not in the column space of A <pre>Before RREF: [to | self]\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc|c}1 &amp; -1 &amp; 1 &amp; 2\\\\1 &amp; 1 &amp; -1 &amp; 1\\\\-1 &amp; -1 &amp; 1 &amp; 0\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc|c}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; -1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{array}\\right]$  <pre>Error: No solution found due to inconsistent system.\n</pre> In\u00a0[10]: Copied! <pre>A = Matrix.from_str(\"1 9 1; -1 3 1; 1 1 1\")\nb = Matrix.from_str(\"5 1 -1\")\n\nscalars = b.T.coords_relative(A.T, verbosity=2)\n</pre> A = Matrix.from_str(\"1 9 1; -1 3 1; 1 1 1\") b = Matrix.from_str(\"5 1 -1\")  scalars = b.T.coords_relative(A.T, verbosity=2) <pre>Before RREF: [to | self]\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc|c}1 &amp; -1 &amp; 1 &amp; 5\\\\9 &amp; 3 &amp; 1 &amp; 1\\\\1 &amp; 1 &amp; 1 &amp; -1\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc|c}1 &amp; 0 &amp; 0 &amp; 1\\\\0 &amp; 1 &amp; 0 &amp; -3\\\\0 &amp; 0 &amp; 1 &amp; 1\\end{array}\\right]$  In\u00a0[11]: Copied! <pre>scalars # coordinates relative gives the coefficients of the linear combination\n</pre> scalars # coordinates relative gives the coefficients of the linear combination Out[11]:  $\\displaystyle \\left[\\begin{array}{c}1\\\\-3\\\\1\\end{array}\\right]$  In\u00a0[12]: Copied! <pre>A = Matrix.from_str(\"1 2 0 1; 0 1 2 1; 1 2 1 3; 0 1 2 2\")\nA\n</pre> A = Matrix.from_str(\"1 2 0 1; 0 1 2 1; 1 2 1 3; 0 1 2 2\") A Out[12]:  $\\displaystyle \\left[\\begin{array}{cccc}1 &amp; 2 &amp; 0 &amp; 1\\\\0 &amp; 1 &amp; 2 &amp; 1\\\\1 &amp; 2 &amp; 1 &amp; 3\\\\0 &amp; 1 &amp; 2 &amp; 2\\end{array}\\right]$  In\u00a0[13]: Copied! <pre>A.is_same_subspace(verbosity=2) # other defaults to R^n\n</pre> A.is_same_subspace(verbosity=2) # other defaults to R^n <pre>Check rref(self) does not have zero rows\nBefore RREF: self\n</pre>  $\\displaystyle \\left[\\begin{array}{cccc}1 &amp; 2 &amp; 0 &amp; 1\\\\0 &amp; 1 &amp; 2 &amp; 1\\\\1 &amp; 2 &amp; 1 &amp; 3\\\\0 &amp; 1 &amp; 2 &amp; 2\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\displaystyle \\left[\\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{array}\\right]$  Out[13]: <pre>True</pre> In\u00a0[14]: Copied! <pre>A.T.is_same_subspace(verbosity=2) # other defaults to R^n\n</pre> A.T.is_same_subspace(verbosity=2) # other defaults to R^n <pre>Check rref(self) does not have zero rows\nBefore RREF: self\n</pre>  $\\displaystyle \\left[\\begin{array}{cccc}1 &amp; 0 &amp; 1 &amp; 0\\\\2 &amp; 1 &amp; 2 &amp; 1\\\\0 &amp; 2 &amp; 1 &amp; 2\\\\1 &amp; 1 &amp; 3 &amp; 2\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\displaystyle \\left[\\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{array}\\right]$  Out[14]: <pre>True</pre> In\u00a0[15]: Copied! <pre>A = Matrix.from_str(\"1 2 5 3; 1 -4 -1 -9; -1 0 -3 1; 2 1 7 0; 0 1 1 2\")\nA\n</pre> A = Matrix.from_str(\"1 2 5 3; 1 -4 -1 -9; -1 0 -3 1; 2 1 7 0; 0 1 1 2\") A Out[15]:  $\\displaystyle \\left[\\begin{array}{cccc}1 &amp; 2 &amp; 5 &amp; 3\\\\1 &amp; -4 &amp; -1 &amp; -9\\\\-1 &amp; 0 &amp; -3 &amp; 1\\\\2 &amp; 1 &amp; 7 &amp; 0\\\\0 &amp; 1 &amp; 1 &amp; 2\\end{array}\\right]$  In\u00a0[16]: Copied! <pre># Row space\nA.get_linearly_independent_vectors(colspace=False, verbosity=2) \n</pre> # Row space A.get_linearly_independent_vectors(colspace=False, verbosity=2)  <pre>Before RREF: [self^T]\n</pre>  $\\displaystyle \\left[\\begin{array}{ccccc}1 &amp; 1 &amp; -1 &amp; 2 &amp; 0\\\\2 &amp; -4 &amp; 0 &amp; 1 &amp; 1\\\\5 &amp; -1 &amp; -3 &amp; 7 &amp; 1\\\\3 &amp; -9 &amp; 1 &amp; 0 &amp; 2\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccccc}1 &amp; 0 &amp; - \\frac{2}{3} &amp; \\frac{3}{2} &amp; \\frac{1}{6}\\\\0 &amp; 1 &amp; - \\frac{1}{3} &amp; \\frac{1}{2} &amp; - \\frac{1}{6}\\\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1)\\right\\}$  <pre>Select rows of self corresponding to pivot positions.\n</pre> Out[16]:  $\\displaystyle \\left[\\begin{array}{cccc}1 &amp; 2 &amp; 5 &amp; 3\\\\1 &amp; -4 &amp; -1 &amp; -9\\end{array}\\right]$  In\u00a0[17]: Copied! <pre># Column space\nA.get_linearly_independent_vectors(colspace=True, verbosity=2)\n</pre> # Column space A.get_linearly_independent_vectors(colspace=True, verbosity=2) <pre>Before RREF: [self]\n</pre>  $\\displaystyle \\left[\\begin{array}{cccc}1 &amp; 2 &amp; 5 &amp; 3\\\\1 &amp; -4 &amp; -1 &amp; -9\\\\-1 &amp; 0 &amp; -3 &amp; 1\\\\2 &amp; 1 &amp; 7 &amp; 0\\\\0 &amp; 1 &amp; 1 &amp; 2\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cccc}1 &amp; 0 &amp; 3 &amp; -1\\\\0 &amp; 1 &amp; 1 &amp; 2\\\\0 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1)\\right\\}$  <pre>Select columns of self corresponding to pivot positions.\n</pre> Out[17]:  $\\displaystyle \\left[\\begin{array}{cc}1 &amp; 2\\\\1 &amp; -4\\\\-1 &amp; 0\\\\2 &amp; 1\\\\0 &amp; 1\\end{array}\\right]$  In\u00a0[18]: Copied! <pre>A.nullspace(verbosity=2)\n</pre> A.nullspace(verbosity=2) <pre>Before RREF: [self]\n</pre>  $\\displaystyle \\left[\\begin{array}{cccc}1 &amp; 2 &amp; 5 &amp; 3\\\\1 &amp; -4 &amp; -1 &amp; -9\\\\-1 &amp; 0 &amp; -3 &amp; 1\\\\2 &amp; 1 &amp; 7 &amp; 0\\\\0 &amp; 1 &amp; 1 &amp; 2\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cccc}1 &amp; 0 &amp; 3 &amp; -1\\\\0 &amp; 1 &amp; 1 &amp; 2\\\\0 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1)\\right\\}$  Out[18]:  $\\displaystyle \\left[ \\left[\\begin{matrix}-3\\\\-1\\\\1\\\\0\\end{matrix}\\right], \\  \\left[\\begin{matrix}1\\\\-2\\\\0\\\\1\\end{matrix}\\right]\\right]$  In\u00a0[19]: Copied! <pre>A.rank(), A.nullity()\n</pre> A.rank(), A.nullity() Out[19]:  $\\displaystyle \\left( 2, \\  2\\right)$  In\u00a0[20]: Copied! <pre>A = Matrix.from_str(\"1 3 7; 2 1 8; 3 -5 -1; 2 -2 2; 1 1 5\")\nA\n</pre> A = Matrix.from_str(\"1 3 7; 2 1 8; 3 -5 -1; 2 -2 2; 1 1 5\") A Out[20]:  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 3 &amp; 7\\\\2 &amp; 1 &amp; 8\\\\3 &amp; -5 &amp; -1\\\\2 &amp; -2 &amp; 2\\\\1 &amp; 1 &amp; 5\\end{array}\\right]$  In\u00a0[21]: Copied! <pre># Alternatively, you can use `simplify_basis` to get a simple basis\n# that is not necessarily a row or column of the original matrix.\n\nrowspace = A.simplify_basis(colspace=False, verbosity=2)\nrowspace\n</pre> # Alternatively, you can use `simplify_basis` to get a simple basis # that is not necessarily a row or column of the original matrix.  rowspace = A.simplify_basis(colspace=False, verbosity=2) rowspace <pre>Before RREF: self\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 3 &amp; 7\\\\2 &amp; 1 &amp; 8\\\\3 &amp; -5 &amp; -1\\\\2 &amp; -2 &amp; 2\\\\1 &amp; 1 &amp; 5\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 1\\\\0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0\\end{array}\\right]$  Out[21]:  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 1\\end{array}\\right]$  In\u00a0[22]: Copied! <pre>colspace = A.simplify_basis(colspace=True, verbosity=2)\ncolspace\n</pre> colspace = A.simplify_basis(colspace=True, verbosity=2) colspace <pre>Before RREF: self^T\n</pre>  $\\displaystyle \\left[\\begin{array}{ccccc}1 &amp; 2 &amp; 3 &amp; 2 &amp; 1\\\\3 &amp; 1 &amp; -5 &amp; -2 &amp; 1\\\\7 &amp; 8 &amp; -1 &amp; 2 &amp; 5\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\displaystyle \\left[\\begin{array}{ccccc}1 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; \\frac{4}{13} &amp; \\frac{8}{13}\\\\0 &amp; 0 &amp; 1 &amp; \\frac{6}{13} &amp; - \\frac{1}{13}\\end{array}\\right]$  Out[22]:  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 1\\\\0 &amp; \\frac{4}{13} &amp; \\frac{6}{13}\\\\0 &amp; \\frac{8}{13} &amp; - \\frac{1}{13}\\end{array}\\right]$  In\u00a0[23]: Copied! <pre>A.nullspace(verbosity=2) # UserWarning if the nullspace is trivial\n</pre> A.nullspace(verbosity=2) # UserWarning if the nullspace is trivial <pre>Before RREF: [self]\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 3 &amp; 7\\\\2 &amp; 1 &amp; 8\\\\3 &amp; -5 &amp; -1\\\\2 &amp; -2 &amp; 2\\\\1 &amp; 1 &amp; 5\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc}1 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 1\\\\0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 2)\\right\\}$  <pre>/tmp/ipykernel_2385/40416061.py:1: UserWarning: Only trivial nullspace (0-vector) detected!\n  A.nullspace(verbosity=2) # UserWarning if the nullspace is trivial\n</pre> Out[23]:  $\\displaystyle \\left[ \\right]$  In\u00a0[24]: Copied! <pre>A.rank(), A.nullity()\n</pre> A.rank(), A.nullity() Out[24]:  $\\displaystyle \\left( 3, \\  0\\right)$  In\u00a0[25]: Copied! <pre>W = Matrix.from_str(\"1 -2 0 0 3; 2 -5 -3 -2 6; 0 5 15 10 0; 2 1 15 8 6\").T\nW\n</pre> W = Matrix.from_str(\"1 -2 0 0 3; 2 -5 -3 -2 6; 0 5 15 10 0; 2 1 15 8 6\").T W Out[25]:  $\\displaystyle \\left[\\begin{array}{cccc}1 &amp; 2 &amp; 0 &amp; 2\\\\-2 &amp; -5 &amp; 5 &amp; 1\\\\0 &amp; -3 &amp; 15 &amp; 15\\\\0 &amp; -2 &amp; 10 &amp; 8\\\\3 &amp; 6 &amp; 0 &amp; 6\\end{array}\\right]$  In\u00a0[26]: Copied! <pre>W.get_linearly_independent_vectors(colspace=True, verbosity=2)\n</pre> W.get_linearly_independent_vectors(colspace=True, verbosity=2) <pre>Before RREF: [self]\n</pre>  $\\displaystyle \\left[\\begin{array}{cccc}1 &amp; 2 &amp; 0 &amp; 2\\\\-2 &amp; -5 &amp; 5 &amp; 1\\\\0 &amp; -3 &amp; 15 &amp; 15\\\\0 &amp; -2 &amp; 10 &amp; 8\\\\3 &amp; 6 &amp; 0 &amp; 6\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cccc}1 &amp; 0 &amp; 10 &amp; 0\\\\0 &amp; 1 &amp; -5 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\\\0 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 3)\\right\\}$  <pre>Select columns of self corresponding to pivot positions.\n</pre> Out[26]:  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 2 &amp; 2\\\\-2 &amp; -5 &amp; 1\\\\0 &amp; -3 &amp; 15\\\\0 &amp; -2 &amp; 8\\\\3 &amp; 6 &amp; 6\\end{array}\\right]$  In\u00a0[27]: Copied! <pre># OR\nW.simplify_basis(colspace=True, verbosity=2)\n</pre> # OR W.simplify_basis(colspace=True, verbosity=2) <pre>Before RREF: self^T\n</pre>  $\\displaystyle \\left[\\begin{array}{ccccc}1 &amp; -2 &amp; 0 &amp; 0 &amp; 3\\\\2 &amp; -5 &amp; -3 &amp; -2 &amp; 6\\\\0 &amp; 5 &amp; 15 &amp; 10 &amp; 0\\\\2 &amp; 1 &amp; 15 &amp; 8 &amp; 6\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\displaystyle \\left[\\begin{array}{ccccc}1 &amp; 0 &amp; 6 &amp; 0 &amp; 3\\\\0 &amp; 1 &amp; 3 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right]$  Out[27]:  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0\\\\6 &amp; 3 &amp; 0\\\\0 &amp; 0 &amp; 1\\\\3 &amp; 0 &amp; 0\\end{array}\\right]$  In\u00a0[28]: Copied! <pre>W.extend_basis(verbosity=2)  # span_subspace=None extends to R^n by default\n</pre> W.extend_basis(verbosity=2)  # span_subspace=None extends to R^n by default <pre>Before RREF: [self | span_subspace]\n</pre>  $\\displaystyle \\left[\\begin{array}{cccc|ccccc}1 &amp; 2 &amp; 0 &amp; 2 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\-2 &amp; -5 &amp; 5 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; -3 &amp; 15 &amp; 15 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; -2 &amp; 10 &amp; 8 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0\\\\3 &amp; 6 &amp; 0 &amp; 6 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cccc|ccccc}1 &amp; 0 &amp; 10 &amp; 0 &amp; 0 &amp; 0 &amp; - \\frac{10}{3} &amp; 6 &amp; \\frac{1}{3}\\\\0 &amp; 1 &amp; -5 &amp; 0 &amp; 0 &amp; 0 &amp; \\frac{4}{3} &amp; - \\frac{5}{2} &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; \\frac{1}{3} &amp; - \\frac{1}{2} &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; - \\frac{1}{3}\\\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; - \\frac{1}{3} &amp; 0 &amp; \\frac{2}{3}\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 3, 4, 5)\\right\\}$  <pre>Select columns of rref([self | span_subspace]) corresponding to pivot positions.\n</pre> Out[28]:  $\\displaystyle \\left[\\begin{array}{ccccc}1 &amp; 2 &amp; 2 &amp; 1 &amp; 0\\\\-2 &amp; -5 &amp; 1 &amp; 0 &amp; 1\\\\0 &amp; -3 &amp; 15 &amp; 0 &amp; 0\\\\0 &amp; -2 &amp; 8 &amp; 0 &amp; 0\\\\3 &amp; 6 &amp; 6 &amp; 0 &amp; 0\\end{array}\\right]$  In\u00a0[29]: Copied! <pre># Alternatively, use the `simplify_basis` method first for a simpler basis overall\nW.simplify_basis(colspace=True, verbosity=0).extend_basis(verbosity=2) \n</pre> # Alternatively, use the `simplify_basis` method first for a simpler basis overall W.simplify_basis(colspace=True, verbosity=0).extend_basis(verbosity=2)  <pre>Before RREF: [self | span_subspace]\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc|ccccc}1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0\\\\6 &amp; 3 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0\\\\3 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc|ccccc}1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\frac{1}{3}\\\\0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; \\frac{1}{3} &amp; 0 &amp; - \\frac{2}{3}\\\\0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; - \\frac{1}{3}\\\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; - \\frac{1}{3} &amp; 0 &amp; \\frac{2}{3}\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 2, 3, 4)\\right\\}$  <pre>Select columns of rref([self | span_subspace]) corresponding to pivot positions.\n</pre> Out[29]:  $\\displaystyle \\left[\\begin{array}{ccccc}1 &amp; 0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0 &amp; 1\\\\6 &amp; 3 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0 &amp; 0\\\\3 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right]$  In\u00a0[30]: Copied! <pre>V = Matrix.from_str(\"1 0 1 3; 2 -1 0 1; -1 3 5 12; 0 1 2 5; 3 -1 1 4\").T\nV\n</pre> V = Matrix.from_str(\"1 0 1 3; 2 -1 0 1; -1 3 5 12; 0 1 2 5; 3 -1 1 4\").T V Out[30]:  $\\displaystyle \\left[\\begin{array}{ccccc}1 &amp; 2 &amp; -1 &amp; 0 &amp; 3\\\\0 &amp; -1 &amp; 3 &amp; 1 &amp; -1\\\\1 &amp; 0 &amp; 5 &amp; 2 &amp; 1\\\\3 &amp; 1 &amp; 12 &amp; 5 &amp; 4\\end{array}\\right]$  In\u00a0[31]: Copied! <pre>S_prime = V.get_linearly_independent_vectors(colspace=True, verbosity=2)\nS_prime\n</pre> S_prime = V.get_linearly_independent_vectors(colspace=True, verbosity=2) S_prime <pre>Before RREF: [self]\n</pre>  $\\displaystyle \\left[\\begin{array}{ccccc}1 &amp; 2 &amp; -1 &amp; 0 &amp; 3\\\\0 &amp; -1 &amp; 3 &amp; 1 &amp; -1\\\\1 &amp; 0 &amp; 5 &amp; 2 &amp; 1\\\\3 &amp; 1 &amp; 12 &amp; 5 &amp; 4\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccccc}1 &amp; 0 &amp; 5 &amp; 2 &amp; 1\\\\0 &amp; 1 &amp; -3 &amp; -1 &amp; 1\\\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1)\\right\\}$  <pre>Select columns of self corresponding to pivot positions.\n</pre> Out[31]:  $\\displaystyle \\left[\\begin{array}{cc}1 &amp; 2\\\\0 &amp; -1\\\\1 &amp; 0\\\\3 &amp; 1\\end{array}\\right]$"},{"location":"tutorials/tut06/#tutorial-6-ay2425-sem-1","title":"Tutorial 6 (AY24/25 Sem 1)\u00b6","text":""},{"location":"tutorials/tut06/#question-1","title":"Question 1\u00b6","text":""},{"location":"tutorials/tut06/#a","title":"(a)\u00b6","text":"<p>Let $\\mathbf{u}_1 = \\begin{pmatrix} 1 \\\\ 2 \\\\ -1 \\end{pmatrix}$, $\\mathbf{u}_2 = \\begin{pmatrix} 0 \\\\ 2 \\\\ 1 \\end{pmatrix}$, $\\mathbf{u}_3 = \\begin{pmatrix} 0 \\\\ -1 \\\\ 3 \\end{pmatrix}$. Show that $S = \\{\\mathbf{u}_1, \\mathbf{u}_2, \\mathbf{u}_3\\}$ forms a basis for $\\mathbb{R}^3$.</p>"},{"location":"tutorials/tut06/#b","title":"(b)\u00b6","text":"<p>Suppose $\\mathbf{w} = \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix}$. Find the coordinate vector of $\\mathbf{w}$ relative to $S$.</p>"},{"location":"tutorials/tut06/#c","title":"(c)\u00b6","text":"<p>Let $T = \\{\\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{v}_3\\}$ be another basis for $\\mathbb{R}^3$ where $\\mathbf{v}_1 = \\begin{pmatrix} 1 \\\\ 5 \\\\ 4 \\end{pmatrix}$, $\\mathbf{v}_2 = \\begin{pmatrix} -1 \\\\ 3 \\\\ 7 \\end{pmatrix}$, $\\mathbf{v}_3 = \\begin{pmatrix} 2 \\\\ 2 \\\\ 4 \\end{pmatrix}$. Find the transition matrix from $T$ to $S$.</p>"},{"location":"tutorials/tut06/#d","title":"(d)\u00b6","text":"<p>Find the transition matrix from $S$ to $T$.</p>"},{"location":"tutorials/tut06/#e","title":"(e)\u00b6","text":"<p>Use the vector $\\mathbf{w}$ in Part (b). Find the coordinate vector of $\\mathbf{w}$ relative to $T$.</p>"},{"location":"tutorials/tut06/#question-3","title":"Question 3\u00b6","text":""},{"location":"tutorials/tut06/#a","title":"(a)\u00b6","text":"<p>Let $\\mathbf{A} = \\begin{pmatrix} 1 &amp; -1 &amp; 1 \\\\ 1 &amp; 1 &amp; -1 \\\\ -1 &amp; -1 &amp; 1 \\end{pmatrix}$ and $\\mathbf{b} = \\begin{pmatrix} 2 \\\\ 1 \\\\ 0 \\end{pmatrix}$. Is $\\mathbf{b}$ in the column space of $\\mathbf{A}$? If it is, express it as a linear combination of the columns of $\\mathbf{A}$.</p>"},{"location":"tutorials/tut06/#b","title":"(b)\u00b6","text":"<p>Let $\\mathbf{A} = \\begin{pmatrix} 1 &amp; 9 &amp; 1 \\\\ -1 &amp; 3 &amp; 1 \\\\ 1 &amp; 1 &amp; 1 \\end{pmatrix}$ and $\\mathbf{b} = \\begin{pmatrix}5 &amp; 1 &amp; -1\\end{pmatrix}$. Is $\\mathbf{b}$ in the row space of $\\mathbf{A}$? If it is, express it as a linear combination of the rows of $\\mathbf{A}$.</p>"},{"location":"tutorials/tut06/#c","title":"(c)\u00b6","text":"<p>Let $\\mathbf{A} = \\begin{pmatrix} 1 &amp; 2 &amp; 0 &amp; 1 \\\\ 0 &amp; 1 &amp; 2 &amp; 1 \\\\ 1 &amp; 2 &amp; 1 &amp; 3 \\\\ 0 &amp; 1 &amp; 2 &amp; 2 \\end{pmatrix}$. Is the row space and column space of $\\mathbf{A}$ the whole $\\mathbb{R}^4$?</p>"},{"location":"tutorials/tut06/#problem-4","title":"Problem 4\u00b6","text":"<p>For each of the following matrices $\\mathbf{A}$,</p> <p>(i) Find a basis for the row space of $\\mathbf{A}$.</p> <p>(ii) Find a basis for the column space of $\\mathbf{A}$.</p> <p>(iii) Find a basis for the nullspace of $\\mathbf{A}$.</p> <p>(iv) Hence determine $\\text{rank}(\\mathbf{A})$, $\\text{nullity}(\\mathbf{A})$ and verify the dimension theorem for matrices.</p> <p>(v) Is $\\mathbf{A}$ full rank?</p>"},{"location":"tutorials/tut06/#a","title":"(a)\u00b6","text":"<p>$\\mathbf{A} = \\begin{pmatrix} 1 &amp; 2 &amp; 5 &amp; 3 \\\\ 1 &amp; -4 &amp; -1 &amp; -9 \\\\ -1 &amp; 0 &amp; -3 &amp; 1 \\\\ 2 &amp; 1 &amp; 7 &amp; 0 \\\\ 0 &amp; 1 &amp; 1 &amp; 2 \\end{pmatrix}$</p>"},{"location":"tutorials/tut06/#b","title":"(b)\u00b6","text":"<p>$\\mathbf{A} = \\begin{pmatrix} 1 &amp; 3 &amp; 7 \\\\ 2 &amp; 1 &amp; 8 \\\\ 3 &amp; -5 &amp; -1 \\\\ 2 &amp; -2 &amp; 2 \\\\ 1 &amp; 1 &amp; 5 \\end{pmatrix}$</p>"},{"location":"tutorials/tut06/#question-5","title":"Question 5\u00b6","text":"<p>Let $W$ be a subspace of $\\mathbb{R}^5$ spanned by the following vectors $$\\mathbf{u}_1 = \\begin{pmatrix} 1 \\\\ -2 \\\\ 0 \\\\ 0 \\\\ 3 \\end{pmatrix}, \\quad \\mathbf{u}_2 = \\begin{pmatrix} 2 \\\\ -5 \\\\ -3 \\\\ -2 \\\\ 6 \\end{pmatrix}, \\quad \\mathbf{u}_3 = \\begin{pmatrix} 0 \\\\ 5 \\\\ 15 \\\\ 10 \\\\ 0 \\end{pmatrix}, \\quad \\mathbf{u}_4 = \\begin{pmatrix} 2 \\\\ 1 \\\\ 15 \\\\ 8 \\\\ 6 \\end{pmatrix}$$</p>"},{"location":"tutorials/tut06/#a","title":"(a)\u00b6","text":"<p>Find a basis for $W$.</p>"},{"location":"tutorials/tut06/#c","title":"(c)\u00b6","text":"<p>Extend the basis $W$ found in (a) to a basis for $\\mathbb{R}^5$.</p>"},{"location":"tutorials/tut06/#question-6","title":"Question 6\u00b6","text":"<p>Let $S = \\left\\{ \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\\\ 3 \\end{pmatrix}, \\begin{pmatrix} 2 \\\\ -1 \\\\ 0 \\\\ 1 \\end{pmatrix}, \\begin{pmatrix} -1 \\\\ 3 \\\\ 5 \\\\ 12 \\end{pmatrix}, \\begin{pmatrix} 0 \\\\ 1 \\\\ 2 \\\\ 5 \\end{pmatrix}, \\begin{pmatrix} 3 \\\\ -1 \\\\ 1 \\\\ 4 \\end{pmatrix} \\right\\}$ and $V = \\text{span}(S)$. Find a subset $S' \\subseteq S$ such that $S'$ forms a basis for $V$.</p>"},{"location":"tutorials/tut07/","title":"Tutorial 7","text":"In\u00a0[1]: Copied! <pre># Required imports\nimport sympy as sym\nfrom ma1522 import Matrix\n</pre> # Required imports import sympy as sym from ma1522 import Matrix In\u00a0[2]: Copied! <pre># set n = 4\na = Matrix.create_unk_matrix(r=4, symbol=\"a\")\nx = Matrix.create_unk_matrix(r=4, symbol=\"x\")\na, x\n</pre> # set n = 4 a = Matrix.create_unk_matrix(r=4, symbol=\"a\") x = Matrix.create_unk_matrix(r=4, symbol=\"x\") a, x Out[2]:  $\\displaystyle \\left( \\left[\\begin{array}{c}a_{1}\\\\a_{2}\\\\a_{3}\\\\a_{4}\\end{array}\\right], \\  \\left[\\begin{array}{c}x_{1}\\\\x_{2}\\\\x_{3}\\\\x_{4}\\end{array}\\right]\\right)$  In\u00a0[3]: Copied! <pre>mat = Matrix.from_str(\"1 3 -2 0; 2 6 -5 -2; 0 0 5 10\")\naug = Matrix.zeros(rows=3, cols=1)\nmat, aug\n</pre> mat = Matrix.from_str(\"1 3 -2 0; 2 6 -5 -2; 0 0 5 10\") aug = Matrix.zeros(rows=3, cols=1) mat, aug Out[3]:  $\\displaystyle \\left( \\left[\\begin{array}{cccc}1 &amp; 3 &amp; -2 &amp; 0\\\\2 &amp; 6 &amp; -5 &amp; -2\\\\0 &amp; 0 &amp; 5 &amp; 10\\end{array}\\right], \\  \\left[\\begin{array}{c}0\\\\0\\\\0\\end{array}\\right]\\right)$  In\u00a0[4]: Copied! <pre>sol = mat.solve(aug)\nsol\n</pre> sol = mat.solve(aug) sol Out[4]:  $\\displaystyle \\left[ \\left[\\begin{array}{c}- 3 x - 4 z\\\\x\\\\- 2 z\\\\z\\end{array}\\right]\\right]$  In\u00a0[5]: Copied! <pre>sol.sep_unk()\n</pre> sol.sep_unk() <pre>\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[5], line 1\n----&gt; 1 sol.sep_unk()\n\nAttributeError: 'list' object has no attribute 'sep_unk'</pre> In\u00a0[6]: Copied! <pre># Alternatively, use nullspace to find the solution set\nmat.nullspace(verbosity=1) \n</pre> # Alternatively, use nullspace to find the solution set mat.nullspace(verbosity=1)  <pre>Before RREF: [self]\n</pre>  $\\displaystyle \\left[\\begin{array}{cccc}1 &amp; 3 &amp; -2 &amp; 0\\\\2 &amp; 6 &amp; -5 &amp; -2\\\\0 &amp; 0 &amp; 5 &amp; 10\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cccc}1 &amp; 3 &amp; 0 &amp; 4\\\\0 &amp; 0 &amp; 1 &amp; 2\\\\0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 2)\\right\\}$  Out[6]:  $\\displaystyle \\left[ \\left[\\begin{matrix}-3\\\\1\\\\0\\\\0\\end{matrix}\\right], \\  \\left[\\begin{matrix}-4\\\\0\\\\-2\\\\1\\end{matrix}\\right]\\right]$  In\u00a0[7]: Copied! <pre>A = Matrix.from_str(\"1 3 -2 0; 2 6 -5 -2; 0 0 5 10\").T\nv = Matrix.create_unk_matrix(r=4, symbol=\"v\")\nA, v\n</pre> A = Matrix.from_str(\"1 3 -2 0; 2 6 -5 -2; 0 0 5 10\").T v = Matrix.create_unk_matrix(r=4, symbol=\"v\") A, v Out[7]:  $\\displaystyle \\left( \\left[\\begin{array}{ccc}1 &amp; 2 &amp; 0\\\\3 &amp; 6 &amp; 0\\\\-2 &amp; -5 &amp; 5\\\\0 &amp; -2 &amp; 10\\end{array}\\right], \\  \\left[\\begin{array}{c}v_{1}\\\\v_{2}\\\\v_{3}\\\\v_{4}\\end{array}\\right]\\right)$  In\u00a0[8]: Copied! <pre># Fast method to find v without showing the steps\nsol = sym.solve(A.T @ v, v)\nv.subs(sol)\n</pre> # Fast method to find v without showing the steps sol = sym.solve(A.T @ v, v) v.subs(sol) Out[8]:  $\\displaystyle \\left[\\begin{array}{c}- 3 v_{2} - 4 v_{4}\\\\v_{2}\\\\- 2 v_{4}\\\\v_{4}\\end{array}\\right]$  In\u00a0[9]: Copied! <pre># Alternative method using `orthogonal_complement`\nmat = A.orthogonal_complement(verbosity=1)\nmat\n</pre> # Alternative method using `orthogonal_complement` mat = A.orthogonal_complement(verbosity=1) mat <pre>Before RREF: [self]\n</pre>  $\\displaystyle \\left[\\begin{matrix}1 &amp; 3 &amp; -2 &amp; 0\\\\2 &amp; 6 &amp; -5 &amp; -2\\\\0 &amp; 0 &amp; 5 &amp; 10\\end{matrix}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cccc}1 &amp; 3 &amp; 0 &amp; 4\\\\0 &amp; 0 &amp; 1 &amp; 2\\\\0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 2)\\right\\}$  Out[9]:  $\\displaystyle \\left[\\begin{array}{cc}-3 &amp; -4\\\\1 &amp; 0\\\\0 &amp; -2\\\\0 &amp; 1\\end{array}\\right]$  In\u00a0[10]: Copied! <pre>free_params = Matrix.create_unk_matrix(r=2)\nmat @ free_params\n</pre> free_params = Matrix.create_unk_matrix(r=2) mat @ free_params Out[10]:  $\\displaystyle \\left[\\begin{array}{c}- 3 x - 4 y\\\\x\\\\- 2 y\\\\y\\end{array}\\right]$  In\u00a0[11]: Copied! <pre>v1 = Matrix.from_str(\"1; 2; -1\")\nv2 = Matrix.from_str(\"1; 0; 1\")\nv1, v2\n</pre> v1 = Matrix.from_str(\"1; 2; -1\") v2 = Matrix.from_str(\"1; 0; 1\") v1, v2 Out[11]:  $\\displaystyle \\left( \\left[\\begin{array}{c}1\\\\2\\\\-1\\end{array}\\right], \\  \\left[\\begin{array}{c}1\\\\0\\\\1\\end{array}\\right]\\right)$  In\u00a0[12]: Copied! <pre># use `dot` method for explicit dot product\nv1.dot(v1), v1.dot(v2), v2.dot(v1), v2.dot(v2)\n</pre> # use `dot` method for explicit dot product v1.dot(v1), v1.dot(v2), v2.dot(v1), v2.dot(v2) Out[12]:  $\\displaystyle \\left( 6, \\  0, \\  0, \\  2\\right)$  In\u00a0[13]: Copied! <pre>V = v1.row_join(v2)\nV.T @ V\n</pre> V = v1.row_join(v2) V.T @ V Out[13]:  $\\displaystyle \\left[\\begin{array}{cc}6 &amp; 0\\\\0 &amp; 2\\end{array}\\right]$  In\u00a0[14]: Copied! <pre>S = Matrix.from_str(\"1 1 1 1 1; 1 2 -1 -2 0; 1 -1 1 -1 0\").T\nS\n</pre> S = Matrix.from_str(\"1 1 1 1 1; 1 2 -1 -2 0; 1 -1 1 -1 0\").T S Out[14]:  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 1 &amp; 1\\\\1 &amp; 2 &amp; -1\\\\1 &amp; -1 &amp; 1\\\\1 &amp; -2 &amp; -1\\\\1 &amp; 0 &amp; 0\\end{array}\\right]$  In\u00a0[15]: Copied! <pre>S.is_linearly_independent(verbosity=2)\n</pre> S.is_linearly_independent(verbosity=2) <pre>Before RREF: self\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 1 &amp; 1\\\\1 &amp; 2 &amp; -1\\\\1 &amp; -1 &amp; 1\\\\1 &amp; -2 &amp; -1\\\\1 &amp; 0 &amp; 0\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 1\\\\0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0\\end{array}\\right]$  <pre>Check if Number of columns (3) == Number of pivot columns (3)\n</pre> Out[15]: <pre>True</pre> In\u00a0[16]: Copied! <pre>S.is_vec_orthogonal(verbosity=1)\n</pre> S.is_vec_orthogonal(verbosity=1) <pre>Check if [self^T @ self] is a diagonal matrix\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc}5 &amp; 0 &amp; 0\\\\0 &amp; 10 &amp; 0\\\\0 &amp; 0 &amp; 4\\end{array}\\right]$  Out[16]: <pre>True</pre> In\u00a0[17]: Copied! <pre>W_perp = S.orthogonal_complement(verbosity=1)\nW_perp\n</pre> W_perp = S.orthogonal_complement(verbosity=1) W_perp <pre>Before RREF: [self]\n</pre>  $\\displaystyle \\left[\\begin{matrix}1 &amp; 1 &amp; 1 &amp; 1 &amp; 1\\\\1 &amp; 2 &amp; -1 &amp; -2 &amp; 0\\\\1 &amp; -1 &amp; 1 &amp; -1 &amp; 0\\end{matrix}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccccc}1 &amp; 0 &amp; 0 &amp; -2 &amp; - \\frac{1}{4}\\\\0 &amp; 1 &amp; 0 &amp; 1 &amp; \\frac{1}{2}\\\\0 &amp; 0 &amp; 1 &amp; 2 &amp; \\frac{3}{4}\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 2)\\right\\}$  Out[17]:  $\\displaystyle \\left[\\begin{array}{cc}2 &amp; \\frac{1}{4}\\\\-1 &amp; - \\frac{1}{2}\\\\-2 &amp; - \\frac{3}{4}\\\\1 &amp; 0\\\\0 &amp; 1\\end{array}\\right]$  In\u00a0[18]: Copied! <pre># `normalized` is a mutable method, so use `copy` to avoid modifying S\nT = S.copy().normalized()\nT\n</pre> # `normalized` is a mutable method, so use `copy` to avoid modifying S T = S.copy().normalized() T Out[18]:  $\\displaystyle \\left[\\begin{array}{ccc}\\frac{\\sqrt{5}}{5} &amp; \\frac{\\sqrt{10}}{10} &amp; \\frac{1}{2}\\\\\\frac{\\sqrt{5}}{5} &amp; \\frac{\\sqrt{10}}{5} &amp; - \\frac{1}{2}\\\\\\frac{\\sqrt{5}}{5} &amp; - \\frac{\\sqrt{10}}{10} &amp; \\frac{1}{2}\\\\\\frac{\\sqrt{5}}{5} &amp; - \\frac{\\sqrt{10}}{5} &amp; - \\frac{1}{2}\\\\\\frac{\\sqrt{5}}{5} &amp; 0 &amp; 0\\end{array}\\right]$  In\u00a0[19]: Copied! <pre># Use ScalarFactor so that it is easier to read the matrix\nT = S.copy().normalized(factor=True)\nT\n</pre> # Use ScalarFactor so that it is easier to read the matrix T = S.copy().normalized(factor=True) T Out[19]:  $\\left[\\begin{array}{ccc}1 &amp; \\frac{1}{10} &amp; 1\\\\1 &amp; \\frac{1}{5} &amp; -1\\\\1 &amp; - \\frac{1}{10} &amp; 1\\\\1 &amp; - \\frac{1}{5} &amp; -1\\\\1 &amp; 0 &amp; 0\\end{array}\\right]\\left[\\begin{array}{ccc}\\frac{1}{\\sqrt{5}} &amp; 0 &amp; 0\\\\0 &amp; \\sqrt{10} &amp; 0\\\\0 &amp; 0 &amp; \\frac{1}{2}\\end{array}\\right]$  In\u00a0[20]: Copied! <pre>v = Matrix.from_str(\"2; 0; 1; 1; -1\")\nW = S # W is the subspace spanned by S\n# `proj_comp` solves least squares solution under the hood and \n# does not require W to be a set of orthonormal column vectors\nv_proj = v.proj_comp(W, verbosity=1)\n</pre> v = Matrix.from_str(\"2; 0; 1; 1; -1\") W = S # W is the subspace spanned by S # `proj_comp` solves least squares solution under the hood and  # does not require W to be a set of orthonormal column vectors v_proj = v.proj_comp(W, verbosity=1) <pre>self.T @ self is invertible. The lest squares solution is unique.\n</pre>  $\\displaystyle \\mathbf{x} = \\left(\\mathbf{A}^\\top \\mathbf{A}\\right)^{-1} \\mathbf{A}^\\top \\mathbf{b}$   $\\displaystyle \\left[\\begin{array}{c}\\frac{3}{5}\\\\- \\frac{1}{10}\\\\\\frac{1}{2}\\end{array}\\right]$  <pre>Projected component: Au\n</pre>  $\\displaystyle \\left[\\begin{array}{c}1\\\\- \\frac{1}{10}\\\\\\frac{6}{5}\\\\\\frac{3}{10}\\\\\\frac{3}{5}\\end{array}\\right]$  <pre>Normal component: b - b_proj\n</pre>  $\\displaystyle \\left[\\begin{array}{c}1\\\\\\frac{1}{10}\\\\- \\frac{1}{5}\\\\\\frac{7}{10}\\\\- \\frac{8}{5}\\end{array}\\right]$  In\u00a0[21]: Copied! <pre>v_norm = v - v_proj\naug_mat = W_perp.row_join(v_norm)\naug_mat\n</pre> v_norm = v - v_proj aug_mat = W_perp.row_join(v_norm) aug_mat Out[21]:  $\\displaystyle \\left[\\begin{array}{cc|c}2 &amp; \\frac{1}{4} &amp; 1\\\\-1 &amp; - \\frac{1}{2} &amp; \\frac{1}{10}\\\\-2 &amp; - \\frac{3}{4} &amp; - \\frac{1}{5}\\\\1 &amp; 0 &amp; \\frac{7}{10}\\\\0 &amp; 1 &amp; - \\frac{8}{5}\\end{array}\\right]$  In\u00a0[22]: Copied! <pre>aug_mat.rref() # consistent system, so v_norm is in W_perp\n</pre> aug_mat.rref() # consistent system, so v_norm is in W_perp Out[22]:  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cc|c}1 &amp; 0 &amp; \\frac{7}{10}\\\\0 &amp; 1 &amp; - \\frac{8}{5}\\\\0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1)\\right\\}$  In\u00a0[23]: Copied! <pre>S = Matrix.from_str(\"1 2 2 -1; 1 1 -1 1; -1 1 -1 -1; -2 1 1 2\").T\nS\n</pre> S = Matrix.from_str(\"1 2 2 -1; 1 1 -1 1; -1 1 -1 -1; -2 1 1 2\").T S Out[23]:  $\\displaystyle \\left[\\begin{array}{cccc}1 &amp; 1 &amp; -1 &amp; -2\\\\2 &amp; 1 &amp; 1 &amp; 1\\\\2 &amp; -1 &amp; -1 &amp; 1\\\\-1 &amp; 1 &amp; -1 &amp; 2\\end{array}\\right]$  In\u00a0[24]: Copied! <pre>S.is_vec_orthogonal(verbosity=1)\n</pre> S.is_vec_orthogonal(verbosity=1) <pre>Check if [self^T @ self] is a diagonal matrix\n</pre>  $\\displaystyle \\left[\\begin{array}{cccc}10 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 4 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 4 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 10\\end{array}\\right]$  Out[24]: <pre>True</pre> In\u00a0[25]: Copied! <pre>w = Matrix.orthogonal_complement(S, verbosity=1) # No orthogonal complement found\n</pre> w = Matrix.orthogonal_complement(S, verbosity=1) # No orthogonal complement found <pre>Before RREF: [self]\n</pre>  $\\displaystyle \\left[\\begin{matrix}1 &amp; 2 &amp; 2 &amp; -1\\\\1 &amp; 1 &amp; -1 &amp; 1\\\\-1 &amp; 1 &amp; -1 &amp; -1\\\\-2 &amp; 1 &amp; 1 &amp; 2\\end{matrix}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 2, 3)\\right\\}$  <pre>/home/runner/work/linear-algebra/linear-algebra/src/ma1522/symbolic.py:2870: UserWarning: Only trivial nullspace (0-vector) detected!\n  return Matrix.from_list(self.transpose().nullspace(verbosity))\n</pre> In\u00a0[26]: Copied! <pre>T = S.copy().normalized(factor=True)\nT\n</pre> T = S.copy().normalized(factor=True) T Out[26]:  $\\left[\\begin{array}{cccc}1 &amp; 1 &amp; -1 &amp; -2\\\\2 &amp; 1 &amp; 1 &amp; 1\\\\2 &amp; -1 &amp; -1 &amp; 1\\\\-1 &amp; 1 &amp; -1 &amp; 2\\end{array}\\right]\\left[\\begin{array}{cccc}\\frac{1}{\\sqrt{10}} &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; \\frac{1}{2} &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; \\frac{1}{2} &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; \\frac{1}{\\sqrt{10}}\\end{array}\\right]$  In\u00a0[27]: Copied! <pre>v = Matrix.from_str(\"0; 1; 2; 3\")\nv\n</pre> v = Matrix.from_str(\"0; 1; 2; 3\") v Out[27]:  $\\displaystyle \\left[\\begin{array}{c}0\\\\1\\\\2\\\\3\\end{array}\\right]$  In\u00a0[28]: Copied! <pre>v_S = v.coords_relative(S, verbosity=2)\nv_S\n</pre> v_S = v.coords_relative(S, verbosity=2) v_S <pre>Before RREF: [to | self]\n</pre>  $\\displaystyle \\left[\\begin{array}{cccc|c}1 &amp; 1 &amp; -1 &amp; -2 &amp; 0\\\\2 &amp; 1 &amp; 1 &amp; 1 &amp; 1\\\\2 &amp; -1 &amp; -1 &amp; 1 &amp; 2\\\\-1 &amp; 1 &amp; -1 &amp; 2 &amp; 3\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\displaystyle \\left[\\begin{array}{cccc|c}1 &amp; 0 &amp; 0 &amp; 0 &amp; \\frac{3}{10}\\\\0 &amp; 1 &amp; 0 &amp; 0 &amp; \\frac{1}{2}\\\\0 &amp; 0 &amp; 1 &amp; 0 &amp; -1\\\\0 &amp; 0 &amp; 0 &amp; 1 &amp; \\frac{9}{10}\\end{array}\\right]$  Out[28]:  $\\displaystyle \\left[\\begin{array}{c}\\frac{3}{10}\\\\\\frac{1}{2}\\\\-1\\\\\\frac{9}{10}\\end{array}\\right]$  In\u00a0[29]: Copied! <pre>T = T.eval() # Convert the ScalarFactor to a regular matrix\nv_T = v.coords_relative(T, verbosity=2)\nv_T\n</pre> T = T.eval() # Convert the ScalarFactor to a regular matrix v_T = v.coords_relative(T, verbosity=2) v_T <pre>Before RREF: [to | self]\n</pre>  $\\displaystyle \\left[\\begin{array}{cccc|c}\\frac{\\sqrt{10}}{10} &amp; \\frac{1}{2} &amp; - \\frac{1}{2} &amp; - \\frac{\\sqrt{10}}{5} &amp; 0\\\\\\frac{\\sqrt{10}}{5} &amp; \\frac{1}{2} &amp; \\frac{1}{2} &amp; \\frac{\\sqrt{10}}{10} &amp; 1\\\\\\frac{\\sqrt{10}}{5} &amp; - \\frac{1}{2} &amp; - \\frac{1}{2} &amp; \\frac{\\sqrt{10}}{10} &amp; 2\\\\- \\frac{\\sqrt{10}}{10} &amp; \\frac{1}{2} &amp; - \\frac{1}{2} &amp; \\frac{\\sqrt{10}}{5} &amp; 3\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\displaystyle \\left[\\begin{array}{cccc|c}1 &amp; 0 &amp; 0 &amp; 0 &amp; \\frac{3 \\sqrt{10}}{10}\\\\0 &amp; 1 &amp; 0 &amp; 0 &amp; 1\\\\0 &amp; 0 &amp; 1 &amp; 0 &amp; -2\\\\0 &amp; 0 &amp; 0 &amp; 1 &amp; \\frac{9 \\sqrt{10}}{10}\\end{array}\\right]$  Out[29]:  $\\displaystyle \\left[\\begin{array}{c}\\frac{3 \\sqrt{10}}{10}\\\\1\\\\-2\\\\\\frac{9 \\sqrt{10}}{10}\\end{array}\\right]$  In\u00a0[30]: Copied! <pre>w_S = Matrix.from_str(\"1; 2; 1; 1\")\nw_S\n</pre> w_S = Matrix.from_str(\"1; 2; 1; 1\") w_S Out[30]:  $\\displaystyle \\left[\\begin{array}{c}1\\\\2\\\\1\\\\1\\end{array}\\right]$  In\u00a0[31]: Copied! <pre># Quick and dirty way to find w_T\nw = S @ w_S\nw\n</pre> # Quick and dirty way to find w_T w = S @ w_S w Out[31]:  $\\displaystyle \\left[\\begin{array}{c}0\\\\6\\\\0\\\\2\\end{array}\\right]$  In\u00a0[32]: Copied! <pre>w_T = w.coords_relative(T, verbosity=2)\nw_T\n</pre> w_T = w.coords_relative(T, verbosity=2) w_T <pre>Before RREF: [to | self]\n</pre>  $\\displaystyle \\left[\\begin{array}{cccc|c}\\frac{\\sqrt{10}}{10} &amp; \\frac{1}{2} &amp; - \\frac{1}{2} &amp; - \\frac{\\sqrt{10}}{5} &amp; 0\\\\\\frac{\\sqrt{10}}{5} &amp; \\frac{1}{2} &amp; \\frac{1}{2} &amp; \\frac{\\sqrt{10}}{10} &amp; 6\\\\\\frac{\\sqrt{10}}{5} &amp; - \\frac{1}{2} &amp; - \\frac{1}{2} &amp; \\frac{\\sqrt{10}}{10} &amp; 0\\\\- \\frac{\\sqrt{10}}{10} &amp; \\frac{1}{2} &amp; - \\frac{1}{2} &amp; \\frac{\\sqrt{10}}{5} &amp; 2\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\displaystyle \\left[\\begin{array}{cccc|c}1 &amp; 0 &amp; 0 &amp; 0 &amp; \\sqrt{10}\\\\0 &amp; 1 &amp; 0 &amp; 0 &amp; 4\\\\0 &amp; 0 &amp; 1 &amp; 0 &amp; 2\\\\0 &amp; 0 &amp; 0 &amp; 1 &amp; \\sqrt{10}\\end{array}\\right]$  Out[32]:  $\\displaystyle \\left[\\begin{array}{c}\\sqrt{10}\\\\4\\\\2\\\\\\sqrt{10}\\end{array}\\right]$  In\u00a0[33]: Copied! <pre># Alternative way via `transition_matrix`\n\nS_to_T = S.transition_matrix(T, verbosity=2)\nS_to_T\n</pre> # Alternative way via `transition_matrix`  S_to_T = S.transition_matrix(T, verbosity=2) S_to_T <pre>Before RREF: [to | self]\n</pre>  $\\displaystyle \\left[\\begin{array}{cccc|cccc}\\frac{\\sqrt{10}}{10} &amp; \\frac{1}{2} &amp; - \\frac{1}{2} &amp; - \\frac{\\sqrt{10}}{5} &amp; 1 &amp; 1 &amp; -1 &amp; -2\\\\\\frac{\\sqrt{10}}{5} &amp; \\frac{1}{2} &amp; \\frac{1}{2} &amp; \\frac{\\sqrt{10}}{10} &amp; 2 &amp; 1 &amp; 1 &amp; 1\\\\\\frac{\\sqrt{10}}{5} &amp; - \\frac{1}{2} &amp; - \\frac{1}{2} &amp; \\frac{\\sqrt{10}}{10} &amp; 2 &amp; -1 &amp; -1 &amp; 1\\\\- \\frac{\\sqrt{10}}{10} &amp; \\frac{1}{2} &amp; - \\frac{1}{2} &amp; \\frac{\\sqrt{10}}{5} &amp; -1 &amp; 1 &amp; -1 &amp; 2\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\displaystyle \\left[\\begin{array}{cccc|cccc}1 &amp; 0 &amp; 0 &amp; 0 &amp; \\sqrt{10} &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 2 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 2 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; \\sqrt{10}\\end{array}\\right]$  Out[33]:  $\\displaystyle \\left[\\begin{matrix}\\sqrt{10} &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 2 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 2 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; \\sqrt{10}\\end{matrix}\\right]$  In\u00a0[34]: Copied! <pre>w_T = S_to_T @ w_S\nw_T\n</pre> w_T = S_to_T @ w_S w_T Out[34]:  $\\displaystyle \\left[\\begin{array}{c}\\sqrt{10}\\\\4\\\\2\\\\\\sqrt{10}\\end{array}\\right]$"},{"location":"tutorials/tut07/#tutorial-07-ay2425-sem-1","title":"Tutorial 07 (AY24/25 Sem 1)\u00b6","text":""},{"location":"tutorials/tut07/#question-1","title":"Question 1\u00b6","text":""},{"location":"tutorials/tut07/#a","title":"(a)\u00b6","text":"<p>Let $a_1 x_1 + a_2 x_2 + \\cdots + a_n x_n = b$ be a linear equation. Express this linear system as $\\mathbf{a} \\cdot \\mathbf{x} = b$ for some (column) vectors $\\mathbf{a}$ and $\\mathbf{x}$.</p>"},{"location":"tutorials/tut07/#b","title":"(b)\u00b6","text":"<p>Find the solution set of the linear system $$\\begin{cases} x_1 &amp;+&amp; 3x_2 &amp;-&amp; 2x_3 &amp;&amp;  &amp;=&amp; 0 \\\\ 2x_1 &amp;+&amp; 6x_2 &amp;-&amp; 5x_3 &amp;-&amp; 2x_4 &amp;=&amp; 0  \\\\ &amp;&amp; &amp;&amp; 5x_3 &amp;+&amp; 10x_4 &amp;=&amp; 0   \\end{cases}$$</p>"},{"location":"tutorials/tut07/#c","title":"(c)\u00b6","text":"<p>Find a nonzero vector $\\mathbf{v} \\in \\mathbb{R}^4$ such that $\\mathbf{a}_1 \\cdot \\mathbf{v} = 0$, $\\mathbf{a}_2 \\cdot \\mathbf{v} = 0$, and $\\mathbf{a}_3 \\cdot \\mathbf{v} = 0$, where $$\\mathbf{a}_1 = \\begin{pmatrix} 1 \\\\ 3 \\\\ -2 \\\\ 0 \\end{pmatrix}, \\quad \\mathbf{a}_2 = \\begin{pmatrix} 2 \\\\ 6 \\\\ -5 \\\\ -2 \\end{pmatrix}, \\quad \\mathbf{a}_3 = \\begin{pmatrix} 0 \\\\ 0 \\\\ 5 \\\\ 10 \\end{pmatrix}$$</p>"},{"location":"tutorials/tut07/#question-3","title":"Question 3\u00b6","text":"<p>Let $\\mathbf{v}_1 = \\begin{pmatrix} 1 \\\\ 2  \\\\ \\ -1 \\end{pmatrix}$, $\\mathbf{v}_2 = \\begin{pmatrix} 1  \\\\ 0 \\\\ 1 \\end{pmatrix}$, and $\\mathbf{V} = \\begin{pmatrix} \\mathbf{v}_1 &amp; \\mathbf{v}_2 \\end{pmatrix}$.</p>"},{"location":"tutorials/tut07/#a","title":"(a)\u00b6","text":"<p>Compute $\\mathbf{v}_1 \\cdot \\mathbf{v}_1$, $\\mathbf{v}_1 \\cdot \\mathbf{v}_2$, $\\mathbf{v}_2 \\cdot \\mathbf{v}_1$ and $\\mathbf{v}_2 \\cdot \\mathbf{v}_2$.</p>"},{"location":"tutorials/tut07/#b","title":"(b)\u00b6","text":"<p>Compute $\\mathbf{V}^T \\mathbf{V}$. What do the entries of $\\mathbf{V}^T \\mathbf{V}$ represent?</p>"},{"location":"tutorials/tut07/#question-4","title":"Question 4\u00b6","text":"<p>Let $W$ be a subspace of $\\mathbb{R}^n$. The orthogonal complement of $W$, denoted as $W^{\\perp}$, is defined to be $$W^{\\perp} := \\{ \\mathbf{v} \\in \\mathbb{R}^n : \\mathbf{v} \\cdot \\mathbf{w} = 0 \\text{ for all } \\mathbf{w} \\in W \\}$$</p> <p>Let $\\mathbf{w}_1 = \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1 \\end{pmatrix}$, $\\mathbf{w}_2 = \\begin{pmatrix} 1 \\\\ 2 \\\\ -1 \\\\ -2 \\\\ 0 \\end{pmatrix}$, and $\\mathbf{w}_3 = \\begin{pmatrix} 1 \\\\ -1 \\\\ 1 \\\\ -1 \\\\ 0 \\end{pmatrix}$, and $W = \\text{span}\\{\\mathbf{w}_1, \\mathbf{w}_2, \\mathbf{w}_3\\}$.</p>"},{"location":"tutorials/tut07/#a","title":"(a)\u00b6","text":"<p>Show that $S = \\{\\mathbf{w}_1, \\mathbf{w}_2, \\mathbf{w}_3\\}$ is linearly independent.</p>"},{"location":"tutorials/tut07/#b","title":"(b)\u00b6","text":"<p>Show that $S$ is orthogonal.</p>"},{"location":"tutorials/tut07/#c","title":"(c)\u00b6","text":"<p>Show that $W^{\\perp}$ is a subspace of $\\mathbb{R}^5$ by showing that it is a span of a set. What is the dimension? (Hint: See Question 1.)</p>"},{"location":"tutorials/tut07/#d","title":"(d)\u00b6","text":"<p>Obtain an orthonormal set $T$ by normalizing $\\mathbf{w}_1$, $\\mathbf{w}_2$, $\\mathbf{w}_3$.</p>"},{"location":"tutorials/tut07/#e","title":"(e)\u00b6","text":"<p>Let $\\mathbf{v} = \\begin{pmatrix} 2 \\\\ 0 \\\\ 1 \\\\ 1 \\\\ -1 \\end{pmatrix}$. Find the projection of $\\mathbf{v}$ onto $W$.</p>"},{"location":"tutorials/tut07/#f","title":"(f)\u00b6","text":"<p>Let $\\mathbf{v}_W$ be the projection of $\\mathbf{v}$ onto $W$. Show that $\\mathbf{v} - \\mathbf{v}_W$ is in $W^{\\perp}$.</p>"},{"location":"tutorials/tut07/#question-5","title":"Question 5\u00b6","text":"<p>Let $S = \\{\\mathbf{u}_1, \\mathbf{u}_2, \\mathbf{u}_3, \\mathbf{u}_4\\}$ where $$\\mathbf{u}_1 = \\begin{pmatrix} 1 \\\\ 2 \\\\ 2 \\\\ -1 \\end{pmatrix}, \\quad \\mathbf{u}_2 = \\begin{pmatrix} 1 \\\\ 1 \\\\ -1 \\\\ 1 \\end{pmatrix}, \\quad \\mathbf{u}_3 = \\begin{pmatrix} -1 \\\\ 1 \\\\ -1 \\\\ -1 \\end{pmatrix}, \\quad \\mathbf{u}_4 = \\begin{pmatrix} -2 \\\\ 1 \\\\ 1 \\\\ 2 \\end{pmatrix}$$</p>"},{"location":"tutorials/tut07/#a","title":"(a)\u00b6","text":"<p>Check that $S$ is an orthogonal basis for $\\mathbb{R}^4$.</p>"},{"location":"tutorials/tut07/#b","title":"(b)\u00b6","text":"<p>Is it possible to find a nonzero vector $\\mathbf{w}$ in $\\mathbb{R}^4$ such that $S \\cup {\\mathbf{w}}$ is an orthogonal set?</p>"},{"location":"tutorials/tut07/#c","title":"(c)\u00b6","text":"<p>Obtain an orthonormal set $T$ by normalizing $\\mathbf{u}_1$, $\\mathbf{u}_2$, $\\mathbf{u}_3$, $\\mathbf{u}_4$.</p>"},{"location":"tutorials/tut07/#d","title":"(d)\u00b6","text":"<p>Let $\\mathbf{v} = \\begin{pmatrix} 0 \\\\ 1 \\\\ 2 \\\\ 3 \\end{pmatrix}$. Find $[\\mathbf{v}]_S$ and $[\\mathbf{v}]_T$.</p>"},{"location":"tutorials/tut07/#e","title":"(e)\u00b6","text":"<p>Suppose $\\mathbf{w}$ is a vector in $\\mathbb{R}^4$ such that $[\\mathbf{w}]_S = \\begin{pmatrix} 1 \\\\ 2 \\\\ 1 \\\\ 1 \\end{pmatrix}$. Find $[\\mathbf{w}]_T$.</p>"},{"location":"tutorials/tut08/","title":"Tutorial 8","text":"In\u00a0[1]: Copied! <pre># Required imports\nimport sympy as sym\nfrom ma1522 import Matrix\n</pre> # Required imports import sympy as sym from ma1522 import Matrix In\u00a0[2]: Copied! <pre>U = Matrix.from_str(\"1 1 1 1; 1 -1 1 0; 1 1 -1 -1; 1 2 0 1\").T\nU\n</pre> U = Matrix.from_str(\"1 1 1 1; 1 -1 1 0; 1 1 -1 -1; 1 2 0 1\").T U Out[2]:  $\\displaystyle \\left[\\begin{array}{cccc}1 &amp; 1 &amp; 1 &amp; 1\\\\1 &amp; -1 &amp; 1 &amp; 2\\\\1 &amp; 1 &amp; -1 &amp; 0\\\\1 &amp; 0 &amp; -1 &amp; 1\\end{array}\\right]$  In\u00a0[3]: Copied! <pre>U.gram_schmidt(factor=True, verbosity=1)\n</pre> U.gram_schmidt(factor=True, verbosity=1)  $\\displaystyle v_1 = \\left[\\begin{array}{c}1\\\\1\\\\1\\\\1\\end{array}\\right]$   $\\displaystyle v_2 = \\left[\\begin{array}{c}1\\\\-1\\\\1\\\\0\\end{array}\\right]- \\left(\\frac{1}{4}\\right) \\left[\\begin{array}{c}1\\\\1\\\\1\\\\1\\end{array}\\right] = \\left(\\frac{1}{4}\\right) \\left[\\begin{matrix}3\\\\-5\\\\3\\\\-1\\end{matrix}\\right]$   $\\displaystyle v_3 = \\left[\\begin{array}{c}1\\\\1\\\\-1\\\\-1\\end{array}\\right]- \\left(\\frac{0}{4}\\right) \\left[\\begin{array}{c}1\\\\1\\\\1\\\\1\\end{array}\\right]- \\left(\\frac{-1}{\\frac{11}{4}}\\right) \\left[\\begin{array}{c}\\frac{3}{4}\\\\- \\frac{5}{4}\\\\\\frac{3}{4}\\\\- \\frac{1}{4}\\end{array}\\right] = \\left(\\frac{2}{11}\\right) \\left[\\begin{matrix}7\\\\3\\\\-4\\\\-6\\end{matrix}\\right]$   $\\displaystyle v_4 = \\left[\\begin{array}{c}1\\\\2\\\\0\\\\1\\end{array}\\right]- \\left(\\frac{4}{4}\\right) \\left[\\begin{array}{c}1\\\\1\\\\1\\\\1\\end{array}\\right]- \\left(\\frac{-2}{\\frac{11}{4}}\\right) \\left[\\begin{array}{c}\\frac{3}{4}\\\\- \\frac{5}{4}\\\\\\frac{3}{4}\\\\- \\frac{1}{4}\\end{array}\\right]- \\left(\\frac{\\frac{14}{11}}{\\frac{40}{11}}\\right) \\left[\\begin{array}{c}\\frac{14}{11}\\\\\\frac{6}{11}\\\\- \\frac{8}{11}\\\\- \\frac{12}{11}\\end{array}\\right] = \\left(\\frac{1}{10}\\right) \\left[\\begin{matrix}1\\\\-1\\\\-2\\\\2\\end{matrix}\\right]$  Out[3]:  $\\left[\\begin{array}{cccc}1 &amp; 3 &amp; 7 &amp; 1\\\\1 &amp; -5 &amp; 3 &amp; -1\\\\1 &amp; 3 &amp; -4 &amp; -2\\\\1 &amp; -1 &amp; -6 &amp; 2\\end{array}\\right]\\left[\\begin{array}{cccc}\\frac{1}{2} &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; \\frac{\\sqrt{11}}{22} &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; \\frac{1}{\\sqrt{110}} &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; \\frac{1}{\\sqrt{10}}\\end{array}\\right]$  In\u00a0[4]: Copied! <pre>U = Matrix.from_str(\"1 2 2 1; 1 2 1 0; 1 0 1 0; 1 0 2 1\").T\nU\n</pre> U = Matrix.from_str(\"1 2 2 1; 1 2 1 0; 1 0 1 0; 1 0 2 1\").T U Out[4]:  $\\displaystyle \\left[\\begin{array}{cccc}1 &amp; 1 &amp; 1 &amp; 1\\\\2 &amp; 2 &amp; 0 &amp; 0\\\\2 &amp; 1 &amp; 1 &amp; 2\\\\1 &amp; 0 &amp; 0 &amp; 1\\end{array}\\right]$  In\u00a0[5]: Copied! <pre>U.gram_schmidt(factor=True, verbosity=1) # UserWarning raised because a zero vector is found\n</pre> U.gram_schmidt(factor=True, verbosity=1) # UserWarning raised because a zero vector is found  $\\displaystyle v_1 = \\left[\\begin{array}{c}1\\\\2\\\\2\\\\1\\end{array}\\right]$   $\\displaystyle v_2 = \\left[\\begin{array}{c}1\\\\2\\\\1\\\\0\\end{array}\\right]- \\left(\\frac{7}{10}\\right) \\left[\\begin{array}{c}1\\\\2\\\\2\\\\1\\end{array}\\right] = \\left(\\frac{1}{10}\\right) \\left[\\begin{matrix}3\\\\6\\\\-4\\\\-7\\end{matrix}\\right]$   $\\displaystyle v_3 = \\left[\\begin{array}{c}1\\\\0\\\\1\\\\0\\end{array}\\right]- \\left(\\frac{3}{10}\\right) \\left[\\begin{array}{c}1\\\\2\\\\2\\\\1\\end{array}\\right]- \\left(\\frac{- \\frac{1}{10}}{\\frac{11}{10}}\\right) \\left[\\begin{array}{c}\\frac{3}{10}\\\\\\frac{3}{5}\\\\- \\frac{2}{5}\\\\- \\frac{7}{10}\\end{array}\\right] = \\left(\\frac{2}{11}\\right) \\left[\\begin{matrix}4\\\\-3\\\\2\\\\-2\\end{matrix}\\right]$   $\\displaystyle v_4 = \\left[\\begin{array}{c}1\\\\0\\\\2\\\\1\\end{array}\\right]- \\left(\\frac{6}{10}\\right) \\left[\\begin{array}{c}1\\\\2\\\\2\\\\1\\end{array}\\right]- \\left(\\frac{- \\frac{6}{5}}{\\frac{11}{10}}\\right) \\left[\\begin{array}{c}\\frac{3}{10}\\\\\\frac{3}{5}\\\\- \\frac{2}{5}\\\\- \\frac{7}{10}\\end{array}\\right]- \\left(\\frac{\\frac{12}{11}}{\\frac{12}{11}}\\right) \\left[\\begin{array}{c}\\frac{8}{11}\\\\- \\frac{6}{11}\\\\\\frac{4}{11}\\\\- \\frac{4}{11}\\end{array}\\right] = 0 \\left[\\begin{matrix}0\\\\0\\\\0\\\\0\\end{matrix}\\right]$  <pre>/tmp/ipykernel_2427/1175356544.py:1: UserWarning: Vectors are linearly dependent. Note that there is no QR factorisation\n  U.gram_schmidt(factor=True, verbosity=1) # UserWarning raised because a zero vector is found\n</pre> Out[5]:  $\\left[\\begin{array}{cccc}1 &amp; 3 &amp; 4 &amp; 0\\\\2 &amp; 6 &amp; -3 &amp; 0\\\\2 &amp; -4 &amp; 2 &amp; 0\\\\1 &amp; -7 &amp; -2 &amp; 0\\end{array}\\right]\\left[\\begin{array}{cccc}\\frac{1}{\\sqrt{10}} &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; \\frac{1}{\\sqrt{110}} &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; \\frac{1}{\\sqrt{33}} &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right]$  In\u00a0[6]: Copied! <pre>A = Matrix.from_str(\"0 1 1 0; 1 -1 1 -1; 1 0 1 0; 1 1 1 1\")\nb = Matrix.from_str(\"6; 3; -1; 1\")\nA, b\n</pre> A = Matrix.from_str(\"0 1 1 0; 1 -1 1 -1; 1 0 1 0; 1 1 1 1\") b = Matrix.from_str(\"6; 3; -1; 1\") A, b Out[6]:  $\\displaystyle \\left( \\left[\\begin{array}{cccc}0 &amp; 1 &amp; 1 &amp; 0\\\\1 &amp; -1 &amp; 1 &amp; -1\\\\1 &amp; 0 &amp; 1 &amp; 0\\\\1 &amp; 1 &amp; 1 &amp; 1\\end{array}\\right], \\  \\left[\\begin{array}{c}6\\\\3\\\\-1\\\\1\\end{array}\\right]\\right)$  In\u00a0[7]: Copied! <pre># Check if the system is inconsistent\nb.is_subspace_of(A, verbosity=2)\n</pre> # Check if the system is inconsistent b.is_subspace_of(A, verbosity=2) <pre>Check if span(self) is subspace of span(other)\n\nBefore RREF: [other | self]\n</pre>  $\\displaystyle \\left[\\begin{array}{cccc|c}0 &amp; 1 &amp; 1 &amp; 0 &amp; 6\\\\1 &amp; -1 &amp; 1 &amp; -1 &amp; 3\\\\1 &amp; 0 &amp; 1 &amp; 0 &amp; -1\\\\1 &amp; 1 &amp; 1 &amp; 1 &amp; 1\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cccc|c}1 &amp; 0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; -1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 1\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 2, 4)\\right\\}$  <pre>Span(self) is not a subspace of span(other).\n\n</pre> Out[7]: <pre>False</pre> In\u00a0[8]: Copied! <pre>sol = A.solve_least_squares(b, verbosity=2)\nsol\n</pre> sol = A.solve_least_squares(b, verbosity=2) sol <pre>Before RREF: [self.T @ self | self.T @ rhs]\n</pre>  $\\displaystyle \\left[\\begin{array}{cccc|c}3 &amp; 0 &amp; 3 &amp; 0 &amp; 3\\\\0 &amp; 3 &amp; 1 &amp; 2 &amp; 4\\\\3 &amp; 1 &amp; 4 &amp; 0 &amp; 9\\\\0 &amp; 2 &amp; 0 &amp; 2 &amp; -2\\end{array}\\right]$  <pre>\nAfter RREF\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cccc|c}1 &amp; 0 &amp; 0 &amp; 1 &amp; -6\\\\0 &amp; 1 &amp; 0 &amp; 1 &amp; -1\\\\0 &amp; 0 &amp; 1 &amp; -1 &amp; 7\\\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 2)\\right\\}$  Out[8]:  $\\displaystyle \\left[\\begin{array}{c}- z - 6\\\\- z - 1\\\\z + 7\\\\z\\end{array}\\right]$  In\u00a0[9]: Copied! <pre># separate the solution into particular and general solution\nsol.sep_part_gen() \n</pre> # separate the solution into particular and general solution sol.sep_part_gen()  Out[9]:  $\\left(\\left[\\begin{array}{c}-6\\\\-1\\\\7\\\\0\\end{array}\\right] + \\left[\\begin{array}{c}- z\\\\- z\\\\z\\\\z\\end{array}\\right]\\right)$  In\u00a0[10]: Copied! <pre>proj = A @ sol\nproj\n</pre> proj = A @ sol proj Out[10]:  $\\displaystyle \\left[\\begin{array}{c}6\\\\2\\\\1\\\\0\\end{array}\\right]$  In\u00a0[11]: Copied! <pre>A = Matrix.from_str(\"1 0.01; 1 0.012; 1 0.015; 1 0.02\", aug_pos=1)\n# scientific notation supported using E\nb = Matrix.from_str(\"2.75E-4; 3.31E-4; 3.92E-4; 4.95E-4\")\nA, b\n</pre> A = Matrix.from_str(\"1 0.01; 1 0.012; 1 0.015; 1 0.02\", aug_pos=1) # scientific notation supported using E b = Matrix.from_str(\"2.75E-4; 3.31E-4; 3.92E-4; 4.95E-4\") A, b Out[11]:  $\\displaystyle \\left( \\left[\\begin{array}{cc}1 &amp; 0.01\\\\1 &amp; 0.012\\\\1 &amp; 0.015\\\\1 &amp; 0.02\\end{array}\\right], \\  \\left[\\begin{array}{c}0.000275\\\\0.000331\\\\0.000392\\\\0.000495\\end{array}\\right]\\right)$  In\u00a0[12]: Copied! <pre># Observe that numbers are represented as decimals\n# This is bad, because it means that SymPy may not be using \n# full precision arithmetic. Use the `simplify` method to convert\n# the numbers to symbolic fractions.\nA.simplify(tolerance=1e-10)\nb.simplify(tolerance=1e-10)\n\nA, b\n</pre> # Observe that numbers are represented as decimals # This is bad, because it means that SymPy may not be using  # full precision arithmetic. Use the `simplify` method to convert # the numbers to symbolic fractions. A.simplify(tolerance=1e-10) b.simplify(tolerance=1e-10)  A, b Out[12]:  $\\displaystyle \\left( \\left[\\begin{array}{cc}1 &amp; \\frac{1}{100}\\\\1 &amp; \\frac{3}{250}\\\\1 &amp; \\frac{3}{200}\\\\1 &amp; \\frac{1}{50}\\end{array}\\right], \\  \\left[\\begin{array}{c}\\frac{11}{40000}\\\\\\frac{331}{1000000}\\\\\\frac{49}{125000}\\\\\\frac{99}{200000}\\end{array}\\right]\\right)$  In\u00a0[13]: Copied! <pre>b.is_subspace_of(A, verbosity=2)\n</pre> b.is_subspace_of(A, verbosity=2) <pre>Check if span(self) is subspace of span(other)\n\nBefore RREF: [other | self]\n</pre>  $\\displaystyle \\left[\\begin{array}{cc|c}1 &amp; \\frac{1}{100} &amp; \\frac{11}{40000}\\\\1 &amp; \\frac{3}{250} &amp; \\frac{331}{1000000}\\\\1 &amp; \\frac{3}{200} &amp; \\frac{49}{125000}\\\\1 &amp; \\frac{1}{50} &amp; \\frac{99}{200000}\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cc|c}1 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 1\\\\0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 2)\\right\\}$  <pre>Span(self) is not a subspace of span(other).\n\n</pre> Out[13]: <pre>False</pre> In\u00a0[14]: Copied! <pre>sol = A.solve_least_squares(b, verbosity=2)\nsol\n</pre> sol = A.solve_least_squares(b, verbosity=2) sol <pre>self.T @ self is invertible. The lest squares solution is unique.\n</pre>  $\\displaystyle \\mathbf{x} = \\left(\\mathbf{A}^\\top \\mathbf{A}\\right)^{-1} \\mathbf{A}^\\top \\mathbf{b}$   $\\displaystyle \\left[\\begin{array}{c}\\frac{14803}{227000000}\\\\\\frac{4907}{227000}\\end{array}\\right]$  Out[14]:  $\\displaystyle \\left[\\begin{array}{c}\\frac{14803}{227000000}\\\\\\frac{4907}{227000}\\end{array}\\right]$  In\u00a0[15]: Copied! <pre># Unlike MATLAB, we can get the exact solution with rational numbers\n# However, as it is unwieldy and MA1522 does not require exact solution,\n# we can use `evalf(n)` to evaluate the solution to `n` significant values.\nsol.evalf(4) \n</pre> # Unlike MATLAB, we can get the exact solution with rational numbers # However, as it is unwieldy and MA1522 does not require exact solution, # we can use `evalf(n)` to evaluate the solution to `n` significant values. sol.evalf(4)  Out[15]:  $\\displaystyle \\left[\\begin{matrix}6.521 \\cdot 10^{-5}\\\\0.02162\\end{matrix}\\right]$  In\u00a0[16]: Copied! <pre>x = Matrix.from_str(\"4 4.5 5 5.5 6 6.5 7 8 8.5\").T\ny = Matrix.from_str(\"0.8651 0.4828 2.590 -4.389 -7.858 3.103 7.456 0.0965 4.326\").T\n\nx, y\n</pre> x = Matrix.from_str(\"4 4.5 5 5.5 6 6.5 7 8 8.5\").T y = Matrix.from_str(\"0.8651 0.4828 2.590 -4.389 -7.858 3.103 7.456 0.0965 4.326\").T  x, y Out[16]:  $\\displaystyle \\left( \\left[\\begin{array}{c}4\\\\4.5\\\\5\\\\5.5\\\\6\\\\6.5\\\\7\\\\8\\\\8.5\\end{array}\\right], \\  \\left[\\begin{array}{c}0.8651\\\\0.4828\\\\2.59\\\\-4.389\\\\-7.858\\\\3.103\\\\7.456\\\\0.0965\\\\4.326\\end{array}\\right]\\right)$  In\u00a0[17]: Copied! <pre># Similar to the previous example, we can use `simplify` to \n# convert the numbers to symbolic fractions.\nx.simplify(tolerance=1e-10)\ny.simplify(tolerance=1e-10)\n\nx, y\n</pre> # Similar to the previous example, we can use `simplify` to  # convert the numbers to symbolic fractions. x.simplify(tolerance=1e-10) y.simplify(tolerance=1e-10)  x, y Out[17]:  $\\displaystyle \\left( \\left[\\begin{array}{c}4\\\\\\frac{9}{2}\\\\5\\\\\\frac{11}{2}\\\\6\\\\\\frac{13}{2}\\\\7\\\\8\\\\\\frac{17}{2}\\end{array}\\right], \\  \\left[\\begin{array}{c}\\frac{8651}{10000}\\\\\\frac{1207}{2500}\\\\\\frac{259}{100}\\\\- \\frac{4389}{1000}\\\\- \\frac{3929}{500}\\\\\\frac{3103}{1000}\\\\\\frac{932}{125}\\\\\\frac{193}{2000}\\\\\\frac{2163}{500}\\end{array}\\right]\\right)$  In\u00a0[18]: Copied! <pre># Create the Vandermonde matrix\nN = Matrix.create_vander(num_rows=x.rows, num_cols=5)\nN\n</pre> # Create the Vandermonde matrix N = Matrix.create_vander(num_rows=x.rows, num_cols=5) N Out[18]:  $\\displaystyle \\left[\\begin{array}{ccccc}1 &amp; x_{1} &amp; x_{1}^{2} &amp; x_{1}^{3} &amp; x_{1}^{4}\\\\1 &amp; x_{2} &amp; x_{2}^{2} &amp; x_{2}^{3} &amp; x_{2}^{4}\\\\1 &amp; x_{3} &amp; x_{3}^{2} &amp; x_{3}^{3} &amp; x_{3}^{4}\\\\1 &amp; x_{4} &amp; x_{4}^{2} &amp; x_{4}^{3} &amp; x_{4}^{4}\\\\1 &amp; x_{5} &amp; x_{5}^{2} &amp; x_{5}^{3} &amp; x_{5}^{4}\\\\1 &amp; x_{6} &amp; x_{6}^{2} &amp; x_{6}^{3} &amp; x_{6}^{4}\\\\1 &amp; x_{7} &amp; x_{7}^{2} &amp; x_{7}^{3} &amp; x_{7}^{4}\\\\1 &amp; x_{8} &amp; x_{8}^{2} &amp; x_{8}^{3} &amp; x_{8}^{4}\\\\1 &amp; x_{9} &amp; x_{9}^{2} &amp; x_{9}^{3} &amp; x_{9}^{4}\\end{array}\\right]$  In\u00a0[19]: Copied! <pre># To substitute the values of x into the Vandermonde matrix\nN = N.apply_vander(x)\nN\n</pre> # To substitute the values of x into the Vandermonde matrix N = N.apply_vander(x) N Out[19]:  $\\displaystyle \\left[\\begin{array}{ccccc}1 &amp; 4 &amp; 16 &amp; 64 &amp; 256\\\\1 &amp; \\frac{9}{2} &amp; \\frac{81}{4} &amp; \\frac{729}{8} &amp; \\frac{6561}{16}\\\\1 &amp; 5 &amp; 25 &amp; 125 &amp; 625\\\\1 &amp; \\frac{11}{2} &amp; \\frac{121}{4} &amp; \\frac{1331}{8} &amp; \\frac{14641}{16}\\\\1 &amp; 6 &amp; 36 &amp; 216 &amp; 1296\\\\1 &amp; \\frac{13}{2} &amp; \\frac{169}{4} &amp; \\frac{2197}{8} &amp; \\frac{28561}{16}\\\\1 &amp; 7 &amp; 49 &amp; 343 &amp; 2401\\\\1 &amp; 8 &amp; 64 &amp; 512 &amp; 4096\\\\1 &amp; \\frac{17}{2} &amp; \\frac{289}{4} &amp; \\frac{4913}{8} &amp; \\frac{83521}{16}\\end{array}\\right]$  In\u00a0[20]: Copied! <pre>sol = N.solve_least_squares(y, verbosity=2)\nsol\n</pre> sol = N.solve_least_squares(y, verbosity=2) sol <pre>self.T @ self is invertible. The lest squares solution is unique.\n</pre>  $\\displaystyle \\mathbf{x} = \\left(\\mathbf{A}^\\top \\mathbf{A}\\right)^{-1} \\mathbf{A}^\\top \\mathbf{b}$   $\\displaystyle \\left[\\begin{array}{c}- \\frac{43029219289}{210853500}\\\\\\frac{535177649129}{3162802500}\\\\- \\frac{8061301133}{162195000}\\\\\\frac{972997028}{158140125}\\\\- \\frac{47784941}{175711250}\\end{array}\\right]$  Out[20]:  $\\displaystyle \\left[\\begin{array}{c}- \\frac{43029219289}{210853500}\\\\\\frac{535177649129}{3162802500}\\\\- \\frac{8061301133}{162195000}\\\\\\frac{972997028}{158140125}\\\\- \\frac{47784941}{175711250}\\end{array}\\right]$  In\u00a0[21]: Copied! <pre>sol.evalf(8)  # Evaluate the solution to 8 significant figures\n</pre> sol.evalf(8)  # Evaluate the solution to 8 significant figures Out[21]:  $\\displaystyle \\left[\\begin{matrix}-204.07164\\\\169.20995\\\\-49.701292\\\\6.1527524\\\\-0.27195152\\end{matrix}\\right]$  In\u00a0[22]: Copied! <pre>A = Matrix.from_str(\"1 1 0; 1 1 0; 1 1 1; 0 1 1\")\nA\n</pre> A = Matrix.from_str(\"1 1 0; 1 1 0; 1 1 1; 0 1 1\") A Out[22]:  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 1 &amp; 0\\\\1 &amp; 1 &amp; 0\\\\1 &amp; 1 &amp; 1\\\\0 &amp; 1 &amp; 1\\end{array}\\right]$  In\u00a0[23]: Copied! <pre>A.gram_schmidt(factor=True, verbosity=1)\n</pre> A.gram_schmidt(factor=True, verbosity=1)  $\\displaystyle v_1 = \\left[\\begin{array}{c}1\\\\1\\\\1\\\\0\\end{array}\\right]$   $\\displaystyle v_2 = \\left[\\begin{array}{c}1\\\\1\\\\1\\\\1\\end{array}\\right]- \\left(\\frac{3}{3}\\right) \\left[\\begin{array}{c}1\\\\1\\\\1\\\\0\\end{array}\\right] = 1 \\left[\\begin{matrix}0\\\\0\\\\0\\\\1\\end{matrix}\\right]$   $\\displaystyle v_3 = \\left[\\begin{array}{c}0\\\\0\\\\1\\\\1\\end{array}\\right]- \\left(\\frac{1}{3}\\right) \\left[\\begin{array}{c}1\\\\1\\\\1\\\\0\\end{array}\\right]- \\left(\\frac{1}{1}\\right) \\left[\\begin{array}{c}0\\\\0\\\\0\\\\1\\end{array}\\right] = \\left(\\frac{1}{3}\\right) \\left[\\begin{matrix}-1\\\\-1\\\\2\\\\0\\end{matrix}\\right]$  Out[23]:  $\\left[\\begin{array}{ccc}\\frac{1}{3} &amp; 0 &amp; - \\frac{1}{6}\\\\\\frac{1}{3} &amp; 0 &amp; - \\frac{1}{6}\\\\\\frac{1}{3} &amp; 0 &amp; \\frac{1}{3}\\\\0 &amp; 1 &amp; 0\\end{array}\\right]\\left[\\begin{array}{ccc}\\sqrt{3} &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; \\sqrt{6}\\end{array}\\right]$  In\u00a0[24]: Copied! <pre>QR = A.QRdecomposition(verbosity=1)\nQR\n</pre> QR = A.QRdecomposition(verbosity=1) QR <pre>Finding orthogonal basis via Gram-Schmidt process:\n</pre>  $\\displaystyle v_1 = \\left[\\begin{array}{c}1\\\\1\\\\1\\\\0\\end{array}\\right]$   $\\displaystyle v_2 = \\left[\\begin{array}{c}1\\\\1\\\\1\\\\1\\end{array}\\right]- \\left(\\frac{3}{3}\\right) \\left[\\begin{array}{c}1\\\\1\\\\1\\\\0\\end{array}\\right] = \\left[\\begin{array}{c}0\\\\0\\\\0\\\\1\\end{array}\\right]$   $\\displaystyle v_3 = \\left[\\begin{array}{c}0\\\\0\\\\1\\\\1\\end{array}\\right]- \\left(\\frac{1}{3}\\right) \\left[\\begin{array}{c}1\\\\1\\\\1\\\\0\\end{array}\\right]- \\left(\\frac{1}{1}\\right) \\left[\\begin{array}{c}0\\\\0\\\\0\\\\1\\end{array}\\right] = \\left[\\begin{array}{c}- \\frac{1}{3}\\\\- \\frac{1}{3}\\\\\\frac{2}{3}\\\\0\\end{array}\\right]$  <pre>Q matrix:\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc}\\frac{\\sqrt{3}}{3} &amp; 0 &amp; - \\frac{\\sqrt{6}}{6}\\\\\\frac{\\sqrt{3}}{3} &amp; 0 &amp; - \\frac{\\sqrt{6}}{6}\\\\\\frac{\\sqrt{3}}{3} &amp; 0 &amp; \\frac{\\sqrt{6}}{3}\\\\0 &amp; 1 &amp; 0\\end{array}\\right]$  <pre>R matrix: Q.T @ self\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc}\\sqrt{3} &amp; \\sqrt{3} &amp; \\frac{\\sqrt{3}}{3}\\\\0 &amp; 1 &amp; 1\\\\0 &amp; 0 &amp; \\frac{\\sqrt{6}}{3}\\end{array}\\right]$  Out[24]:  $\\left[\\begin{array}{ccc}\\frac{\\sqrt{3}}{3} &amp; 0 &amp; - \\frac{\\sqrt{6}}{6}\\\\\\frac{\\sqrt{3}}{3} &amp; 0 &amp; - \\frac{\\sqrt{6}}{6}\\\\\\frac{\\sqrt{3}}{3} &amp; 0 &amp; \\frac{\\sqrt{6}}{3}\\\\0 &amp; 1 &amp; 0\\end{array}\\right]\\left[\\begin{array}{ccc}\\sqrt{3} &amp; \\sqrt{3} &amp; \\frac{\\sqrt{3}}{3}\\\\0 &amp; 1 &amp; 1\\\\0 &amp; 0 &amp; \\frac{\\sqrt{6}}{3}\\end{array}\\right]$  In\u00a0[25]: Copied! <pre>b = Matrix.from_str(\"1; 1; 0; 0\")\nb\n</pre> b = Matrix.from_str(\"1; 1; 0; 0\") b Out[25]:  $\\displaystyle \\left[\\begin{array}{c}1\\\\1\\\\0\\\\0\\end{array}\\right]$  In\u00a0[26]: Copied! <pre>Q, R = QR.Q, QR.R\n\nsol = R.inverse() @ Q.T @ b\nsol\n</pre> Q, R = QR.Q, QR.R  sol = R.inverse() @ Q.T @ b sol Out[26]:  $\\displaystyle \\left[\\begin{array}{c}0\\\\1\\\\-1\\end{array}\\right]$  In\u00a0[27]: Copied! <pre># Or brute force\nsol = A.solve_least_squares(b, verbosity=2)\nsol\n</pre> # Or brute force sol = A.solve_least_squares(b, verbosity=2) sol <pre>self.T @ self is invertible. The lest squares solution is unique.\n</pre>  $\\displaystyle \\mathbf{x} = \\left(\\mathbf{A}^\\top \\mathbf{A}\\right)^{-1} \\mathbf{A}^\\top \\mathbf{b}$   $\\displaystyle \\left[\\begin{array}{c}0\\\\1\\\\-1\\end{array}\\right]$  Out[27]:  $\\displaystyle \\left[\\begin{array}{c}0\\\\1\\\\-1\\end{array}\\right]$"},{"location":"tutorials/tut08/#tutorial-08-ay2425-sem-1","title":"Tutorial 08 (AY24/25 Sem 1)\u00b6","text":""},{"location":"tutorials/tut08/#question-1","title":"Question 1\u00b6","text":"<p>Apply Gram-Schmidt Process to convert</p>"},{"location":"tutorials/tut08/#a","title":"(a)\u00b6","text":"<p>$\\left\\{ \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\\\ 1 \\end{pmatrix}, \\begin{pmatrix} 1 \\\\ -1 \\\\ 1 \\\\ 0 \\end{pmatrix}, \\begin{pmatrix} 1 \\\\ 1 \\\\ -1 \\\\ -1 \\end{pmatrix}, \\begin{pmatrix} 1 \\\\ 2 \\\\ 0 \\\\ 1 \\end{pmatrix} \\right\\}$ into an orthonormal basis for $\\mathbb{R}^4$.</p>"},{"location":"tutorials/tut08/#b","title":"(b)\u00b6","text":"<p>$\\left\\{ \\begin{pmatrix} 1 \\\\ 2 \\\\ 2 \\\\ 1 \\end{pmatrix}, \\begin{pmatrix} 1 \\\\ 2 \\\\ 1 \\\\ 0 \\end{pmatrix}, \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\\\ 0 \\end{pmatrix}, \\begin{pmatrix} 1 \\\\ 0 \\\\ 2 \\\\ 1 \\end{pmatrix} \\right\\}$ into an orthonormal set. Is the set obtained an orthonormal basis? Why?</p>"},{"location":"tutorials/tut08/#question-2","title":"Question 2\u00b6","text":"<p>Let $\\mathbf{A} = \\begin{pmatrix} 0 &amp; 1 &amp; 1 &amp; 0 \\\\ 1 &amp; -1 &amp; 1 &amp; -1 \\\\ 1 &amp; 0 &amp; 1 &amp; 0 \\\\ 1 &amp; 1 &amp; 1 &amp; 1 \\end{pmatrix}$ and $\\mathbf{b} = \\begin{pmatrix} 6 \\\\ 3 \\\\ -1 \\\\ 1 \\end{pmatrix}$.</p>"},{"location":"tutorials/tut08/#a","title":"(a)\u00b6","text":"<p>Is the linear system $\\mathbf{A}\\mathbf{x} = \\mathbf{b}$ inconsistent?</p>"},{"location":"tutorials/tut08/#b","title":"(b)\u00b6","text":"<p>Find a least squares solution to the system. Is the solution unique?</p>"},{"location":"tutorials/tut08/#c","title":"(c)\u00b6","text":"<p>Use your answer in (b), compute the projection of $\\mathbf{b}$ onto the column space of $\\mathbf{A}$. Is the solution unique?</p>"},{"location":"tutorials/tut08/#question-3-application","title":"Question 3 (Application)\u00b6","text":"<p>A line $p(x) = a_1 x + a_0$ is said to be the least squares approximating line for a given set of data points $(x_1, y_1), (x_2, y_2), \\ldots, (x_m, y_m)$ if the sum $$S = [y_1 - p(x_1)]^2 + [y_2 - p(x_2)]^2 + \\cdots + [y_m - p(x_m)]^2$$ is minimized. Writing $$\\mathbf{x} = \\begin{pmatrix} x_1 \\\\ x_2 \\\\ \\vdots \\\\ x_m \\end{pmatrix}, \\quad \\mathbf{y} = \\begin{pmatrix} y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_m \\end{pmatrix}, \\quad \\text{and} \\quad p(\\mathbf{x}) = \\begin{pmatrix} p(x_1) \\\\ p(x_2) \\\\ \\vdots \\\\ p(x_m) \\end{pmatrix} = \\begin{pmatrix} a_1 x_1 + a_0 \\\\ a_1 x_2 + a_0 \\\\ \\vdots \\\\ a_1 x_m + a_0 \\end{pmatrix}$$</p> <p>the problem is now rephrased as finding $a_0, a_1$ such that $$S = ||\\mathbf{y} - p(\\mathbf{x})||^2$$ is minimized. Observe that if we let $$\\mathbf{N} = \\begin{pmatrix} 1 &amp; x_1 \\\\ 1 &amp; x_2 \\\\ \\vdots &amp; \\vdots \\\\ 1 &amp; x_m \\end{pmatrix} \\quad \\text{and} \\quad \\mathbf{a} = \\begin{pmatrix} a_0 \\\\ a_1 \\end{pmatrix}$$</p> <p>then $\\mathbf{N}\\mathbf{a} = p(\\mathbf{x})$. And so our aim is to find $\\mathbf{a}$ that minimizes $||\\mathbf{y} - \\mathbf{N}\\mathbf{a}||^2$.</p> <p>It is known the equation representing the dependency of the resistance of a cylindrically shaped conductor (a wire) at $20\u00b0C$ is given by $$R = \\rho \\frac{L}{A}$$ where $R$ is the resistance measured in Ohms $\\Omega$, $L$ is the length of the material in meters $m$, $A$ is the cross-sectional area of the material in meter squared $m^2$, and $\\rho$ is the resistivity of the material in Ohm meters $\\Omega m$.</p> <p>A student wants to measure the resistivity of a certain material. Keeping the cross-sectional area constant at $0.002 m^2$, he connected the power sources along the material at various lengths and measured the resistance and obtained the following data.</p> $L$ $0.01$ $0.012$ $0.015$ $0.02$ $R$ $2.75 \\times 10^{-4}$ $3.31 \\times 10^{-4}$ $3.92 \\times 10^{-4}$ $4.95 \\times 10^{-4}$ <p>It is known that the Ohm meter might not be calibrated. Taking that into account, the student wants to find a linear graph $R = \\frac{\\rho}{0.002} L + R_0$ from the data obtained to compute the resistivity of the material.</p>"},{"location":"tutorials/tut08/#a","title":"(a)\u00b6","text":"<p>Relabeling, we let $R = y$, $\\frac{\\rho}{0.002} = a_1$ and $R_0 = a_0$. Is it possible to find a graph $y = a_1 x + a_0$ satisfying the points?</p>"},{"location":"tutorials/tut08/#b","title":"(b)\u00b6","text":"<p>Find the least square approximating line for the data points and hence find the resistivity of the material. Would this material make a good wire?</p>"},{"location":"tutorials/tut08/#question-4-application","title":"Question 4 (Application)\u00b6","text":"<p>Suppose the equation governing the relation between data pairs is not known. We may want to then find a polynomial $$p(x) = a_0 + a_1 x + a_2 x^2 + \\cdots + a_n x^n$$ of degree $n$, $n \\leq m - 1$, that best approximates the data pairs $(x_1, y_1), (x_2, y_2), \\ldots, (x_m, y_m)$. A least square approximating polynomial of degree $n$ is such that $$||\\mathbf{y} - p(\\mathbf{x})||^2$$ is minimized. If we write $$\\mathbf{x} = \\begin{pmatrix} x_1 \\\\ x_2 \\\\ \\vdots \\\\ x_m \\end{pmatrix}, \\quad \\mathbf{y} = \\begin{pmatrix} y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_m \\end{pmatrix}, \\quad \\mathbf{N} = \\begin{pmatrix} 1 &amp; x_1 &amp; x_1^2 &amp; \\cdots &amp; x_1^n \\\\ 1 &amp; x_2 &amp; x_2^2 &amp; \\cdots &amp; x_2^n \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 1 &amp; x_m &amp; x_m^2 &amp; \\cdots &amp; x_m^n \\end{pmatrix} \\quad \\text{and} \\quad \\mathbf{a} = \\begin{pmatrix} a_0 \\\\ a_1 \\\\ \\vdots \\\\ a_n \\end{pmatrix}$$</p> <p>then $p(\\mathbf{x}) = \\mathbf{N}\\mathbf{a}$, and the task is to find $\\mathbf{a}$ such that $||\\mathbf{y} - \\mathbf{N}\\mathbf{a}||^2$ is minimized. Observe that $\\mathbf{N}$ is a matrix minor of the Vandermonde matrix. If at least $n + 1$ of the $x$-values $x_1, x_2, \\ldots, x_m$ are distinct, the columns of $\\mathbf{N}$ are linearly independent, and thus $\\mathbf{a}$ is uniquely determined by $$\\mathbf{a} = (\\mathbf{N}^T \\mathbf{N})^{-1} \\mathbf{N}^T \\mathbf{y}$$</p> <p>We shall now find a quartic polynomial $$p(x) = a_0 + a_1 x + a_2 x^2 + a_3 x^3 + a_4 x^4$$ that is a least square approximating polynomial for the following data points</p> $x$ $4$ $4.5$ $5$ $5.5$ $6$ $6.5$ $7$ $8$ $8.5$ $y$ $0.8651$ $0.4828$ $2.590$ $-4.389$ $-7.858$ $3.103$ $7.456$ $0.0965$ $4.326$"},{"location":"tutorials/tut08/#question-5","title":"Question 5\u00b6","text":"<p>Let $\\mathbf{A} = \\begin{pmatrix} 1 &amp; 1 &amp; 0 \\\\ 1 &amp; 1 &amp; 0 \\\\ 1 &amp; 1 &amp; 1 \\\\ 0 &amp; 1 &amp; 1 \\end{pmatrix}$.</p>"},{"location":"tutorials/tut08/#a","title":"(a)\u00b6","text":"<p>Find a $QR$ factorization of $\\mathbf{A}$.</p>"},{"location":"tutorials/tut08/#b","title":"(b)\u00b6","text":"<p>Use your answer in (a) to find the least square solution to $\\mathbf{A}\\mathbf{x} = \\mathbf{b}$, where $\\mathbf{b} = \\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\\\ 0 \\end{pmatrix}$.</p>"},{"location":"tutorials/tut09/","title":"Tutorial 9","text":"In\u00a0[1]: Copied! <pre># Required imports\nimport sympy as sym\nfrom ma1522 import Matrix\n</pre> # Required imports import sympy as sym from ma1522 import Matrix In\u00a0[2]: Copied! <pre>mat = Matrix.from_str(\"1 2 0; 0 1 1; 1 0 -2\")\naug = Matrix.from_str(\"300; 300; 300\")\n\nmat, aug\n</pre> mat = Matrix.from_str(\"1 2 0; 0 1 1; 1 0 -2\") aug = Matrix.from_str(\"300; 300; 300\")  mat, aug Out[2]:  $\\displaystyle \\left( \\left[\\begin{array}{ccc}1 &amp; 2 &amp; 0\\\\0 &amp; 1 &amp; 1\\\\1 &amp; 0 &amp; -2\\end{array}\\right], \\  \\left[\\begin{array}{c}300\\\\300\\\\300\\end{array}\\right]\\right)$  In\u00a0[3]: Copied! <pre>aug.is_subspace_of(mat, verbosity=2)\n</pre> aug.is_subspace_of(mat, verbosity=2) <pre>Check if span(self) is subspace of span(other)\n\nBefore RREF: [other | self]\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc|c}1 &amp; 2 &amp; 0 &amp; 300\\\\0 &amp; 1 &amp; 1 &amp; 300\\\\1 &amp; 0 &amp; -2 &amp; 300\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc|c}1 &amp; 0 &amp; -2 &amp; 0\\\\0 &amp; 1 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 3)\\right\\}$  <pre>Span(self) is not a subspace of span(other).\n\n</pre> Out[3]: <pre>False</pre> In\u00a0[4]: Copied! <pre>sol = mat.solve_least_squares(aug, verbosity=2)\nsol\n</pre> sol = mat.solve_least_squares(aug, verbosity=2) sol <pre>Before RREF: [self.T @ self | self.T @ rhs]\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc|c}2 &amp; 2 &amp; -2 &amp; 600\\\\2 &amp; 5 &amp; 1 &amp; 900\\\\-2 &amp; 1 &amp; 5 &amp; -300\\end{array}\\right]$  <pre>\nAfter RREF\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc|c}1 &amp; 0 &amp; -2 &amp; 200\\\\0 &amp; 1 &amp; 1 &amp; 100\\\\0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1)\\right\\}$  Out[4]:  $\\displaystyle \\left[\\begin{array}{c}2 z + 200\\\\100 - z\\\\z\\end{array}\\right]$  In\u00a0[5]: Copied! <pre>sol.sep_part_gen()\n</pre> sol.sep_part_gen() Out[5]:  $\\left(\\left[\\begin{array}{c}200\\\\100\\\\0\\end{array}\\right] + \\left[\\begin{array}{c}2 z\\\\- z\\\\z\\end{array}\\right]\\right)$  In\u00a0[6]: Copied! <pre>A = Matrix.from_str(\"1 1 0; 1 1 0; 1 1 1; 0 1 1\")\nA\n</pre> A = Matrix.from_str(\"1 1 0; 1 1 0; 1 1 1; 0 1 1\") A Out[6]:  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 1 &amp; 0\\\\1 &amp; 1 &amp; 0\\\\1 &amp; 1 &amp; 1\\\\0 &amp; 1 &amp; 1\\end{array}\\right]$  In\u00a0[7]: Copied! <pre># To get the full QR decomposition (as computed by MATLAB), set `full=True`\nA.QRdecomposition(full=True, verbosity=0)\n</pre> # To get the full QR decomposition (as computed by MATLAB), set `full=True` A.QRdecomposition(full=True, verbosity=0) Out[7]:  $\\left[\\begin{array}{cccc}\\frac{\\sqrt{3}}{3} &amp; 0 &amp; - \\frac{\\sqrt{6}}{6} &amp; \\frac{\\sqrt{2}}{2}\\\\\\frac{\\sqrt{3}}{3} &amp; 0 &amp; - \\frac{\\sqrt{6}}{6} &amp; - \\frac{\\sqrt{2}}{2}\\\\\\frac{\\sqrt{3}}{3} &amp; 0 &amp; \\frac{\\sqrt{6}}{3} &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\end{array}\\right]\\left[\\begin{array}{ccc}\\sqrt{3} &amp; \\sqrt{3} &amp; \\frac{\\sqrt{3}}{3}\\\\0 &amp; 1 &amp; 1\\\\0 &amp; 0 &amp; \\frac{\\sqrt{6}}{3}\\\\0 &amp; 0 &amp; 0\\end{array}\\right]$  In\u00a0[8]: Copied! <pre>X = Matrix.from_str(\"1 1 2; 1 2 1; 2 1 1\")\nX\n</pre> X = Matrix.from_str(\"1 1 2; 1 2 1; 2 1 1\") X Out[8]:  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 1 &amp; 2\\\\1 &amp; 2 &amp; 1\\\\2 &amp; 1 &amp; 1\\end{array}\\right]$  In\u00a0[9]: Copied! <pre>X**3 - 4 * X**2 - X + 4 * Matrix.eye(3)\n</pre> X**3 - 4 * X**2 - X + 4 * Matrix.eye(3) Out[9]:  $\\displaystyle \\left[\\begin{array}{ccc}0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0\\end{array}\\right]$  In\u00a0[10]: Copied! <pre>X.cpoly()\n</pre> X.cpoly() Out[10]:  $\\displaystyle \\left(x - 4\\right) \\left(x - 1\\right) \\left(x + 1\\right)$  In\u00a0[11]: Copied! <pre>A = Matrix.from_str(\"1 -3 3; 3 -5 3; 6 -6 4\")\nA\n</pre> A = Matrix.from_str(\"1 -3 3; 3 -5 3; 6 -6 4\") A Out[11]:  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; -3 &amp; 3\\\\3 &amp; -5 &amp; 3\\\\6 &amp; -6 &amp; 4\\end{array}\\right]$  In\u00a0[12]: Copied! <pre>sym.Matrix(A).is_diagonalizable()\n</pre> sym.Matrix(A).is_diagonalizable() Out[12]: <pre>True</pre> In\u00a0[13]: Copied! <pre># To check diagaonalization\n# Take note that the `reals_only` argument is set to `True` by default \n# in accordance with MA1522 syllabus. This overrides SymPy's default \n# behavior of allowing complex eigenvalues.\nA.is_diagonalizable(reals_only=True, verbosity=1)\n</pre> # To check diagaonalization # Take note that the `reals_only` argument is set to `True` by default  # in accordance with MA1522 syllabus. This overrides SymPy's default  # behavior of allowing complex eigenvalues. A.is_diagonalizable(reals_only=True, verbosity=1) <pre>Characteristic Polynomial is: \n</pre>  $\\displaystyle \\left(x - 4\\right) \\left(x + 2\\right)^{2}$  <pre>\nCheck if algebraic multiplicity equals number of eigenvectors.\n\nEigenvectors are:\n</pre>  $\\displaystyle \\left\\{\\text{eigenvalue} = -2, \\quad\\text{algebraic multiplicity} = 2, \\quad\\text{eigenspace} = \\left[\\begin{array}{cc}1 &amp; -1\\\\1 &amp; 0\\\\0 &amp; 1\\end{array}\\right]\\right\\}$   $\\displaystyle \\left\\{\\text{eigenvalue} = 4, \\quad\\text{algebraic multiplicity} = 1, \\quad\\text{eigenspace} = \\left[\\begin{array}{c}\\frac{1}{2}\\\\\\frac{1}{2}\\\\1\\end{array}\\right]\\right\\}$  Out[13]: <pre>True</pre> In\u00a0[14]: Copied! <pre># Full diagaonlisation procedure\nA.diagonalize(reals_only=True, verbosity=1)\n</pre> # Full diagaonlisation procedure A.diagonalize(reals_only=True, verbosity=1) <pre>Characteristic Polynomial\n</pre>  $\\displaystyle \\left(x - 4\\right) \\left(x + 2\\right)^{2}$   $\\displaystyle \\text{Before RREF: }4\\mathbb{I} - \\mathrm{self}$   $\\displaystyle \\left[\\begin{array}{ccc}3 &amp; 3 &amp; -3\\\\-3 &amp; 9 &amp; -3\\\\-6 &amp; 6 &amp; 0\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc}1 &amp; 0 &amp; - \\frac{1}{2}\\\\0 &amp; 1 &amp; - \\frac{1}{2}\\\\0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1)\\right\\}$  <pre>\nEigenvectors:\n</pre>  $\\displaystyle \\left[ \\left[\\begin{matrix}\\frac{1}{2}\\\\\\frac{1}{2}\\\\1\\end{matrix}\\right]\\right]$  <pre>\n\n</pre>  $\\displaystyle \\text{Before RREF: }-2\\mathbb{I} - \\mathrm{self}$   $\\displaystyle \\left[\\begin{array}{ccc}-3 &amp; 3 &amp; -3\\\\-3 &amp; 3 &amp; -3\\\\-6 &amp; 6 &amp; -6\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc}1 &amp; -1 &amp; 1\\\\0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0,)\\right\\}$  <pre>\nEigenvectors:\n</pre>  $\\displaystyle \\left[ \\left[\\begin{matrix}1\\\\1\\\\0\\end{matrix}\\right], \\  \\left[\\begin{matrix}-1\\\\0\\\\1\\end{matrix}\\right]\\right]$  <pre>\n\n</pre> Out[14]:  $\\left[\\begin{array}{ccc}1 &amp; -1 &amp; 1\\\\1 &amp; 0 &amp; 1\\\\0 &amp; 1 &amp; 2\\end{array}\\right]\\left[\\begin{array}{ccc}-2 &amp; 0 &amp; 0\\\\0 &amp; -2 &amp; 0\\\\0 &amp; 0 &amp; 4\\end{array}\\right]\\left[\\begin{matrix}- \\frac{1}{2} &amp; \\frac{3}{2} &amp; - \\frac{1}{2}\\\\-1 &amp; 1 &amp; 0\\\\\\frac{1}{2} &amp; - \\frac{1}{2} &amp; \\frac{1}{2}\\end{matrix}\\right]$  In\u00a0[15]: Copied! <pre>A = Matrix.from_str(\"9 8 6 3; 0 -1 3 -4; 0 0 2 0; 0 0 0 3\")\nA\n</pre> A = Matrix.from_str(\"9 8 6 3; 0 -1 3 -4; 0 0 2 0; 0 0 0 3\") A Out[15]:  $\\displaystyle \\left[\\begin{array}{cccc}9 &amp; 8 &amp; 6 &amp; 3\\\\0 &amp; -1 &amp; 3 &amp; -4\\\\0 &amp; 0 &amp; 2 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 3\\end{array}\\right]$  In\u00a0[16]: Copied! <pre>A.diagonalize(reals_only=True, verbosity=1)\n</pre> A.diagonalize(reals_only=True, verbosity=1) <pre>Characteristic Polynomial\n</pre>  $\\displaystyle \\left(x - 9\\right) \\left(x - 3\\right) \\left(x - 2\\right) \\left(x + 1\\right)$   $\\displaystyle \\text{Before RREF: }9\\mathbb{I} - \\mathrm{self}$   $\\displaystyle \\left[\\begin{array}{cccc}0 &amp; -8 &amp; -6 &amp; -3\\\\0 &amp; 10 &amp; -3 &amp; 4\\\\0 &amp; 0 &amp; 7 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 6\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cccc}0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\\\0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (1, 2, 3)\\right\\}$  <pre>\nEigenvectors:\n</pre>  $\\displaystyle \\left[ \\left[\\begin{matrix}1\\\\0\\\\0\\\\0\\end{matrix}\\right]\\right]$  <pre>\n\n</pre>  $\\displaystyle \\text{Before RREF: }3\\mathbb{I} - \\mathrm{self}$   $\\displaystyle \\left[\\begin{array}{cccc}-6 &amp; -8 &amp; -6 &amp; -3\\\\0 &amp; 4 &amp; -3 &amp; 4\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; - \\frac{5}{6}\\\\0 &amp; 1 &amp; 0 &amp; 1\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 2)\\right\\}$  <pre>\nEigenvectors:\n</pre>  $\\displaystyle \\left[ \\left[\\begin{matrix}\\frac{5}{6}\\\\-1\\\\0\\\\1\\end{matrix}\\right]\\right]$  <pre>\n\n</pre>  $\\displaystyle \\text{Before RREF: }2\\mathbb{I} - \\mathrm{self}$   $\\displaystyle \\left[\\begin{array}{cccc}-7 &amp; -8 &amp; -6 &amp; -3\\\\0 &amp; 3 &amp; -3 &amp; 4\\\\0 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; -1\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cccc}1 &amp; 0 &amp; 2 &amp; 0\\\\0 &amp; 1 &amp; -1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\\\0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 3)\\right\\}$  <pre>\nEigenvectors:\n</pre>  $\\displaystyle \\left[ \\left[\\begin{matrix}-2\\\\1\\\\1\\\\0\\end{matrix}\\right]\\right]$  <pre>\n\n</pre>  $\\displaystyle \\text{Before RREF: }-1\\mathbb{I} - \\mathrm{self}$   $\\displaystyle \\left[\\begin{array}{cccc}-10 &amp; -8 &amp; -6 &amp; -3\\\\0 &amp; 0 &amp; -3 &amp; 4\\\\0 &amp; 0 &amp; -3 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; -4\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cccc}1 &amp; \\frac{4}{5} &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\\\0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 2, 3)\\right\\}$  <pre>\nEigenvectors:\n</pre>  $\\displaystyle \\left[ \\left[\\begin{matrix}- \\frac{4}{5}\\\\1\\\\0\\\\0\\end{matrix}\\right]\\right]$  <pre>\n\n</pre> Out[16]:  $\\left[\\begin{array}{cccc}-4 &amp; -2 &amp; 5 &amp; 1\\\\5 &amp; 1 &amp; -6 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 6 &amp; 0\\end{array}\\right]\\left[\\begin{array}{cccc}-1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 2 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 3 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 9\\end{array}\\right]\\left[\\begin{matrix}0 &amp; \\frac{1}{5} &amp; - \\frac{1}{5} &amp; \\frac{1}{5}\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; \\frac{1}{6}\\\\1 &amp; \\frac{4}{5} &amp; \\frac{6}{5} &amp; - \\frac{1}{30}\\end{matrix}\\right]$  In\u00a0[17]: Copied! <pre>A = Matrix.from_str(\"1 0 0; 1 1 0; 0 1 1\")\nA\n</pre> A = Matrix.from_str(\"1 0 0; 1 1 0; 0 1 1\") A Out[17]:  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 0 &amp; 0\\\\1 &amp; 1 &amp; 0\\\\0 &amp; 1 &amp; 1\\end{array}\\right]$  In\u00a0[18]: Copied! <pre># If matrix is not diagonalizable, it will raise a MatrixError\ntry:\n    A.diagonalize(reals_only=True, verbosity=1)\nexcept sym.matrices.matrixbase.MatrixError as e:\n    print(f\"MatrixError: {e}\")\n</pre> # If matrix is not diagonalizable, it will raise a MatrixError try:     A.diagonalize(reals_only=True, verbosity=1) except sym.matrices.matrixbase.MatrixError as e:     print(f\"MatrixError: {e}\") <pre>Characteristic Polynomial\n</pre>  $\\displaystyle \\left(x - 1\\right)^{3}$   $\\displaystyle \\text{Before RREF: }1\\mathbb{I} - \\mathrm{self}$   $\\displaystyle \\left[\\begin{array}{ccc}0 &amp; 0 &amp; 0\\\\-1 &amp; 0 &amp; 0\\\\0 &amp; -1 &amp; 0\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc}1 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1)\\right\\}$  <pre>\nEigenvectors:\n</pre>  $\\displaystyle \\left[ \\left[\\begin{matrix}0\\\\0\\\\1\\end{matrix}\\right]\\right]$  <pre>\n\nMatrixError: Matrix is not diagonalizable\n</pre> In\u00a0[19]: Copied! <pre>A = Matrix.from_str(\"0 0 1 0; 0 0 0 1; 1 0 0 0; 0 1 0 0\")\nA\n</pre> A = Matrix.from_str(\"0 0 1 0; 0 0 0 1; 1 0 0 0; 0 1 0 0\") A Out[19]:  $\\displaystyle \\left[\\begin{array}{cccc}0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\\\1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\end{array}\\right]$  In\u00a0[20]: Copied! <pre>A.diagonalize(reals_only=True, verbosity=1)\n</pre> A.diagonalize(reals_only=True, verbosity=1) <pre>Characteristic Polynomial\n</pre>  $\\displaystyle \\left(x - 1\\right)^{2} \\left(x + 1\\right)^{2}$   $\\displaystyle \\text{Before RREF: }1\\mathbb{I} - \\mathrm{self}$   $\\displaystyle \\left[\\begin{array}{cccc}1 &amp; 0 &amp; -1 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; -1\\\\-1 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; -1 &amp; 0 &amp; 1\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cccc}1 &amp; 0 &amp; -1 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; -1\\\\0 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1)\\right\\}$  <pre>\nEigenvectors:\n</pre>  $\\displaystyle \\left[ \\left[\\begin{matrix}1\\\\0\\\\1\\\\0\\end{matrix}\\right], \\  \\left[\\begin{matrix}0\\\\1\\\\0\\\\1\\end{matrix}\\right]\\right]$  <pre>\n\n</pre>  $\\displaystyle \\text{Before RREF: }-1\\mathbb{I} - \\mathrm{self}$   $\\displaystyle \\left[\\begin{array}{cccc}-1 &amp; 0 &amp; -1 &amp; 0\\\\0 &amp; -1 &amp; 0 &amp; -1\\\\-1 &amp; 0 &amp; -1 &amp; 0\\\\0 &amp; -1 &amp; 0 &amp; -1\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cccc}1 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 1\\\\0 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1)\\right\\}$  <pre>\nEigenvectors:\n</pre>  $\\displaystyle \\left[ \\left[\\begin{matrix}-1\\\\0\\\\1\\\\0\\end{matrix}\\right], \\  \\left[\\begin{matrix}0\\\\-1\\\\0\\\\1\\end{matrix}\\right]\\right]$  <pre>\n\n</pre> Out[20]:  $\\left[\\begin{array}{cccc}-1 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; -1 &amp; 0 &amp; 1\\\\1 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 1\\end{array}\\right]\\left[\\begin{array}{cccc}-1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; -1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{array}\\right]\\left[\\begin{matrix}- \\frac{1}{2} &amp; 0 &amp; \\frac{1}{2} &amp; 0\\\\0 &amp; - \\frac{1}{2} &amp; 0 &amp; \\frac{1}{2}\\\\\\frac{1}{2} &amp; 0 &amp; \\frac{1}{2} &amp; 0\\\\0 &amp; \\frac{1}{2} &amp; 0 &amp; \\frac{1}{2}\\end{matrix}\\right]$  In\u00a0[21]: Copied! <pre>A = Matrix.from_str(\"-1 1 1; 1 1 -1; -4 2 3\")\nA\n</pre> A = Matrix.from_str(\"-1 1 1; 1 1 -1; -4 2 3\") A Out[21]:  $\\displaystyle \\left[\\begin{array}{ccc}-1 &amp; 1 &amp; 1\\\\1 &amp; 1 &amp; -1\\\\-4 &amp; 2 &amp; 3\\end{array}\\right]$  In\u00a0[22]: Copied! <pre># `cpoly` returning a tuple of expressions means that the characteristic \n# polynomial is not irreducible over the reals. As the rhs expression \n# only has non-real roots. This means that the matrix is not \n# diagaonalizable over the reals (with regards to MA1522 syllabus).\nA.cpoly()\n</pre> # `cpoly` returning a tuple of expressions means that the characteristic  # polynomial is not irreducible over the reals. As the rhs expression  # only has non-real roots. This means that the matrix is not  # diagaonalizable over the reals (with regards to MA1522 syllabus). A.cpoly() Out[22]:  $\\displaystyle \\left( x - 1, \\  x^{2} - 2 x + 2\\right)$  In\u00a0[23]: Copied! <pre>Matrix.eye(4).inv()\n</pre> Matrix.eye(4).inv() Out[23]:  $\\displaystyle \\left[\\begin{matrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{matrix}\\right]$  In\u00a0[24]: Copied! <pre># By setting `reals_only=False`, we allow complex eigenvalues\n# and hence the matrix can be diagonalized.\nPDP = A.diagonalize(reals_only=False)\nPDP\n</pre> # By setting `reals_only=False`, we allow complex eigenvalues # and hence the matrix can be diagonalized. PDP = A.diagonalize(reals_only=False) PDP Out[24]:  $\\left[\\begin{array}{ccc}1 &amp; 1 &amp; 1\\\\1 &amp; - i &amp; i\\\\1 &amp; 2 &amp; 2\\end{array}\\right]\\left[\\begin{array}{ccc}1 &amp; 0 &amp; 0\\\\0 &amp; 1 - i &amp; 0\\\\0 &amp; 0 &amp; 1 + i\\end{array}\\right]\\left[\\begin{matrix}2 &amp; 0 &amp; -1\\\\- \\frac{1}{2} - i &amp; \\frac{i}{2} &amp; \\frac{1}{2} + \\frac{i}{2}\\\\- \\frac{1}{2} + i &amp; - \\frac{i}{2} &amp; \\frac{1}{2} - \\frac{i}{2}\\end{matrix}\\right]$"},{"location":"tutorials/tut09/#tutorial-09-ay2425-sem-1","title":"Tutorial 09 (AY24/25 Sem 1)\u00b6","text":""},{"location":"tutorials/tut09/#question-1","title":"Question 1\u00b6","text":"<p>A father wishes to distribute an amount of money among his three sons Jack, Jim, and John. He wishes to distribute such that the following conditions are all satisfied.</p> <p>(i) The amount Jack receives plus twice the amount Jim receives is $300.</p> <p>(ii) The amount Jim receives plus the amount John receives is $300.</p> <p>(iii) Jack receives $300 more than twice of what John receives.</p>"},{"location":"tutorials/tut09/#a","title":"(a)\u00b6","text":"<p>Is it possible for the following conditions to all be satisfied?</p>"},{"location":"tutorials/tut09/#b","title":"(b)\u00b6","text":"<p>If it is not possible, find a least square solution. (Make sure that your least square solution is feasible. For example, one cannot give a negative amount of money to anybody.)</p>"},{"location":"tutorials/tut09/#question-2","title":"Question 2\u00b6","text":""},{"location":"tutorials/tut09/#b","title":"(b)\u00b6","text":"<p>Let $$\\mathbf{A} = \\begin{pmatrix} 1 &amp; 1 &amp; 0 \\\\ 1 &amp; 1 &amp; 0 \\\\ 1 &amp; 1 &amp; 1 \\\\ 0 &amp; 1 &amp; 1 \\end{pmatrix}$$</p> <p>What is $\\mathbf{Q}$ and $\\mathbf{R}$? Compare this with the answer in tutorial 8 question 5(a).</p>"},{"location":"tutorials/tut09/#question-3-cayley-hamilton-theorem","title":"Question 3 (Cayley-Hamilton Theorem)\u00b6","text":"<p>Consider $$p(X) = X^3 - 4X^2 - X + 4I$$</p>"},{"location":"tutorials/tut09/#a","title":"(a)\u00b6","text":"<p>Compute $p(X)$ for $X = \\begin{pmatrix} 1 &amp; 1 &amp; 2 \\\\ 1 &amp; 2 &amp; 1 \\\\ 2 &amp; 1 &amp; 1 \\end{pmatrix}$.</p>"},{"location":"tutorials/tut09/#b","title":"(b)\u00b6","text":"<p>Find the characteristic polynomial of $X$.</p>"},{"location":"tutorials/tut09/#question-4","title":"Question 4\u00b6","text":"<p>For each of the following matrices $\\mathbf{A}$, determine if $\\mathbf{A}$ is diagonalizable. If $\\mathbf{A}$ is diagonalizable, find an invertible $\\mathbf{P}$ that diagonalizes $\\mathbf{A}$ and determine $\\mathbf{P}^{-1}\\mathbf{A}\\mathbf{P}$.</p>"},{"location":"tutorials/tut09/#a","title":"(a)\u00b6","text":"<p>$\\mathbf{A} = \\begin{pmatrix} 1 &amp; -3 &amp; 3 \\\\ 3 &amp; -5 &amp; 3 \\\\ 6 &amp; -6 &amp; 4 \\end{pmatrix}$</p>"},{"location":"tutorials/tut09/#b","title":"(b)\u00b6","text":"<p>$\\mathbf{A} = \\begin{pmatrix} 9 &amp; 8 &amp; 6 &amp; 3 \\\\ 0 &amp; -1 &amp; 3 &amp; -4 \\\\ 0 &amp; 0 &amp; 2 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 3 \\end{pmatrix}$</p>"},{"location":"tutorials/tut09/#c","title":"(c)\u00b6","text":"<p>$\\mathbf{A} = \\begin{pmatrix} 1 &amp; 0 &amp; 0 \\\\ 1 &amp; 1 &amp; 0 \\\\ 0 &amp; 1 &amp; 1 \\end{pmatrix}$</p>"},{"location":"tutorials/tut09/#d","title":"(d)\u00b6","text":"<p>$\\mathbf{A} = \\begin{pmatrix} 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\end{pmatrix}$</p>"},{"location":"tutorials/tut09/#e","title":"(e)\u00b6","text":"<p>$\\mathbf{A} = \\begin{pmatrix} -1 &amp; 1 &amp; 1 \\\\ 1 &amp; 1 &amp; -1 \\\\ -4 &amp; 2 &amp; 3 \\end{pmatrix}$</p>"},{"location":"tutorials/tut10/","title":"Tutorial 10","text":"In\u00a0[1]: Copied! <pre># Required imports\nimport sympy as sym\nfrom ma1522 import Matrix\n</pre> # Required imports import sympy as sym from ma1522 import Matrix In\u00a0[2]: Copied! <pre>A = Matrix.from_str(\"0.4 0.1 0.5; 0.2 0.6 0.2; 0.4 0.3 0.3\")\nA\n</pre> A = Matrix.from_str(\"0.4 0.1 0.5; 0.2 0.6 0.2; 0.4 0.3 0.3\") A Out[2]:  $\\displaystyle \\left[\\begin{array}{ccc}0.4 &amp; 0.1 &amp; 0.5\\\\0.2 &amp; 0.6 &amp; 0.2\\\\0.4 &amp; 0.3 &amp; 0.3\\end{array}\\right]$  In\u00a0[3]: Copied! <pre># Always work with fractions to avoid floating point errors\nA.simplify(rational=True) \nA\n</pre> # Always work with fractions to avoid floating point errors A.simplify(rational=True)  A Out[3]:  $\\displaystyle \\left[\\begin{array}{ccc}\\frac{2}{5} &amp; \\frac{1}{10} &amp; \\frac{1}{2}\\\\\\frac{1}{5} &amp; \\frac{3}{5} &amp; \\frac{1}{5}\\\\\\frac{2}{5} &amp; \\frac{3}{10} &amp; \\frac{3}{10}\\end{array}\\right]$  In\u00a0[4]: Copied! <pre>A.is_stochastic(verbosity=1)\n</pre> A.is_stochastic(verbosity=1) <pre>Check if matrix is square: True\nCheck if all entries are non-negative: True\nCheck if each column sums to 1: True\n</pre> Out[4]: <pre>True</pre> In\u00a0[5]: Copied! <pre>PDP = A.diagonalize(reals_only=True, verbosity=1)\nPDP\n</pre> PDP = A.diagonalize(reals_only=True, verbosity=1) PDP <pre>Characteristic Polynomial\n</pre>  $\\displaystyle \\left(x - 1\\right) \\left(x - \\frac{2}{5}\\right) \\left(x + \\frac{1}{10}\\right)$   $\\displaystyle \\text{Before RREF: }1\\mathbb{I} - \\mathrm{self}$   $\\displaystyle \\left[\\begin{array}{ccc}\\frac{3}{5} &amp; - \\frac{1}{10} &amp; - \\frac{1}{2}\\\\- \\frac{1}{5} &amp; \\frac{2}{5} &amp; - \\frac{1}{5}\\\\- \\frac{2}{5} &amp; - \\frac{3}{10} &amp; \\frac{7}{10}\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc}1 &amp; 0 &amp; -1\\\\0 &amp; 1 &amp; -1\\\\0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1)\\right\\}$  <pre>\nEigenvectors:\n</pre>  $\\displaystyle \\left[ \\left[\\begin{matrix}1\\\\1\\\\1\\end{matrix}\\right]\\right]$  <pre>\n\n</pre>  $\\displaystyle \\text{Before RREF: }\\frac{2}{5}\\mathbb{I} - \\mathrm{self}$   $\\displaystyle \\left[\\begin{array}{ccc}0 &amp; - \\frac{1}{10} &amp; - \\frac{1}{2}\\\\- \\frac{1}{5} &amp; - \\frac{1}{5} &amp; - \\frac{1}{5}\\\\- \\frac{2}{5} &amp; - \\frac{3}{10} &amp; \\frac{1}{10}\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc}1 &amp; 0 &amp; -4\\\\0 &amp; 1 &amp; 5\\\\0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1)\\right\\}$  <pre>\nEigenvectors:\n</pre>  $\\displaystyle \\left[ \\left[\\begin{matrix}4\\\\-5\\\\1\\end{matrix}\\right]\\right]$  <pre>\n\n</pre>  $\\displaystyle \\text{Before RREF: }- \\frac{1}{10}\\mathbb{I} - \\mathrm{self}$   $\\displaystyle \\left[\\begin{array}{ccc}- \\frac{1}{2} &amp; - \\frac{1}{10} &amp; - \\frac{1}{2}\\\\- \\frac{1}{5} &amp; - \\frac{7}{10} &amp; - \\frac{1}{5}\\\\- \\frac{2}{5} &amp; - \\frac{3}{10} &amp; - \\frac{2}{5}\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc}1 &amp; 0 &amp; 1\\\\0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1)\\right\\}$  <pre>\nEigenvectors:\n</pre>  $\\displaystyle \\left[ \\left[\\begin{matrix}-1\\\\0\\\\1\\end{matrix}\\right]\\right]$  <pre>\n\n</pre> Out[5]:  $\\left[\\begin{array}{ccc}-1 &amp; 4 &amp; 1\\\\0 &amp; -5 &amp; 1\\\\1 &amp; 1 &amp; 1\\end{array}\\right]\\left[\\begin{array}{ccc}- \\frac{1}{10} &amp; 0 &amp; 0\\\\0 &amp; \\frac{2}{5} &amp; 0\\\\0 &amp; 0 &amp; 1\\end{array}\\right]\\left[\\begin{matrix}- \\frac{2}{5} &amp; - \\frac{1}{5} &amp; \\frac{3}{5}\\\\\\frac{1}{15} &amp; - \\frac{2}{15} &amp; \\frac{1}{15}\\\\\\frac{1}{3} &amp; \\frac{1}{3} &amp; \\frac{1}{3}\\end{matrix}\\right]$  In\u00a0[6]: Copied! <pre>x_0 = Matrix.from_str(\"100; 0; 0\")\nx_0\n</pre> x_0 = Matrix.from_str(\"100; 0; 0\") x_0 Out[6]:  $\\displaystyle \\left[\\begin{array}{c}100\\\\0\\\\0\\end{array}\\right]$  In\u00a0[7]: Copied! <pre>x_3 = PDP.P @ PDP.D**3 @ PDP.P.inv() @ x_0\nx_3\n</pre> x_3 = PDP.P @ PDP.D**3 @ PDP.P.inv() @ x_0 x_3 Out[7]:  $\\displaystyle \\left[\\begin{array}{c}35\\\\\\frac{156}{5}\\\\\\frac{169}{5}\\end{array}\\right]$  In\u00a0[8]: Copied! <pre>x_3.evalf()\n</pre> x_3.evalf() Out[8]:  $\\displaystyle \\left[\\begin{matrix}35.0\\\\31.2\\\\33.8\\end{matrix}\\right]$  In\u00a0[9]: Copied! <pre># Brute force calculation\n(A**100 @ x_0).evalf()\n</pre> # Brute force calculation (A**100 @ x_0).evalf() Out[9]:  $\\displaystyle \\left[\\begin{matrix}33.3333333333333\\\\33.3333333333333\\\\33.3333333333333\\end{matrix}\\right]$  In\u00a0[10]: Copied! <pre>D_100 = (PDP.D**1000).evalf()\nD_100\n</pre> D_100 = (PDP.D**1000).evalf() D_100 Out[10]:  $\\displaystyle \\left[\\begin{matrix}1.0 \\cdot 10^{-1000} &amp; 0 &amp; 0\\\\0 &amp; 1.14813069527425 \\cdot 10^{-398} &amp; 0\\\\0 &amp; 0 &amp; 1.0\\end{matrix}\\right]$  In\u00a0[11]: Copied! <pre># Therefore,\nD_inf = Matrix.from_str(\"0 0 0; 0 0 0; 0 0 1\")\nD_inf\n</pre> # Therefore, D_inf = Matrix.from_str(\"0 0 0; 0 0 0; 0 0 1\") D_inf Out[11]:  $\\displaystyle \\left[\\begin{array}{ccc}0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1\\end{array}\\right]$  In\u00a0[12]: Copied! <pre>PDP.P @ D_inf @ PDP.P.inv() @ x_0\n</pre> PDP.P @ D_inf @ PDP.P.inv() @ x_0 Out[12]:  $\\displaystyle \\left[\\begin{array}{c}\\frac{100}{3}\\\\\\frac{100}{3}\\\\\\frac{100}{3}\\end{array}\\right]$  In\u00a0[13]: Copied! <pre># simple random vector\nMatrix.create_unk_matrix(3, 1)\n</pre> # simple random vector Matrix.create_unk_matrix(3, 1) Out[13]:  $\\displaystyle \\left[\\begin{array}{c}x\\\\y\\\\z\\end{array}\\right]$  In\u00a0[14]: Copied! <pre># To use custom symbols, the most straightforward way is\n# to use sympy's symbols function\nalpha, beta, gamma = sym.symbols(\"alpha beta gamma\")\nx = Matrix([alpha, beta, gamma])\nx\n</pre> # To use custom symbols, the most straightforward way is # to use sympy's symbols function alpha, beta, gamma = sym.symbols(\"alpha beta gamma\") x = Matrix([alpha, beta, gamma]) x Out[14]:  $\\displaystyle \\left[\\begin{array}{c}\\alpha\\\\\\beta\\\\\\gamma\\end{array}\\right]$  In\u00a0[15]: Copied! <pre>PDP.P @ D_inf @ PDP.P.inv() @ x\n</pre> PDP.P @ D_inf @ PDP.P.inv() @ x Out[15]:  $\\displaystyle \\left[\\begin{array}{c}\\frac{\\alpha}{3} + \\frac{\\beta}{3} + \\frac{\\gamma}{3}\\\\\\frac{\\alpha}{3} + \\frac{\\beta}{3} + \\frac{\\gamma}{3}\\\\\\frac{\\alpha}{3} + \\frac{\\beta}{3} + \\frac{\\gamma}{3}\\end{array}\\right]$  In\u00a0[16]: Copied! <pre>A = Matrix.from_str(\"1 0 3; 0 4 0; 0 0 4\")\nA\n</pre> A = Matrix.from_str(\"1 0 3; 0 4 0; 0 0 4\") A Out[16]:  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 0 &amp; 3\\\\0 &amp; 4 &amp; 0\\\\0 &amp; 0 &amp; 4\\end{array}\\right]$  In\u00a0[17]: Copied! <pre>PDP = A.diagonalize(reals_only=True, verbosity=1)\nPDP\n</pre> PDP = A.diagonalize(reals_only=True, verbosity=1) PDP <pre>Characteristic Polynomial\n</pre>  $\\displaystyle \\left(x - 4\\right)^{2} \\left(x - 1\\right)$   $\\displaystyle \\text{Before RREF: }1\\mathbb{I} - \\mathrm{self}$   $\\displaystyle \\left[\\begin{array}{ccc}0 &amp; 0 &amp; -3\\\\0 &amp; -3 &amp; 0\\\\0 &amp; 0 &amp; -3\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc}0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 1\\\\0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (1, 2)\\right\\}$  <pre>\nEigenvectors:\n</pre>  $\\displaystyle \\left[ \\left[\\begin{matrix}1\\\\0\\\\0\\end{matrix}\\right]\\right]$  <pre>\n\n</pre>  $\\displaystyle \\text{Before RREF: }4\\mathbb{I} - \\mathrm{self}$   $\\displaystyle \\left[\\begin{array}{ccc}3 &amp; 0 &amp; -3\\\\0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc}1 &amp; 0 &amp; -1\\\\0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0,)\\right\\}$  <pre>\nEigenvectors:\n</pre>  $\\displaystyle \\left[ \\left[\\begin{matrix}0\\\\1\\\\0\\end{matrix}\\right], \\  \\left[\\begin{matrix}1\\\\0\\\\1\\end{matrix}\\right]\\right]$  <pre>\n\n</pre> Out[17]:  $\\left[\\begin{array}{ccc}1 &amp; 0 &amp; 1\\\\0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 1\\end{array}\\right]\\left[\\begin{array}{ccc}1 &amp; 0 &amp; 0\\\\0 &amp; 4 &amp; 0\\\\0 &amp; 0 &amp; 4\\end{array}\\right]\\left[\\begin{matrix}1 &amp; 0 &amp; -1\\\\0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 1\\end{matrix}\\right]$  In\u00a0[18]: Copied! <pre># Therefore, A = B**2 --&gt; B = PDP.P @ PDP.D**0.5 @ PDP.P.inv()\n# Note: sym.sqrt only produces the principal square root\nB = PDP.P @ sym.sqrt(PDP.D) @ PDP.P.inv() \nB\n</pre> # Therefore, A = B**2 --&gt; B = PDP.P @ PDP.D**0.5 @ PDP.P.inv() # Note: sym.sqrt only produces the principal square root B = PDP.P @ sym.sqrt(PDP.D) @ PDP.P.inv()  B Out[18]:  $\\displaystyle \\left[\\begin{matrix}1 &amp; 0 &amp; 1\\\\0 &amp; 2 &amp; 0\\\\0 &amp; 0 &amp; 2\\end{matrix}\\right]$  In\u00a0[19]: Copied! <pre>A = Matrix.from_str(\"3 1; 1 3\")\nA\n</pre> A = Matrix.from_str(\"3 1; 1 3\") A Out[19]:  $\\displaystyle \\left[\\begin{array}{cc}3 &amp; 1\\\\1 &amp; 3\\end{array}\\right]$  In\u00a0[20]: Copied! <pre>A.orthogonally_diagonalize(verbosity=1)\n</pre> A.orthogonally_diagonalize(verbosity=1) <pre>Check if matrix is symmetric: True\nCharacteristic Polynomial\n</pre>  $\\displaystyle \\left(x - 4\\right) \\left(x - 2\\right)$   $\\displaystyle \\text{Before RREF: }4\\mathbb{I} - \\mathrm{self}$   $\\displaystyle \\left[\\begin{array}{cc}1 &amp; -1\\\\-1 &amp; 1\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cc}1 &amp; -1\\\\0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0,)\\right\\}$  <pre>\nEigenvectors:\n</pre>  $\\displaystyle \\left[ \\left[\\begin{matrix}1\\\\1\\end{matrix}\\right]\\right]$  <pre>\n\n</pre>  $\\displaystyle \\text{Before RREF: }2\\mathbb{I} - \\mathrm{self}$   $\\displaystyle \\left[\\begin{array}{cc}-1 &amp; -1\\\\-1 &amp; -1\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cc}1 &amp; 1\\\\0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0,)\\right\\}$  <pre>\nEigenvectors:\n</pre>  $\\displaystyle \\left[ \\left[\\begin{matrix}-1\\\\1\\end{matrix}\\right]\\right]$  <pre>\n\n</pre> Out[20]:  $\\left[\\begin{array}{cc}- \\frac{\\sqrt{2}}{2} &amp; \\frac{\\sqrt{2}}{2}\\\\\\frac{\\sqrt{2}}{2} &amp; \\frac{\\sqrt{2}}{2}\\end{array}\\right]\\left[\\begin{array}{cc}2 &amp; 0\\\\0 &amp; 4\\end{array}\\right]\\left[\\begin{matrix}- \\frac{\\sqrt{2}}{2} &amp; \\frac{\\sqrt{2}}{2}\\\\\\frac{\\sqrt{2}}{2} &amp; \\frac{\\sqrt{2}}{2}\\end{matrix}\\right]$  In\u00a0[21]: Copied! <pre>A = Matrix.from_str(\"2 2 -2; 2 -1 4; -2 4 -1\")\nA\n</pre> A = Matrix.from_str(\"2 2 -2; 2 -1 4; -2 4 -1\") A Out[21]:  $\\displaystyle \\left[\\begin{array}{ccc}2 &amp; 2 &amp; -2\\\\2 &amp; -1 &amp; 4\\\\-2 &amp; 4 &amp; -1\\end{array}\\right]$  In\u00a0[22]: Copied! <pre>PDPT = A.orthogonally_diagonalize(verbosity=1)\nPDPT\n</pre> PDPT = A.orthogonally_diagonalize(verbosity=1) PDPT <pre>Check if matrix is symmetric: True\nCharacteristic Polynomial\n</pre>  $\\displaystyle \\left(x - 3\\right)^{2} \\left(x + 6\\right)$   $\\displaystyle \\text{Before RREF: }-6\\mathbb{I} - \\mathrm{self}$   $\\displaystyle \\left[\\begin{array}{ccc}-8 &amp; -2 &amp; 2\\\\-2 &amp; -5 &amp; -4\\\\2 &amp; -4 &amp; -5\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc}1 &amp; 0 &amp; - \\frac{1}{2}\\\\0 &amp; 1 &amp; 1\\\\0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1)\\right\\}$  <pre>\nEigenvectors:\n</pre>  $\\displaystyle \\left[ \\left[\\begin{matrix}\\frac{1}{2}\\\\-1\\\\1\\end{matrix}\\right]\\right]$  <pre>\n\n</pre>  $\\displaystyle \\text{Before RREF: }3\\mathbb{I} - \\mathrm{self}$   $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; -2 &amp; 2\\\\-2 &amp; 4 &amp; -4\\\\2 &amp; -4 &amp; 4\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc}1 &amp; -2 &amp; 2\\\\0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0,)\\right\\}$  <pre>\nEigenvectors:\n</pre>  $\\displaystyle \\left[ \\left[\\begin{matrix}2\\\\1\\\\0\\end{matrix}\\right], \\  \\left[\\begin{matrix}-2\\\\0\\\\1\\end{matrix}\\right]\\right]$  <pre>\n\nEigenvalue:  3\n[Gram Schmidt Process]\n</pre>  $\\displaystyle v_1 = \\left[\\begin{array}{c}2\\\\1\\\\0\\end{array}\\right]$   $\\displaystyle v_2 = \\left[\\begin{array}{c}-2\\\\0\\\\1\\end{array}\\right]- \\left(\\frac{-4}{5}\\right) \\left[\\begin{array}{c}2\\\\1\\\\0\\end{array}\\right] = \\left(\\frac{1}{5}\\right) \\left[\\begin{matrix}-2\\\\4\\\\5\\end{matrix}\\right]$  Out[22]:  $\\left[\\begin{array}{ccc}\\frac{1}{3} &amp; \\frac{2 \\sqrt{5}}{5} &amp; - \\frac{2 \\sqrt{5}}{15}\\\\- \\frac{2}{3} &amp; \\frac{\\sqrt{5}}{5} &amp; \\frac{4 \\sqrt{5}}{15}\\\\\\frac{2}{3} &amp; 0 &amp; \\frac{\\sqrt{5}}{3}\\end{array}\\right]\\left[\\begin{array}{ccc}-6 &amp; 0 &amp; 0\\\\0 &amp; 3 &amp; 0\\\\0 &amp; 0 &amp; 3\\end{array}\\right]\\left[\\begin{matrix}\\frac{1}{3} &amp; - \\frac{2}{3} &amp; \\frac{2}{3}\\\\\\frac{2 \\sqrt{5}}{5} &amp; \\frac{\\sqrt{5}}{5} &amp; 0\\\\- \\frac{2 \\sqrt{5}}{15} &amp; \\frac{4 \\sqrt{5}}{15} &amp; \\frac{\\sqrt{5}}{3}\\end{matrix}\\right]$  In\u00a0[23]: Copied! <pre>A = Matrix.from_str(\"1 -2 0 0; -2 1 0 0; 0 0 1 -2; 0 0 -2 1\")\nA\n</pre> A = Matrix.from_str(\"1 -2 0 0; -2 1 0 0; 0 0 1 -2; 0 0 -2 1\") A Out[23]:  $\\displaystyle \\left[\\begin{array}{cccc}1 &amp; -2 &amp; 0 &amp; 0\\\\-2 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; -2\\\\0 &amp; 0 &amp; -2 &amp; 1\\end{array}\\right]$  In\u00a0[24]: Copied! <pre>PDPT = A.orthogonally_diagonalize(verbosity=1)\nPDPT\n</pre> PDPT = A.orthogonally_diagonalize(verbosity=1) PDPT <pre>Check if matrix is symmetric: True\nCharacteristic Polynomial\n</pre>  $\\displaystyle \\left(x - 3\\right)^{2} \\left(x + 1\\right)^{2}$   $\\displaystyle \\text{Before RREF: }3\\mathbb{I} - \\mathrm{self}$   $\\displaystyle \\left[\\begin{array}{cccc}2 &amp; 2 &amp; 0 &amp; 0\\\\2 &amp; 2 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 2 &amp; 2\\\\0 &amp; 0 &amp; 2 &amp; 2\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cccc}1 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 1\\\\0 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 2)\\right\\}$  <pre>\nEigenvectors:\n</pre>  $\\displaystyle \\left[ \\left[\\begin{matrix}-1\\\\1\\\\0\\\\0\\end{matrix}\\right], \\  \\left[\\begin{matrix}0\\\\0\\\\-1\\\\1\\end{matrix}\\right]\\right]$  <pre>\n\n</pre>  $\\displaystyle \\text{Before RREF: }-1\\mathbb{I} - \\mathrm{self}$   $\\displaystyle \\left[\\begin{array}{cccc}-2 &amp; 2 &amp; 0 &amp; 0\\\\2 &amp; -2 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; -2 &amp; 2\\\\0 &amp; 0 &amp; 2 &amp; -2\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cccc}1 &amp; -1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; -1\\\\0 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 2)\\right\\}$  <pre>\nEigenvectors:\n</pre>  $\\displaystyle \\left[ \\left[\\begin{matrix}1\\\\1\\\\0\\\\0\\end{matrix}\\right], \\  \\left[\\begin{matrix}0\\\\0\\\\1\\\\1\\end{matrix}\\right]\\right]$  <pre>\n\nEigenvalue:  -1\n[Gram Schmidt Process]\n</pre>  $\\displaystyle v_1 = \\left[\\begin{array}{c}1\\\\1\\\\0\\\\0\\end{array}\\right]$   $\\displaystyle v_2 = \\left[\\begin{array}{c}0\\\\0\\\\1\\\\1\\end{array}\\right]- \\left(\\frac{0}{2}\\right) \\left[\\begin{array}{c}1\\\\1\\\\0\\\\0\\end{array}\\right] = 1 \\left[\\begin{matrix}0\\\\0\\\\1\\\\1\\end{matrix}\\right]$  <pre>Eigenvalue:  3\n[Gram Schmidt Process]\n</pre>  $\\displaystyle v_1 = \\left[\\begin{array}{c}-1\\\\1\\\\0\\\\0\\end{array}\\right]$   $\\displaystyle v_2 = \\left[\\begin{array}{c}0\\\\0\\\\-1\\\\1\\end{array}\\right]- \\left(\\frac{0}{2}\\right) \\left[\\begin{array}{c}-1\\\\1\\\\0\\\\0\\end{array}\\right] = 1 \\left[\\begin{matrix}0\\\\0\\\\-1\\\\1\\end{matrix}\\right]$  Out[24]:  $\\left[\\begin{array}{cccc}\\frac{\\sqrt{2}}{2} &amp; 0 &amp; - \\frac{\\sqrt{2}}{2} &amp; 0\\\\\\frac{\\sqrt{2}}{2} &amp; 0 &amp; \\frac{\\sqrt{2}}{2} &amp; 0\\\\0 &amp; \\frac{\\sqrt{2}}{2} &amp; 0 &amp; - \\frac{\\sqrt{2}}{2}\\\\0 &amp; \\frac{\\sqrt{2}}{2} &amp; 0 &amp; \\frac{\\sqrt{2}}{2}\\end{array}\\right]\\left[\\begin{array}{cccc}-1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; -1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 3 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 3\\end{array}\\right]\\left[\\begin{matrix}\\frac{\\sqrt{2}}{2} &amp; \\frac{\\sqrt{2}}{2} &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; \\frac{\\sqrt{2}}{2} &amp; \\frac{\\sqrt{2}}{2}\\\\- \\frac{\\sqrt{2}}{2} &amp; \\frac{\\sqrt{2}}{2} &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; - \\frac{\\sqrt{2}}{2} &amp; \\frac{\\sqrt{2}}{2}\\end{matrix}\\right]$  In\u00a0[25]: Copied! <pre>A = Matrix.from_str(\"3 2; 2 3; 2 -2\")\nA\n</pre> A = Matrix.from_str(\"3 2; 2 3; 2 -2\") A Out[25]:  $\\displaystyle \\left[\\begin{array}{cc}3 &amp; 2\\\\2 &amp; 3\\\\2 &amp; -2\\end{array}\\right]$  In\u00a0[26]: Copied! <pre>svd = A.singular_value_decomposition(verbosity=1)\nsvd\n</pre> svd = A.singular_value_decomposition(verbosity=1) svd <pre>A^T A\n</pre>  $\\displaystyle \\left[\\begin{array}{cc}17 &amp; 8\\\\8 &amp; 17\\end{array}\\right]$  <pre>Check if matrix is symmetric: True\nCharacteristic Polynomial\n</pre>  $\\displaystyle \\left(x - 25\\right) \\left(x - 9\\right)$   $\\displaystyle \\text{Before RREF: }25\\mathbb{I} - \\mathrm{self}$   $\\displaystyle \\left[\\begin{array}{cc}8 &amp; -8\\\\-8 &amp; 8\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cc}1 &amp; -1\\\\0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0,)\\right\\}$  <pre>\nEigenvectors:\n</pre>  $\\displaystyle \\left[ \\left[\\begin{matrix}1\\\\1\\end{matrix}\\right]\\right]$  <pre>\n\n</pre>  $\\displaystyle \\text{Before RREF: }9\\mathbb{I} - \\mathrm{self}$   $\\displaystyle \\left[\\begin{array}{cc}-8 &amp; -8\\\\-8 &amp; -8\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cc}1 &amp; 1\\\\0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0,)\\right\\}$  <pre>\nEigenvectors:\n</pre>  $\\displaystyle \\left[ \\left[\\begin{matrix}-1\\\\1\\end{matrix}\\right]\\right]$  <pre>\n\n</pre>  $\\displaystyle u_1 = (1/5)A\\left[\\begin{matrix}\\frac{\\sqrt{2}}{2}\\\\\\frac{\\sqrt{2}}{2}\\end{matrix}\\right] = \\left[\\begin{array}{c}\\frac{\\sqrt{2}}{2}\\\\\\frac{\\sqrt{2}}{2}\\\\0\\end{array}\\right]$   $\\displaystyle u_2 = (1/3)A\\left[\\begin{matrix}- \\frac{\\sqrt{2}}{2}\\\\\\frac{\\sqrt{2}}{2}\\end{matrix}\\right] = \\left[\\begin{array}{c}- \\frac{\\sqrt{2}}{6}\\\\\\frac{\\sqrt{2}}{6}\\\\- \\frac{2 \\sqrt{2}}{3}\\end{array}\\right]$  <pre>\nExtending U with its orthogonal complement.\nBefore RREF: [self]\n</pre>  $\\displaystyle \\left[\\begin{matrix}\\frac{\\sqrt{2}}{2} &amp; \\frac{\\sqrt{2}}{2} &amp; 0\\\\- \\frac{\\sqrt{2}}{6} &amp; \\frac{\\sqrt{2}}{6} &amp; - \\frac{2 \\sqrt{2}}{3}\\end{matrix}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc}1 &amp; 0 &amp; 2\\\\0 &amp; 1 &amp; -2\\end{array}\\right], \\quad\\text{pivots} = (0, 1)\\right\\}$   $\\displaystyle v_1 = \\left[\\begin{array}{c}-2\\\\2\\\\1\\end{array}\\right]$  Out[26]:  $\\left[\\begin{array}{ccc}\\frac{\\sqrt{2}}{2} &amp; - \\frac{\\sqrt{2}}{6} &amp; - \\frac{2}{3}\\\\\\frac{\\sqrt{2}}{2} &amp; \\frac{\\sqrt{2}}{6} &amp; \\frac{2}{3}\\\\0 &amp; - \\frac{2 \\sqrt{2}}{3} &amp; \\frac{1}{3}\\end{array}\\right]\\left[\\begin{array}{cc}5 &amp; 0\\\\0 &amp; 3\\\\0 &amp; 0\\end{array}\\right]\\left[\\begin{array}{cc}\\frac{\\sqrt{2}}{2} &amp; \\frac{\\sqrt{2}}{2}\\\\- \\frac{\\sqrt{2}}{2} &amp; \\frac{\\sqrt{2}}{2}\\end{array}\\right]$  In\u00a0[27]: Copied! <pre># Import the SVD data class to represent the result of SVD\nfrom ma1522 import SVD \n</pre> # Import the SVD data class to represent the result of SVD from ma1522 import SVD  In\u00a0[28]: Copied! <pre># A = U @ S @ V.T\n# A.T = V @ S.T @ U.T\nsvdT = SVD(U=svd.V, S = svd.S.T, V=svd.U)\nsvdT\n</pre> # A = U @ S @ V.T # A.T = V @ S.T @ U.T svdT = SVD(U=svd.V, S = svd.S.T, V=svd.U) svdT Out[28]:  $\\left[\\begin{array}{cc}\\frac{\\sqrt{2}}{2} &amp; - \\frac{\\sqrt{2}}{2}\\\\\\frac{\\sqrt{2}}{2} &amp; \\frac{\\sqrt{2}}{2}\\end{array}\\right]\\left[\\begin{array}{ccc}5 &amp; 0 &amp; 0\\\\0 &amp; 3 &amp; 0\\end{array}\\right]\\left[\\begin{array}{ccc}\\frac{\\sqrt{2}}{2} &amp; \\frac{\\sqrt{2}}{2} &amp; 0\\\\- \\frac{\\sqrt{2}}{6} &amp; \\frac{\\sqrt{2}}{6} &amp; - \\frac{2 \\sqrt{2}}{3}\\\\- \\frac{2}{3} &amp; \\frac{2}{3} &amp; \\frac{1}{3}\\end{array}\\right]$  In\u00a0[29]: Copied! <pre>svdT.eval()\n</pre> svdT.eval() Out[29]:  $\\displaystyle \\left[\\begin{matrix}3 &amp; 2 &amp; 2\\\\2 &amp; 3 &amp; -2\\end{matrix}\\right]$  In\u00a0[30]: Copied! <pre>A = Matrix.from_str(\"1 0 1; 0 1 1; 1 1 2\")\nA\n</pre> A = Matrix.from_str(\"1 0 1; 0 1 1; 1 1 2\") A Out[30]:  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 0 &amp; 1\\\\0 &amp; 1 &amp; 1\\\\1 &amp; 1 &amp; 2\\end{array}\\right]$  In\u00a0[31]: Copied! <pre>A.singular_value_decomposition(verbosity=1)\n</pre> A.singular_value_decomposition(verbosity=1) <pre>A^T A\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc}2 &amp; 1 &amp; 3\\\\1 &amp; 2 &amp; 3\\\\3 &amp; 3 &amp; 6\\end{array}\\right]$  <pre>Check if matrix is symmetric: True\nCharacteristic Polynomial\n</pre>  $\\displaystyle x \\left(x - 9\\right) \\left(x - 1\\right)$   $\\displaystyle \\text{Before RREF: }9\\mathbb{I} - \\mathrm{self}$   $\\displaystyle \\left[\\begin{array}{ccc}7 &amp; -1 &amp; -3\\\\-1 &amp; 7 &amp; -3\\\\-3 &amp; -3 &amp; 3\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc}1 &amp; 0 &amp; - \\frac{1}{2}\\\\0 &amp; 1 &amp; - \\frac{1}{2}\\\\0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1)\\right\\}$  <pre>\nEigenvectors:\n</pre>  $\\displaystyle \\left[ \\left[\\begin{matrix}\\frac{1}{2}\\\\\\frac{1}{2}\\\\1\\end{matrix}\\right]\\right]$  <pre>\n\n</pre>  $\\displaystyle \\text{Before RREF: }1\\mathbb{I} - \\mathrm{self}$   $\\displaystyle \\left[\\begin{array}{ccc}-1 &amp; -1 &amp; -3\\\\-1 &amp; -1 &amp; -3\\\\-3 &amp; -3 &amp; -5\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc}1 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 1\\\\0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 2)\\right\\}$  <pre>\nEigenvectors:\n</pre>  $\\displaystyle \\left[ \\left[\\begin{matrix}-1\\\\1\\\\0\\end{matrix}\\right]\\right]$  <pre>\n\n</pre>  $\\displaystyle \\text{Before RREF: }0\\mathbb{I} - \\mathrm{self}$   $\\displaystyle \\left[\\begin{array}{ccc}-2 &amp; -1 &amp; -3\\\\-1 &amp; -2 &amp; -3\\\\-3 &amp; -3 &amp; -6\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc}1 &amp; 0 &amp; 1\\\\0 &amp; 1 &amp; 1\\\\0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1)\\right\\}$  <pre>\nEigenvectors:\n</pre>  $\\displaystyle \\left[ \\left[\\begin{matrix}-1\\\\-1\\\\1\\end{matrix}\\right]\\right]$  <pre>\n\n</pre>  $\\displaystyle u_1 = (1/3)A\\left[\\begin{matrix}\\frac{\\sqrt{6}}{6}\\\\\\frac{\\sqrt{6}}{6}\\\\\\frac{\\sqrt{6}}{3}\\end{matrix}\\right] = \\left[\\begin{array}{c}\\frac{\\sqrt{6}}{6}\\\\\\frac{\\sqrt{6}}{6}\\\\\\frac{\\sqrt{6}}{3}\\end{array}\\right]$   $\\displaystyle u_2 = (1/1)A\\left[\\begin{matrix}- \\frac{\\sqrt{2}}{2}\\\\\\frac{\\sqrt{2}}{2}\\\\0\\end{matrix}\\right] = \\left[\\begin{array}{c}- \\frac{\\sqrt{2}}{2}\\\\\\frac{\\sqrt{2}}{2}\\\\0\\end{array}\\right]$  <pre>\nExtending U with its orthogonal complement.\nBefore RREF: [self]\n</pre>  $\\displaystyle \\left[\\begin{matrix}\\frac{\\sqrt{6}}{6} &amp; \\frac{\\sqrt{6}}{6} &amp; \\frac{\\sqrt{6}}{3}\\\\- \\frac{\\sqrt{2}}{2} &amp; \\frac{\\sqrt{2}}{2} &amp; 0\\end{matrix}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc}1 &amp; 0 &amp; 1\\\\0 &amp; 1 &amp; 1\\end{array}\\right], \\quad\\text{pivots} = (0, 1)\\right\\}$   $\\displaystyle v_1 = \\left[\\begin{array}{c}-1\\\\-1\\\\1\\end{array}\\right]$  Out[31]:  $\\left[\\begin{array}{ccc}\\frac{\\sqrt{6}}{6} &amp; - \\frac{\\sqrt{2}}{2} &amp; - \\frac{\\sqrt{3}}{3}\\\\\\frac{\\sqrt{6}}{6} &amp; \\frac{\\sqrt{2}}{2} &amp; - \\frac{\\sqrt{3}}{3}\\\\\\frac{\\sqrt{6}}{3} &amp; 0 &amp; \\frac{\\sqrt{3}}{3}\\end{array}\\right]\\left[\\begin{array}{ccc}3 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0\\end{array}\\right]\\left[\\begin{array}{ccc}\\frac{\\sqrt{6}}{6} &amp; \\frac{\\sqrt{6}}{6} &amp; \\frac{\\sqrt{6}}{3}\\\\- \\frac{\\sqrt{2}}{2} &amp; \\frac{\\sqrt{2}}{2} &amp; 0\\\\- \\frac{\\sqrt{3}}{3} &amp; - \\frac{\\sqrt{3}}{3} &amp; \\frac{\\sqrt{3}}{3}\\end{array}\\right]$  In\u00a0[32]: Copied! <pre># OR symmetric -&gt; diagonalize == orthogonally diagonalize == svd\npdp = A.diagonalize(verbosity=1, sort=True)  # This will also work\npdp # Take note that the singular values might not be in the correct order\n</pre> # OR symmetric -&gt; diagonalize == orthogonally diagonalize == svd pdp = A.diagonalize(verbosity=1, sort=True)  # This will also work pdp # Take note that the singular values might not be in the correct order <pre>Characteristic Polynomial\n</pre>  $\\displaystyle x \\left(x - 3\\right) \\left(x - 1\\right)$   $\\displaystyle \\text{Before RREF: }3\\mathbb{I} - \\mathrm{self}$   $\\displaystyle \\left[\\begin{array}{ccc}2 &amp; 0 &amp; -1\\\\0 &amp; 2 &amp; -1\\\\-1 &amp; -1 &amp; 1\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc}1 &amp; 0 &amp; - \\frac{1}{2}\\\\0 &amp; 1 &amp; - \\frac{1}{2}\\\\0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1)\\right\\}$  <pre>\nEigenvectors:\n</pre>  $\\displaystyle \\left[ \\left[\\begin{matrix}\\frac{1}{2}\\\\\\frac{1}{2}\\\\1\\end{matrix}\\right]\\right]$  <pre>\n\n</pre>  $\\displaystyle \\text{Before RREF: }1\\mathbb{I} - \\mathrm{self}$   $\\displaystyle \\left[\\begin{array}{ccc}0 &amp; 0 &amp; -1\\\\0 &amp; 0 &amp; -1\\\\-1 &amp; -1 &amp; -1\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc}1 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 1\\\\0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 2)\\right\\}$  <pre>\nEigenvectors:\n</pre>  $\\displaystyle \\left[ \\left[\\begin{matrix}-1\\\\1\\\\0\\end{matrix}\\right]\\right]$  <pre>\n\n</pre>  $\\displaystyle \\text{Before RREF: }0\\mathbb{I} - \\mathrm{self}$   $\\displaystyle \\left[\\begin{array}{ccc}-1 &amp; 0 &amp; -1\\\\0 &amp; -1 &amp; -1\\\\-1 &amp; -1 &amp; -2\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc}1 &amp; 0 &amp; 1\\\\0 &amp; 1 &amp; 1\\\\0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1)\\right\\}$  <pre>\nEigenvectors:\n</pre>  $\\displaystyle \\left[ \\left[\\begin{matrix}-1\\\\-1\\\\1\\end{matrix}\\right]\\right]$  <pre>\n\n</pre> Out[32]:  $\\left[\\begin{array}{ccc}-1 &amp; -1 &amp; 1\\\\-1 &amp; 1 &amp; 1\\\\1 &amp; 0 &amp; 2\\end{array}\\right]\\left[\\begin{array}{ccc}0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 3\\end{array}\\right]\\left[\\begin{matrix}- \\frac{1}{3} &amp; - \\frac{1}{3} &amp; \\frac{1}{3}\\\\- \\frac{1}{2} &amp; \\frac{1}{2} &amp; 0\\\\\\frac{1}{6} &amp; \\frac{1}{6} &amp; \\frac{1}{3}\\end{matrix}\\right]$  In\u00a0[33]: Copied! <pre># To fix the order, you can use the following trick\norder = [2, 1, 0] # specify the order of singular values as it is\nnewP = pdp.P.select_cols(*order)\ndiag_entries = pdp.D.diagonal()\nnewD = Matrix.diag(*[diag_entries[i] for i in order])\nnewP, newD\n</pre> # To fix the order, you can use the following trick order = [2, 1, 0] # specify the order of singular values as it is newP = pdp.P.select_cols(*order) diag_entries = pdp.D.diagonal() newD = Matrix.diag(*[diag_entries[i] for i in order]) newP, newD Out[33]:  $\\displaystyle \\left( \\left[\\begin{array}{ccc}1 &amp; -1 &amp; -1\\\\1 &amp; 1 &amp; -1\\\\2 &amp; 0 &amp; 1\\end{array}\\right], \\  \\left[\\begin{array}{ccc}3 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0\\end{array}\\right]\\right)$  In\u00a0[34]: Copied! <pre>newP @ newD @ newP.inv()\n</pre> newP @ newD @ newP.inv() Out[34]:  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 0 &amp; 1\\\\0 &amp; 1 &amp; 1\\\\1 &amp; 1 &amp; 2\\end{array}\\right]$  In\u00a0[35]: Copied! <pre>pdpt = A.orthogonally_diagonalize(verbosity=1, sort=True)\npdpt\n</pre> pdpt = A.orthogonally_diagonalize(verbosity=1, sort=True) pdpt <pre>Check if matrix is symmetric: True\nCharacteristic Polynomial\n</pre>  $\\displaystyle x \\left(x - 3\\right) \\left(x - 1\\right)$   $\\displaystyle \\text{Before RREF: }3\\mathbb{I} - \\mathrm{self}$   $\\displaystyle \\left[\\begin{array}{ccc}2 &amp; 0 &amp; -1\\\\0 &amp; 2 &amp; -1\\\\-1 &amp; -1 &amp; 1\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc}1 &amp; 0 &amp; - \\frac{1}{2}\\\\0 &amp; 1 &amp; - \\frac{1}{2}\\\\0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1)\\right\\}$  <pre>\nEigenvectors:\n</pre>  $\\displaystyle \\left[ \\left[\\begin{matrix}\\frac{1}{2}\\\\\\frac{1}{2}\\\\1\\end{matrix}\\right]\\right]$  <pre>\n\n</pre>  $\\displaystyle \\text{Before RREF: }1\\mathbb{I} - \\mathrm{self}$   $\\displaystyle \\left[\\begin{array}{ccc}0 &amp; 0 &amp; -1\\\\0 &amp; 0 &amp; -1\\\\-1 &amp; -1 &amp; -1\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc}1 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 1\\\\0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 2)\\right\\}$  <pre>\nEigenvectors:\n</pre>  $\\displaystyle \\left[ \\left[\\begin{matrix}-1\\\\1\\\\0\\end{matrix}\\right]\\right]$  <pre>\n\n</pre>  $\\displaystyle \\text{Before RREF: }0\\mathbb{I} - \\mathrm{self}$   $\\displaystyle \\left[\\begin{array}{ccc}-1 &amp; 0 &amp; -1\\\\0 &amp; -1 &amp; -1\\\\-1 &amp; -1 &amp; -2\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc}1 &amp; 0 &amp; 1\\\\0 &amp; 1 &amp; 1\\\\0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1)\\right\\}$  <pre>\nEigenvectors:\n</pre>  $\\displaystyle \\left[ \\left[\\begin{matrix}-1\\\\-1\\\\1\\end{matrix}\\right]\\right]$  <pre>\n\n</pre> Out[35]:  $\\left[\\begin{array}{ccc}- \\frac{\\sqrt{3}}{3} &amp; - \\frac{\\sqrt{2}}{2} &amp; \\frac{\\sqrt{6}}{6}\\\\- \\frac{\\sqrt{3}}{3} &amp; \\frac{\\sqrt{2}}{2} &amp; \\frac{\\sqrt{6}}{6}\\\\\\frac{\\sqrt{3}}{3} &amp; 0 &amp; \\frac{\\sqrt{6}}{3}\\end{array}\\right]\\left[\\begin{array}{ccc}0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 3\\end{array}\\right]\\left[\\begin{matrix}- \\frac{\\sqrt{3}}{3} &amp; - \\frac{\\sqrt{3}}{3} &amp; \\frac{\\sqrt{3}}{3}\\\\- \\frac{\\sqrt{2}}{2} &amp; \\frac{\\sqrt{2}}{2} &amp; 0\\\\\\frac{\\sqrt{6}}{6} &amp; \\frac{\\sqrt{6}}{6} &amp; \\frac{\\sqrt{6}}{3}\\end{matrix}\\right]$  In\u00a0[36]: Copied! <pre># Similar to diagonalization, the singular values are \n# not guaranteed to be in the correct order\norder = [2, 1, 0] # specify the order of singular values as it is\nnewP = pdpt.P.select_cols(*order)\ndiag_entries = pdpt.D.diagonal()\nnewD = Matrix.diag(*[diag_entries[i] for i in order])\nnewP, newD\n</pre> # Similar to diagonalization, the singular values are  # not guaranteed to be in the correct order order = [2, 1, 0] # specify the order of singular values as it is newP = pdpt.P.select_cols(*order) diag_entries = pdpt.D.diagonal() newD = Matrix.diag(*[diag_entries[i] for i in order]) newP, newD Out[36]:  $\\displaystyle \\left( \\left[\\begin{array}{ccc}\\frac{\\sqrt{6}}{6} &amp; - \\frac{\\sqrt{2}}{2} &amp; - \\frac{\\sqrt{3}}{3}\\\\\\frac{\\sqrt{6}}{6} &amp; \\frac{\\sqrt{2}}{2} &amp; - \\frac{\\sqrt{3}}{3}\\\\\\frac{\\sqrt{6}}{3} &amp; 0 &amp; \\frac{\\sqrt{3}}{3}\\end{array}\\right], \\  \\left[\\begin{array}{ccc}3 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0\\end{array}\\right]\\right)$  In\u00a0[37]: Copied! <pre>newP @ newD @ newP.T\n</pre> newP @ newD @ newP.T Out[37]:  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; 0 &amp; 1\\\\0 &amp; 1 &amp; 1\\\\1 &amp; 1 &amp; 2\\end{array}\\right]$  In\u00a0[38]: Copied! <pre>A = Matrix.from_str(\"-18 13 -4 4; 2 19 -4 12; -14 11 -12 8; -2 21 4 8\")\nA\n</pre> A = Matrix.from_str(\"-18 13 -4 4; 2 19 -4 12; -14 11 -12 8; -2 21 4 8\") A Out[38]:  $\\displaystyle \\left[\\begin{array}{cccc}-18 &amp; 13 &amp; -4 &amp; 4\\\\2 &amp; 19 &amp; -4 &amp; 12\\\\-14 &amp; 11 &amp; -12 &amp; 8\\\\-2 &amp; 21 &amp; 4 &amp; 8\\end{array}\\right]$  In\u00a0[39]: Copied! <pre>A.singular_value_decomposition(verbosity=1)\n</pre> A.singular_value_decomposition(verbosity=1) <pre>A^T A\n</pre>  $\\displaystyle \\left[\\begin{array}{cccc}528 &amp; -392 &amp; 224 &amp; -176\\\\-392 &amp; 1092 &amp; -176 &amp; 536\\\\224 &amp; -176 &amp; 192 &amp; -128\\\\-176 &amp; 536 &amp; -128 &amp; 288\\end{array}\\right]$  <pre>Check if matrix is symmetric: True\nCharacteristic Polynomial\n</pre>  $\\displaystyle x \\left(x - 1600\\right) \\left(x - 400\\right) \\left(x - 100\\right)$   $\\displaystyle \\text{Before RREF: }1600\\mathbb{I} - \\mathrm{self}$   $\\displaystyle \\left[\\begin{array}{cccc}1072 &amp; 392 &amp; -224 &amp; 176\\\\392 &amp; 508 &amp; 176 &amp; -536\\\\-224 &amp; 176 &amp; 1408 &amp; 128\\\\176 &amp; -536 &amp; 128 &amp; 1312\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; 1\\\\0 &amp; 1 &amp; 0 &amp; -2\\\\0 &amp; 0 &amp; 1 &amp; \\frac{1}{2}\\\\0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 2)\\right\\}$  <pre>\nEigenvectors:\n</pre>  $\\displaystyle \\left[ \\left[\\begin{matrix}-1\\\\2\\\\- \\frac{1}{2}\\\\1\\end{matrix}\\right]\\right]$  <pre>\n\n</pre>  $\\displaystyle \\text{Before RREF: }400\\mathbb{I} - \\mathrm{self}$   $\\displaystyle \\left[\\begin{array}{cccc}-128 &amp; 392 &amp; -224 &amp; 176\\\\392 &amp; -692 &amp; 176 &amp; -536\\\\-224 &amp; 176 &amp; 208 &amp; 128\\\\176 &amp; -536 &amp; 128 &amp; 112\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; -4\\\\0 &amp; 1 &amp; 0 &amp; -2\\\\0 &amp; 0 &amp; 1 &amp; -2\\\\0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 2)\\right\\}$  <pre>\nEigenvectors:\n</pre>  $\\displaystyle \\left[ \\left[\\begin{matrix}4\\\\2\\\\2\\\\1\\end{matrix}\\right]\\right]$  <pre>\n\n</pre>  $\\displaystyle \\text{Before RREF: }100\\mathbb{I} - \\mathrm{self}$   $\\displaystyle \\left[\\begin{array}{cccc}-428 &amp; 392 &amp; -224 &amp; 176\\\\392 &amp; -992 &amp; 176 &amp; -536\\\\-224 &amp; 176 &amp; -92 &amp; 128\\\\176 &amp; -536 &amp; 128 &amp; -188\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; -1\\\\0 &amp; 1 &amp; 0 &amp; \\frac{1}{2}\\\\0 &amp; 0 &amp; 1 &amp; 2\\\\0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 2)\\right\\}$  <pre>\nEigenvectors:\n</pre>  $\\displaystyle \\left[ \\left[\\begin{matrix}1\\\\- \\frac{1}{2}\\\\-2\\\\1\\end{matrix}\\right]\\right]$  <pre>\n\n</pre>  $\\displaystyle \\text{Before RREF: }0\\mathbb{I} - \\mathrm{self}$   $\\displaystyle \\left[\\begin{array}{cccc}-528 &amp; 392 &amp; -224 &amp; 176\\\\392 &amp; -1092 &amp; 176 &amp; -536\\\\-224 &amp; 176 &amp; -192 &amp; 128\\\\176 &amp; -536 &amp; 128 &amp; -288\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; \\frac{1}{4}\\\\0 &amp; 1 &amp; 0 &amp; \\frac{1}{2}\\\\0 &amp; 0 &amp; 1 &amp; - \\frac{1}{2}\\\\0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 2)\\right\\}$  <pre>\nEigenvectors:\n</pre>  $\\displaystyle \\left[ \\left[\\begin{matrix}- \\frac{1}{4}\\\\- \\frac{1}{2}\\\\\\frac{1}{2}\\\\1\\end{matrix}\\right]\\right]$  <pre>\n\n</pre>  $\\displaystyle u_1 = (1/40)A\\left[\\begin{matrix}- \\frac{2}{5}\\\\\\frac{4}{5}\\\\- \\frac{1}{5}\\\\\\frac{2}{5}\\end{matrix}\\right] = \\left[\\begin{array}{c}\\frac{1}{2}\\\\\\frac{1}{2}\\\\\\frac{1}{2}\\\\\\frac{1}{2}\\end{array}\\right]$   $\\displaystyle u_2 = (1/20)A\\left[\\begin{matrix}\\frac{4}{5}\\\\\\frac{2}{5}\\\\\\frac{2}{5}\\\\\\frac{1}{5}\\end{matrix}\\right] = \\left[\\begin{array}{c}- \\frac{1}{2}\\\\\\frac{1}{2}\\\\- \\frac{1}{2}\\\\\\frac{1}{2}\\end{array}\\right]$   $\\displaystyle u_3 = (1/10)A\\left[\\begin{matrix}\\frac{2}{5}\\\\- \\frac{1}{5}\\\\- \\frac{4}{5}\\\\\\frac{2}{5}\\end{matrix}\\right] = \\left[\\begin{array}{c}- \\frac{1}{2}\\\\\\frac{1}{2}\\\\\\frac{1}{2}\\\\- \\frac{1}{2}\\end{array}\\right]$  <pre>\nExtending U with its orthogonal complement.\nBefore RREF: [self]\n</pre>  $\\displaystyle \\left[\\begin{matrix}\\frac{1}{2} &amp; \\frac{1}{2} &amp; \\frac{1}{2} &amp; \\frac{1}{2}\\\\- \\frac{1}{2} &amp; \\frac{1}{2} &amp; - \\frac{1}{2} &amp; \\frac{1}{2}\\\\- \\frac{1}{2} &amp; \\frac{1}{2} &amp; \\frac{1}{2} &amp; - \\frac{1}{2}\\end{matrix}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; 1\\\\0 &amp; 1 &amp; 0 &amp; 1\\\\0 &amp; 0 &amp; 1 &amp; -1\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 2)\\right\\}$   $\\displaystyle v_1 = \\left[\\begin{array}{c}-1\\\\-1\\\\1\\\\1\\end{array}\\right]$  Out[39]:  $\\left[\\begin{array}{cccc}\\frac{1}{2} &amp; - \\frac{1}{2} &amp; - \\frac{1}{2} &amp; - \\frac{1}{2}\\\\\\frac{1}{2} &amp; \\frac{1}{2} &amp; \\frac{1}{2} &amp; - \\frac{1}{2}\\\\\\frac{1}{2} &amp; - \\frac{1}{2} &amp; \\frac{1}{2} &amp; \\frac{1}{2}\\\\\\frac{1}{2} &amp; \\frac{1}{2} &amp; - \\frac{1}{2} &amp; \\frac{1}{2}\\end{array}\\right]\\left[\\begin{array}{cccc}40 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 20 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 10 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0\\end{array}\\right]\\left[\\begin{array}{cccc}- \\frac{2}{5} &amp; \\frac{4}{5} &amp; - \\frac{1}{5} &amp; \\frac{2}{5}\\\\\\frac{4}{5} &amp; \\frac{2}{5} &amp; \\frac{2}{5} &amp; \\frac{1}{5}\\\\\\frac{2}{5} &amp; - \\frac{1}{5} &amp; - \\frac{4}{5} &amp; \\frac{2}{5}\\\\- \\frac{1}{5} &amp; - \\frac{2}{5} &amp; \\frac{2}{5} &amp; \\frac{4}{5}\\end{array}\\right]$"},{"location":"tutorials/tut10/#tutorial-10-ay2425-sem-1","title":"Tutorial 10 (AY24/25 Sem 1)\u00b6","text":""},{"location":"tutorials/tut10/#question-1","title":"Question 1\u00b6","text":"<p>A population of ants is put into a maze with 3 compartments labeled $a$, $b$, and $c$. If the ant is in compartment $a$, an hour later, there is a 20% chance it will go to compartment $b$, and a 40% chance it will go to compartment $c$. If it is in compartment $b$, an hour later, there is a 10% chance it will go to compartment $a$, and a 30% chance it will go to compartment $c$. If it is in compartment $c$, an hour later, there is a 50% chance it will go to compartment $a$, and a 20% chance it will go to compartment $b$. Suppose 100 ants have been placed in compartment $a$.</p>"},{"location":"tutorials/tut10/#a","title":"(a)\u00b6","text":"<p>Find the transition probability matrix $\\mathbf{A}$. Show that it is a stochastic matrix.</p>"},{"location":"tutorials/tut10/#b","title":"(b)\u00b6","text":"<p>By diagonalizing $\\mathbf{A}$, find the number of ants in each compartment after 3 hours.</p>"},{"location":"tutorials/tut10/#d","title":"(d)\u00b6","text":"<p>In the long run (assuming no ants died), where will the majority of the ants be?</p>"},{"location":"tutorials/tut10/#e","title":"(e)\u00b6","text":"<p>Suppose initially the numbers of ants in compartments a, b and c are $\\alpha$, $\\beta$, and $\\gamma$ respectively. What is the population distribution in the long run (assuming no ants died)?</p>"},{"location":"tutorials/tut10/#question-2","title":"Question 2\u00b6","text":"<p>By diagonalizing $\\mathbf{A} = \\begin{pmatrix} 1 &amp; 0 &amp; 3 \\\\ 0 &amp; 4 &amp; 0 \\\\ 0 &amp; 0 &amp; 4 \\end{pmatrix}$, find a matrix $\\mathbf{B}$ such that $\\mathbf{B}^2 = \\mathbf{A}$.</p>"},{"location":"tutorials/tut10/#problem-3","title":"Problem 3\u00b6","text":"<p>For each of the following symmetric matrices $\\mathbf{A}$, find an orthogonal matrix $\\mathbf{P}$ that orthogonally diagonalizes $\\mathbf{A}$.</p>"},{"location":"tutorials/tut10/#a","title":"(a)\u00b6","text":"<p>$\\mathbf{A} = \\begin{pmatrix} 3 &amp; 1 \\\\ 1 &amp; 3 \\end{pmatrix}$</p>"},{"location":"tutorials/tut10/#b","title":"(b)\u00b6","text":"<p>$\\mathbf{A} = \\begin{pmatrix} 2 &amp; 2 &amp; -2 \\\\ 2 &amp; -1 &amp; 4 \\\\ -2 &amp; 4 &amp; -1 \\end{pmatrix}$</p>"},{"location":"tutorials/tut10/#question-4","title":"Question 4\u00b6","text":"<p>Let $\\mathbf{A} = \\begin{pmatrix} 1 &amp; -2 &amp; 0 &amp; 0 \\\\ -2 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; -2 \\\\ 0 &amp; 0 &amp; -2 &amp; 1 \\end{pmatrix}$.</p>"},{"location":"tutorials/tut10/#a","title":"(a)\u00b6","text":"<p>Find an orthogonal matrix $\\mathbf{P}$ that orthogonally diagonalizes $\\mathbf{A}$, and compute $\\mathbf{P}^T \\mathbf{A} \\mathbf{P}$.</p>"},{"location":"tutorials/tut10/#question-5","title":"Question 5\u00b6","text":"<p>Find the SVD of the following matrices $\\mathbf{A}$.</p>"},{"location":"tutorials/tut10/#a","title":"(a)\u00b6","text":"<p>$\\mathbf{A} = \\begin{pmatrix} 3 &amp; 2 \\\\ 2 &amp; 3 \\\\ 2 &amp; -2 \\end{pmatrix}$</p>"},{"location":"tutorials/tut10/#b","title":"(b)\u00b6","text":"<p>$\\mathbf{A} = \\begin{pmatrix} 3 &amp; 2 &amp; 2 \\\\ 2 &amp; 3 &amp; -2 \\end{pmatrix}$</p>"},{"location":"tutorials/tut10/#c","title":"(c)\u00b6","text":"<p>$\\mathbf{A} = \\begin{pmatrix} 1 &amp; 0 &amp; 1 \\\\ 0 &amp; 1 &amp; 1 \\\\ 1 &amp; 1 &amp; 2 \\end{pmatrix}$</p>"},{"location":"tutorials/tut10/#question-6","title":"Question 6\u00b6","text":"<p>Let $\\mathbf{A} = \\begin{pmatrix} -18 &amp; 13 &amp; -4 &amp; 4 \\\\ 2 &amp; 19 &amp; -4 &amp; 12 \\\\ -14 &amp; 11 &amp; -12 &amp; 8 \\\\ -2 &amp; 21 &amp; 4 &amp; 8 \\end{pmatrix}$.</p>"},{"location":"tutorials/tut10/#a","title":"(a)\u00b6","text":"<p>Find a SVD of $\\mathbf{A}$.</p>"},{"location":"tutorials/tut11/","title":"Tutorial 11","text":"In\u00a0[1]: Copied! <pre># Required imports\nimport sympy as sym\nfrom ma1522 import Matrix\n</pre> # Required imports import sympy as sym from ma1522 import Matrix In\u00a0[2]: Copied! <pre>in_vec = Matrix.from_str(\"x; y\")\nout_vec = Matrix.from_str(\"x+y; y-x\")\n\nin_vec, out_vec\n</pre> in_vec = Matrix.from_str(\"x; y\") out_vec = Matrix.from_str(\"x+y; y-x\")  in_vec, out_vec Out[2]:  $\\displaystyle \\left( \\left[\\begin{array}{c}x\\\\y\\end{array}\\right], \\  \\left[\\begin{array}{c}x + y\\\\- x + y\\end{array}\\right]\\right)$  In\u00a0[3]: Copied! <pre>mat = in_vec.standard_matrix(out_vec, matrices=1)\nmat # Double brackets indicates its a list of 1 matrix, i.e. unique solution\n</pre> mat = in_vec.standard_matrix(out_vec, matrices=1) mat # Double brackets indicates its a list of 1 matrix, i.e. unique solution Out[3]:  $\\displaystyle \\left[ \\left[\\begin{array}{cc}1 &amp; 1\\\\-1 &amp; 1\\end{array}\\right]\\right]$  In\u00a0[4]: Copied! <pre>mat[0].columnspace()\n</pre> mat[0].columnspace() Out[4]:  $\\displaystyle \\left[ \\left[\\begin{matrix}1\\\\-1\\end{matrix}\\right], \\  \\left[\\begin{matrix}1\\\\1\\end{matrix}\\right]\\right]$  In\u00a0[5]: Copied! <pre>mat[0].nullspace()\n</pre> mat[0].nullspace() Out[5]:  $\\displaystyle \\left[ \\right]$  In\u00a0[6]: Copied! <pre>in_vec = Matrix.from_str(\"x; y\")\nout_vec = Matrix.from_str(\"2**x; 0\")\n\nin_vec, out_vec\n</pre> in_vec = Matrix.from_str(\"x; y\") out_vec = Matrix.from_str(\"2**x; 0\")  in_vec, out_vec Out[6]:  $\\displaystyle \\left( \\left[\\begin{array}{c}x\\\\y\\end{array}\\right], \\  \\left[\\begin{array}{c}2^{x}\\\\0\\end{array}\\right]\\right)$  In\u00a0[7]: Copied! <pre>try: \n    in_vec.standard_matrix(out_vec, matrices=1)\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n</pre> try:      in_vec.standard_matrix(out_vec, matrices=1) except ValueError as e:     print(f\"Error: {e}\") <pre>Error: No solution found for the standard matrix. This may indicate that the transformation is not linear.\n</pre> In\u00a0[8]: Copied! <pre>in_vec = Matrix.from_str(\"x; y\")\nout_vec = Matrix.from_str(\"x+y; 0; 0\")\n\nin_vec, out_vec\n</pre> in_vec = Matrix.from_str(\"x; y\") out_vec = Matrix.from_str(\"x+y; 0; 0\")  in_vec, out_vec Out[8]:  $\\displaystyle \\left( \\left[\\begin{array}{c}x\\\\y\\end{array}\\right], \\  \\left[\\begin{array}{c}x + y\\\\0\\\\0\\end{array}\\right]\\right)$  In\u00a0[9]: Copied! <pre>mat = in_vec.standard_matrix(out_vec, matrices=1)\nmat\n</pre> mat = in_vec.standard_matrix(out_vec, matrices=1) mat Out[9]:  $\\displaystyle \\left[ \\left[\\begin{array}{cc}1 &amp; 1\\\\0 &amp; 0\\\\0 &amp; 0\\end{array}\\right]\\right]$  In\u00a0[10]: Copied! <pre>mat[0].columnspace()\n</pre> mat[0].columnspace() Out[10]:  $\\displaystyle \\left[ \\left[\\begin{matrix}1\\\\0\\\\0\\end{matrix}\\right]\\right]$  In\u00a0[11]: Copied! <pre>mat[0].nullspace()\n</pre> mat[0].nullspace() Out[11]:  $\\displaystyle \\left[ \\left[\\begin{matrix}-1\\\\1\\end{matrix}\\right]\\right]$  In\u00a0[12]: Copied! <pre>in_vec = Matrix.from_str(\"x; y; z\")\nout_vec = Matrix.from_str(\"1; y-x; y-z\")\n\nin_vec, out_vec\n</pre> in_vec = Matrix.from_str(\"x; y; z\") out_vec = Matrix.from_str(\"1; y-x; y-z\")  in_vec, out_vec Out[12]:  $\\displaystyle \\left( \\left[\\begin{array}{c}x\\\\y\\\\z\\end{array}\\right], \\  \\left[\\begin{array}{c}1\\\\- x + y\\\\y - z\\end{array}\\right]\\right)$  In\u00a0[13]: Copied! <pre>try:\n    mat = in_vec.standard_matrix(out_vec, matrices=1)\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n</pre> try:     mat = in_vec.standard_matrix(out_vec, matrices=1) except ValueError as e:     print(f\"Error: {e}\") <pre>Error: No solution found for the standard matrix. This may indicate that the transformation is not linear.\n</pre> In\u00a0[14]: Copied! <pre>in_vec = Matrix.create_unk_matrix(5, 1, \"x\", is_real=True)\nout_vec = Matrix.from_str(\"x3 + 2*x4 - x5\", col_sep=\"?\", is_real=True)\n\nin_vec, out_vec\n</pre> in_vec = Matrix.create_unk_matrix(5, 1, \"x\", is_real=True) out_vec = Matrix.from_str(\"x3 + 2*x4 - x5\", col_sep=\"?\", is_real=True)  in_vec, out_vec Out[14]:  $\\displaystyle \\left( \\left[\\begin{array}{c}x_{1}\\\\x_{2}\\\\x_{3}\\\\x_{4}\\\\x_{5}\\end{array}\\right], \\  \\left[\\begin{array}{c}x_{3} + 2 x_{4} - x_{5}\\end{array}\\right]\\right)$  In\u00a0[15]: Copied! <pre>in_vec.standard_matrix(out_vec, matrices=1)\n</pre> in_vec.standard_matrix(out_vec, matrices=1) Out[15]:  $\\displaystyle \\left[ \\left[\\begin{array}{ccccc}0 &amp; 0 &amp; 1 &amp; 2 &amp; -1\\end{array}\\right]\\right]$  In\u00a0[16]: Copied! <pre>mat[0].columnspace()\n</pre> mat[0].columnspace() Out[16]:  $\\displaystyle \\left[ \\left[\\begin{matrix}1\\\\0\\\\0\\end{matrix}\\right]\\right]$  In\u00a0[17]: Copied! <pre>mat[0].nullspace()\n</pre> mat[0].nullspace() Out[17]:  $\\displaystyle \\left[ \\left[\\begin{matrix}-1\\\\1\\end{matrix}\\right]\\right]$  In\u00a0[18]: Copied! <pre>x = Matrix.create_unk_matrix(3, 1) # set n=3\nx, x.dot(x)\n</pre> x = Matrix.create_unk_matrix(3, 1) # set n=3 x, x.dot(x) Out[18]:  $\\displaystyle \\left( \\left[\\begin{array}{c}x\\\\y\\\\z\\end{array}\\right], \\  x^{2} + y^{2} + z^{2}\\right)$  In\u00a0[19]: Copied! <pre># Wrap `x.dot(x)` in a matrix so that it can be \n# used with `standard_matrix`\ntry:\n    mat = x.standard_matrix(Matrix([x.dot(x)]), matrices=1)\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n</pre> # Wrap `x.dot(x)` in a matrix so that it can be  # used with `standard_matrix` try:     mat = x.standard_matrix(Matrix([x.dot(x)]), matrices=1) except ValueError as e:     print(f\"Error: {e}\") <pre>Error: No solution found for the standard matrix. This may indicate that the transformation is not linear.\n</pre> In\u00a0[20]: Copied! <pre>F_in = Matrix.from_str(\"x1; x2; x3\")\nF_out = Matrix.from_str(\"x1 - 2*x2; x1 + x2 - 3*x3; 5*x2 - x3\", col_sep=\"?\")\n\nF_in, F_out\n</pre> F_in = Matrix.from_str(\"x1; x2; x3\") F_out = Matrix.from_str(\"x1 - 2*x2; x1 + x2 - 3*x3; 5*x2 - x3\", col_sep=\"?\")  F_in, F_out  Out[20]:  $\\displaystyle \\left( \\left[\\begin{array}{c}x_{1}\\\\x_{2}\\\\x_{3}\\end{array}\\right], \\  \\left[\\begin{array}{c}x_{1} - 2 x_{2}\\\\x_{1} + x_{2} - 3 x_{3}\\\\5 x_{2} - x_{3}\\end{array}\\right]\\right)$  In\u00a0[21]: Copied! <pre>A_F = F_in.standard_matrix(F_out, matrices=1)[0]\nA_F\n</pre> A_F = F_in.standard_matrix(F_out, matrices=1)[0] A_F Out[21]:  $\\displaystyle \\left[\\begin{array}{ccc}1 &amp; -2 &amp; 0\\\\1 &amp; 1 &amp; -3\\\\0 &amp; 5 &amp; -1\\end{array}\\right]$  In\u00a0[22]: Copied! <pre>G_in = Matrix.from_str(\"x1; x2; x3\")\nG_out = Matrix.from_str(\"x3 - x1; x2 + 5*x1; x1 + x2 + x3\", col_sep=\"?\")\n\nG_in, G_out\n</pre> G_in = Matrix.from_str(\"x1; x2; x3\") G_out = Matrix.from_str(\"x3 - x1; x2 + 5*x1; x1 + x2 + x3\", col_sep=\"?\")  G_in, G_out Out[22]:  $\\displaystyle \\left( \\left[\\begin{array}{c}x_{1}\\\\x_{2}\\\\x_{3}\\end{array}\\right], \\  \\left[\\begin{array}{c}- x_{1} + x_{3}\\\\5 x_{1} + x_{2}\\\\x_{1} + x_{2} + x_{3}\\end{array}\\right]\\right)$  In\u00a0[23]: Copied! <pre>B_G = G_in.standard_matrix(G_out, matrices=1)[0]\nB_G\n</pre> B_G = G_in.standard_matrix(G_out, matrices=1)[0] B_G Out[23]:  $\\displaystyle \\left[\\begin{array}{ccc}-1 &amp; 0 &amp; 1\\\\5 &amp; 1 &amp; 0\\\\1 &amp; 1 &amp; 1\\end{array}\\right]$  In\u00a0[24]: Copied! <pre># Composition of function is the composition of their standard matrices\nA_F @ B_G\n</pre> # Composition of function is the composition of their standard matrices A_F @ B_G Out[24]:  $\\displaystyle \\left[\\begin{array}{ccc}-11 &amp; -2 &amp; 1\\\\1 &amp; -2 &amp; -2\\\\24 &amp; 4 &amp; -1\\end{array}\\right]$  In\u00a0[25]: Copied! <pre>H = B_G.inverse(verbosity=2)\nH\n</pre> H = B_G.inverse(verbosity=2) H <pre>Left inverse found!\nRight inverse found!\nBefore RREF: [self | eye]\n</pre>  $\\displaystyle \\left[\\begin{array}{ccc|c|c|c}-1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0\\\\5 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0\\\\1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1\\end{array}\\right]$  <pre>\nAfter RREF:\n</pre>  $\\text{RREF}\\left\\{\\text{rref} = \\left[\\begin{array}{ccc|c|c|c}1 &amp; 0 &amp; 0 &amp; \\frac{1}{3} &amp; \\frac{1}{3} &amp; - \\frac{1}{3}\\\\0 &amp; 1 &amp; 0 &amp; - \\frac{5}{3} &amp; - \\frac{2}{3} &amp; \\frac{5}{3}\\\\0 &amp; 0 &amp; 1 &amp; \\frac{4}{3} &amp; \\frac{1}{3} &amp; - \\frac{1}{3}\\end{array}\\right], \\quad\\text{pivots} = (0, 1, 2)\\right\\}$  Out[25]:  $\\displaystyle \\left[\\begin{array}{ccc}\\frac{1}{3} &amp; \\frac{1}{3} &amp; - \\frac{1}{3}\\\\- \\frac{5}{3} &amp; - \\frac{2}{3} &amp; \\frac{5}{3}\\\\\\frac{4}{3} &amp; \\frac{1}{3} &amp; - \\frac{1}{3}\\end{array}\\right]$  In\u00a0[26]: Copied! <pre>T_in = Matrix.eye(3)\nT_out = Matrix.from_str(\"1 3 0 1; 2 2 -1 4; 0 4 1 6\").T\n\nT_in, T_out\n</pre> T_in = Matrix.eye(3) T_out = Matrix.from_str(\"1 3 0 1; 2 2 -1 4; 0 4 1 6\").T  T_in, T_out Out[26]:  $\\displaystyle \\left( \\left[\\begin{array}{ccc}1 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 1\\end{array}\\right], \\  \\left[\\begin{array}{ccc}1 &amp; 2 &amp; 0\\\\3 &amp; 2 &amp; 4\\\\0 &amp; -1 &amp; 1\\\\1 &amp; 4 &amp; 6\\end{array}\\right]\\right)$  In\u00a0[27]: Copied! <pre>mat = T_in.standard_matrix(T_out, matrices=1)\nmat\n</pre> mat = T_in.standard_matrix(T_out, matrices=1) mat Out[27]:  $\\displaystyle \\left[ \\left[\\begin{array}{ccc}1 &amp; 2 &amp; 0\\\\3 &amp; 2 &amp; 4\\\\0 &amp; -1 &amp; 1\\\\1 &amp; 4 &amp; 6\\end{array}\\right]\\right]$  In\u00a0[28]: Copied! <pre>T_in = Matrix.from_str(\"1 -1; 1 1; 2 0\").T\nT_out = Matrix.from_str(\"2 0; 0 2; 2 2\").T\n\nT_in, T_out\n</pre> T_in = Matrix.from_str(\"1 -1; 1 1; 2 0\").T T_out = Matrix.from_str(\"2 0; 0 2; 2 2\").T  T_in, T_out Out[28]:  $\\displaystyle \\left( \\left[\\begin{array}{ccc}1 &amp; 1 &amp; 2\\\\-1 &amp; 1 &amp; 0\\end{array}\\right], \\  \\left[\\begin{array}{ccc}2 &amp; 0 &amp; 2\\\\0 &amp; 2 &amp; 2\\end{array}\\right]\\right)$  In\u00a0[29]: Copied! <pre>mat = T_in.standard_matrix(T_out, matrices=1)\nmat\n</pre> mat = T_in.standard_matrix(T_out, matrices=1) mat Out[29]:  $\\displaystyle \\left[ \\left[\\begin{array}{cc}1 &amp; -1\\\\1 &amp; 1\\end{array}\\right]\\right]$  In\u00a0[30]: Copied! <pre>T_in = Matrix.from_str(\"1 -1 0; 0 1 -1; -1 0 1\").T\nT_out = Matrix.from_str(\"-1 1 0\")\n\nT_in, T_out\n</pre> T_in = Matrix.from_str(\"1 -1 0; 0 1 -1; -1 0 1\").T T_out = Matrix.from_str(\"-1 1 0\")  T_in, T_out Out[30]:  $\\displaystyle \\left( \\left[\\begin{array}{ccc}1 &amp; 0 &amp; -1\\\\-1 &amp; 1 &amp; 0\\\\0 &amp; -1 &amp; 1\\end{array}\\right], \\  \\left[\\begin{array}{ccc}-1 &amp; 1 &amp; 0\\end{array}\\right]\\right)$  In\u00a0[31]: Copied! <pre>mat = T_in.standard_matrix(T_out, matrices=1)\nmat # free parameters in the solution means its not unique\n</pre> mat = T_in.standard_matrix(T_out, matrices=1) mat # free parameters in the solution means its not unique Out[31]:  $\\displaystyle \\left[ \\left[\\begin{array}{ccc}x_{1,3} &amp; x_{1,3} + 1 &amp; x_{1,3}\\end{array}\\right]\\right]$"},{"location":"tutorials/tut11/#tutorial-11-ay2425-sem-1","title":"Tutorial 11 (AY24/25 Sem 1)\u00b6","text":""},{"location":"tutorials/tut11/#question-1","title":"Question 1\u00b6","text":"<p>For each of the following:</p> <p>(i) Determine whether the following are linear transformations.</p> <p>(ii) Write down the standard matrix for each of the linear transformations.</p> <p>(iii) Find a basis for the range for each of the linear transformations.</p> <p>(iv) Find a basis for the kernel for each of the linear transformations.</p>"},{"location":"tutorials/tut11/#a","title":"(a)\u00b6","text":"<p>$T_1 : \\mathbb{R}^2 \\to \\mathbb{R}^2$ such that $T_1\\begin{pmatrix} x \\\\ y \\end{pmatrix} = \\begin{pmatrix} x + y \\\\ y - x \\end{pmatrix}$ for $\\begin{pmatrix} x \\\\ y \\end{pmatrix} \\in \\mathbb{R}^2$.</p>"},{"location":"tutorials/tut11/#b","title":"(b)\u00b6","text":"<p>$T_2 : \\mathbb{R}^2 \\to \\mathbb{R}^2$ such that $T_2\\begin{pmatrix} x \\\\ y \\end{pmatrix} = \\begin{pmatrix} 2^x \\\\ 0 \\end{pmatrix}$ for $\\begin{pmatrix} x \\\\ y \\end{pmatrix} \\in \\mathbb{R}^2$.</p>"},{"location":"tutorials/tut11/#c","title":"(c)\u00b6","text":"<p>$T_3 : \\mathbb{R}^2 \\to \\mathbb{R}^3$ such that $T_3\\begin{pmatrix} x \\\\ y \\end{pmatrix} = \\begin{pmatrix} x + y \\\\ 0 \\\\ 0 \\end{pmatrix}$ for $\\begin{pmatrix} x \\\\ y \\end{pmatrix} \\in \\mathbb{R}^2$.</p>"},{"location":"tutorials/tut11/#d","title":"(d)\u00b6","text":"<p>$T_4 : \\mathbb{R}^3 \\to \\mathbb{R}^3$ such that $T_4\\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ y - x \\\\ y - z \\end{pmatrix}$ for $\\begin{pmatrix} x \\ y \\ z \\end{pmatrix} \\in \\mathbb{R}^3$.</p>"},{"location":"tutorials/tut11/#e","title":"(e)\u00b6","text":"<p>$T_5 : \\mathbb{R}^5 \\to \\mathbb{R}$ such that $T_5\\begin{pmatrix} x_1 \\\\ \\vdots \\\\ x_5 \\end{pmatrix} = x_3 + 2x_4 - x_5$ for $\\begin{pmatrix} x_1 \\\\ \\vdots \\\\ x_5 \\end{pmatrix} \\in \\mathbb{R}^5$.</p>"},{"location":"tutorials/tut11/#f","title":"(f)\u00b6","text":"<p>$T_6 : \\mathbb{R}^n \\to \\mathbb{R}$ such that $T_6(\\mathbf{x}) = \\mathbf{x} \\cdot \\mathbf{x}$ for $\\mathbf{x} \\in \\mathbb{R}^n$.</p>"},{"location":"tutorials/tut11/#question-2","title":"Question 2\u00b6","text":"<p>Let $F : \\mathbb{R}^3 \\to \\mathbb{R}^3$ and $G : \\mathbb{R}^3 \\to \\mathbb{R}^3$ be linear transformations such that</p> <p>$$F\\left( \\begin{pmatrix} x_1 \\\\ x_2 \\\\ x_3 \\end{pmatrix} \\right) = \\begin{pmatrix} x_1 - 2x_2 \\\\ x_1 + x_2 - 3x_3 \\\\ 5x_2 - x_3 \\end{pmatrix} \\quad \\text{and} \\quad G\\left( \\begin{pmatrix} x_1 \\\\ x_2 \\\\ x_3 \\end{pmatrix} \\right) = \\begin{pmatrix} x_3 - x_1 \\\\ x_2 + 5x_1 \\\\ x_1 + x_2 + x_3 \\end{pmatrix}$$</p> <p>and let $\\mathbf{A}_F$ and $\\mathbf{B}_G$ be the standard matrix of $F$ and $G$, respectively.</p>"},{"location":"tutorials/tut11/#a","title":"(a)\u00b6","text":"<p>Find $\\mathbf{A}_F$ and $\\mathbf{B}_G$.</p>"},{"location":"tutorials/tut11/#c","title":"(c)\u00b6","text":"<p>Write down the formula for $F(G(\\mathbf{x}))$ and find its standard matrix.</p>"},{"location":"tutorials/tut11/#d","title":"(d)\u00b6","text":"<p>Find a linear transformation $H : \\mathbb{R}^3 \\to \\mathbb{R}^3$ such that $H(G(\\mathbf{x})) = \\mathbf{x}$, for all $\\mathbf{x} \\in \\mathbb{R}^3$.</p>"},{"location":"tutorials/tut11/#question-3","title":"Question 3\u00b6","text":"<p>For each of the following linear transformations, (i) determine whether there is enough information for us to find the formula of $T$; and (ii) find the formula and the standard matrix for $T$ if possible.</p>"},{"location":"tutorials/tut11/#a","title":"(a)\u00b6","text":"<p>$T : \\mathbb{R}^3 \\to \\mathbb{R}^4$ such that $$T\\left( \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} \\right) = \\begin{pmatrix} 1 \\\\ 3 \\\\ 0 \\\\ 1 \\end{pmatrix}, \\quad T\\left( \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix} \\right) = \\begin{pmatrix} 2 \\\\ 2 \\\\ -1 \\\\ 4 \\end{pmatrix}, \\quad T\\left( \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} \\right) = \\begin{pmatrix} 0 \\\\ 4 \\\\ 1 \\\\ 6 \\end{pmatrix}$$</p>"},{"location":"tutorials/tut11/#b","title":"(b)\u00b6","text":"<p>$T : \\mathbb{R}^2 \\to \\mathbb{R}^2$ such that $$T\\left( \\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix} \\right) = \\begin{pmatrix} 2 \\\\ 0 \\end{pmatrix}, \\quad T\\left( \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} \\right) = \\begin{pmatrix} 0 \\\\ 2 \\end{pmatrix}, \\quad T\\left( \\begin{pmatrix} 2 \\\\ 0 \\end{pmatrix} \\right) = \\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix}$$</p>"},{"location":"tutorials/tut11/#c","title":"(c)\u00b6","text":"<p>$T : \\mathbb{R}^3 \\to \\mathbb{R}$ such that $$T\\left( \\begin{pmatrix} 1 \\\\ -1 \\\\ 0 \\end{pmatrix} \\right) = -1, \\quad T\\left( \\begin{pmatrix} 0 \\\\ 1 \\\\ -1 \\end{pmatrix} \\right) = 1, \\quad T\\left( \\begin{pmatrix} -1 \\\\ 0 \\\\ 1 \\end{pmatrix} \\right) = 0$$</p>"},{"location":"tutorials/tutorial/","title":"Tutorial: Getting Started","text":"<p>This guide is designed for undergraduate students who are new to Python and want to use this library for linear algebra computations. The <code>symbolic.Matrix</code> class is built on top of SymPy, a powerful Python library for symbolic mathematics, and is tailored for the NUS MA1522 course (AY 24/25 Sem 1). You may also find an interactive version of this tutorial here: Demo Notebook.</p>"},{"location":"tutorials/tutorial/#1-installation-and-setup","title":"1. Installation and Setup","text":"<p>First, you need to set up your Python environment. We recommend using a Jupyter Notebook for an interactive experience.</p> <p>Prerequisites</p> <ul> <li>Python 3.10+</li> <li>Jupyter Notebook or JupyterLab</li> </ul> <p>Follow these steps to get everything set up:</p> <ol> <li> <p>Create and activate a virtual environment:</p> <ul> <li>On Windows:   Bash<pre><code>python -m venv venv\nvenv\\Scripts\\activate\n</code></pre></li> <li>On macOS/Linux:   Bash<pre><code>source venv/bin/activate\n</code></pre></li> </ul> </li> <li> <p>Install dependencies: Bash<pre><code>pip install ma1522-linear-algebra notebook\n</code></pre></p> </li> <li> <p>Start Jupyter: Bash<pre><code>jupyter notebook\n</code></pre></p> </li> </ol> <p>Now, create a new notebook and you're ready to go!</p>"},{"location":"tutorials/tutorial/#2-creating-matrices","title":"2. Creating Matrices","text":"<p>Let's start by importing the necessary functions and creating our first matrices.</p> Python<pre><code>from ma1522 import Matrix, display\n</code></pre>"},{"location":"tutorials/tutorial/#from-a-list-of-lists","title":"From a List of Lists","text":"<p>The most straightforward way to create a matrix is from a list of lists, where each inner list represents a row.</p> Python<pre><code>A = Matrix([[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]])\ndisplay(A)\n</code></pre>"},{"location":"tutorials/tutorial/#from-rmlatex","title":"From \\(\\rm\\LaTeX\\)","text":"<p>A key feature of this library is the ability to create a matrix directly from a \\(\\rm\\LaTeX\\) string. This is incredibly useful for copying matrices from online resources or textbooks.</p> Python<pre><code>latex_expr = r'\\begin{pmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\end{pmatrix}'\nB = Matrix.from_latex(latex_expr)\ndisplay(B)\n</code></pre>"},{"location":"tutorials/tutorial/#from-string-representation","title":"From String Representation","text":"<p>You can also create a matrix from a string representation, similar to how you might define it in MATLAB.</p> Python<pre><code>C = Matrix.from_str('1 a 3; 4 b**2 6; 7 pi 9', row_sep=';', col_sep=' ')\ndisplay(C)\n</code></pre>"},{"location":"tutorials/tutorial/#special-matrices","title":"Special Matrices","text":"<p>You can also create special matrices easily.</p> <ul> <li> <p>Identity Matrix: Python<pre><code>I = Matrix.eye(3)\ndisplay(I)\n</code></pre></p> </li> <li> <p>Zero Matrix: Python<pre><code>Z = Matrix.zeros(2, 3)\ndisplay(Z)\n</code></pre></p> </li> <li> <p>Symbolic Matrix: Create a matrix with symbolic entries. This is useful to solve matrices whose entries are not known ahead of time.   Python<pre><code>S = Matrix.create_unk_matrix(2, 2, 's')\ndisplay(S)\n</code></pre></p> </li> </ul>"},{"location":"tutorials/tutorial/#3-basic-operations","title":"3. Basic Operations","text":"<p>The <code>Matrix</code> class supports standard matrix operations.</p> Python<pre><code>A = Matrix([[1, 2], [3, 4]])\nB = Matrix([[5, 6], [7, 8]])\n\n# Addition\ndisplay(A + B)\n\n# Scalar Multiplication\ndisplay(2 * A)\n\n# Matrix Multiplication\ndisplay(A @ B)\n\n# Transpose\ndisplay(A.T)\n</code></pre>"},{"location":"tutorials/tutorial/#4-solving-linear-systems","title":"4. Solving Linear Systems","text":"<p>Let's solve the matrix equation \\(Ax = b\\).</p> Python<pre><code>A = Matrix([[1, 2, 3],\n            [4, 5, 5],\n            [7, 8, 9]])\n\nb = Matrix([[1],\n            [2],\n            [3]])\n\n# Solve directly\nx = A.solve(rhs=b)\ndisplay(x)\n</code></pre>"},{"location":"tutorials/tutorial/#using-row-reduction","title":"Using Row Reduction","text":"<p>Alternatively, you can use row reduction on an augmented matrix.</p> <ol> <li> <p>Create an augmented matrix: Python<pre><code>augmented_matrix = A.aug_line().row_join(b)\ndisplay(augmented_matrix)\n</code></pre>     The <code>aug_line()</code> method adds a visual separator.</p> </li> <li> <p>Compute the Reduced Row Echelon Form (RREF): Python<pre><code>rref_matrix, pivots = augmented_matrix.rref()\ndisplay(rref_matrix)\n</code></pre></p> </li> <li> <p>Step-by-step Row Echelon Form (REF):     For a detailed, step-by-step reduction, use the <code>ref()</code> method with <code>verbosity</code>.</p> Python<pre><code># Create a new augmented matrix for demonstration\naugmented_matrix_2 = A.aug_line().row_join(b)\n\n# verbosity=1 shows the operations\n# verbosity=2 shows the matrix at each step\nplu = augmented_matrix_2.ref(verbosity=2)\n</code></pre> </li> </ol>"},{"location":"tutorials/tutorial/#5-advanced-topics","title":"5. Advanced Topics","text":"<p>The library provides functions for various advanced linear algebra concepts.</p>"},{"location":"tutorials/tutorial/#eigenvalues-and-eigenvectors","title":"Eigenvalues and Eigenvectors","text":"Python<pre><code>A = Matrix([[4, -1, 6],\n            [2,  1, 6],\n            [2, -1, 8]])\n\n# Eigenvalues\neigenvals = A.eigenvals()\nprint(eigenvals)\n\n# Eigenvectors\neigenvects = A.eigenvects()\ndisplay(eigenvects)\n</code></pre>"},{"location":"tutorials/tutorial/#diagonalization","title":"Diagonalization","text":"<p>You can check if a matrix is diagonalizable and perform the diagonalization.</p> Python<pre><code># Perform diagonalization (P, D)\nP, D = A.diagonalize()\ndisplay(P)\ndisplay(D)\n\n# Verify A = PDP^-1\ndisplay(P @ D @ P.inv())\n</code></pre>"},{"location":"tutorials/tutorial/#orthogonal-diagonalization","title":"Orthogonal Diagonalization","text":"<p>For symmetric matrices, you can perform orthogonal diagonalization.</p> Python<pre><code>S = Matrix([[5, -2, 0],\n            [-2, 8, 0],\n            [0, 0, 4]])\n\nif S.is_orthogonally_diagonalizable:\n    P, D = S.orthogonally_diagonalize()\n    display(P)\ndisplay(D)\n    # Verify S = PDP^T\ndisplay(P @ D @ P.T)\n</code></pre>"},{"location":"tutorials/tutorial/#singular-value-decomposition-svd","title":"Singular Value Decomposition (SVD)","text":"Python<pre><code>A = Matrix([[1, 2], [2, 2], [2, 1]])\nU, S, V = A.singular_value_decomposition()\n\nprint(\"U:\")\ndisplay(U)\nprint(\"S:\")\ndisplay(S)\nprint(\"V:\")\ndisplay(V)\n\n# Verify A = U * S * V.T\ndisplay(U @ S @ V.T)\n</code></pre>"},{"location":"tutorials/tutorial/#6-subspace-analysis","title":"6. Subspace Analysis","text":"<p>The 4 fundamental subspaces of a matrix.</p> Python<pre><code>A = Matrix([[1, 2, 3, 4],\n            [5, 6, 7, 8],\n            [9, 10, 11, 12]])\n\n# Column Space\ncol_space = A.columnspace()\ndisplay(Matrix.from_list(col_space))\n\n# Null Space\nnull_space = A.nullspace()\ndisplay(Matrix.from_list(null_space))\n\n# Row Space\nrow_space = A.rowspace()\ndisplay(Matrix.from_list(row_space, row_join=False))\n\n# Left Null Space (Orthogonal Complement)\north_comp = A.orthogonal_complement().T\ndisplay(orth_comp)\n</code></pre> <p>This tutorial covers the core functionalities of the <code>symbolic.Matrix</code> class.  Selected questions and suggested methods to solve them are provided in the other pages. For more details on specific functions, you can refer to the API Reference.</p>"}]}